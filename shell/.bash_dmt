#!/bin/bash

DMT_CLI="$DMT_NODE_CORE/dmt-controller/cli/dmt.js"

function dmt {
  if [ -z "$1" ] || [ "$1" == "help" ] || [ "$1" == "version" ]; then
    printf "${MAGENTA}     ‚àû DMT ‚àû${NC}\n"
    printf "${CYAN}Liberate yourself.${NC}\n"
    echo
  fi

  # extract host from @ symbol but replace @all with the name of current network !
  local hosts=""

  local args
  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"
  do
    if [ "$arg" == "@all" ]; then
      local network_id=''
      get_current_network network_id
      if [ -n "$network_id" ]; then
        hosts="${hosts} @@$network_id"
        shift
      fi
    elif [[ "$arg" == @* ]] && [[ ! "$arg" =~ = ]]; then # @attr=val should not be treated as hostnames
      hosts="${hosts} ${arg}"
      shift
    fi
  done

  hosts=$(echo "$hosts" | xargs) # remove trailing whitespace

  # report if a process named "dmt-proc" is currently running
  local proc=$(ps -ef | grep "dmt-proc" | grep -v "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')
  local proc_manager=$(ps -ef | grep "dmt-proc" | grep "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -z "$hosts" ]; then # if we're targeting remote hosts, information about our own local process is irrelevant
    if [ -n "$proc" ]; then
      printf "${CYAN}dmt-proc${NC} seems to be running with ${YELLOW}pid ${proc}${NC}\n"
    elif [ "$1" != "start" ]; then
      echo
        printf "‚ö†Ô∏è  ${CYAN}dmt-proc${NC} ${MAGENTA}does not seem to be running${NC} ${YELLOW}‚Üí use${NC} ${GREEN}dmt start${NC} üöÄ\n"
        if [ -n "$proc_manager" ]; then
          printf ".... ${GREEN}looks like dmt process manager is currently (re)starting ${YELLOW}dmt-proc${NC} ....\n"
        fi
    fi
    echo
  fi
  # ----

  declare -a opts=(
    "help"
    "docs"
    "info"
    "status"
    "version"
    "device"
    "services"
    "next"
    "core"
    "update"
    "debug"
    "renew"
    "remove"
    "log"
    "logfg"
    "install"
    "start"
    "startfg"
    "restart"
    "restart2"
    "stop"
    "symlink"
    "deactivate"
    "remove"
    "bin"
    "music"
    "search"
  )

  if dev_machine; then
    declare -a opts_admin=(
      "cd"
    )

    opts=("${opts[@]}" "${opts_admin[@]}")
  fi

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    if [ -z "$hosts" ]; then
      printf "Try ${GREEN}dmt help${NC} as well.\n"
      if [ -z "$1" ] && [ -n "$proc" ] ; then
        echo
        printf "${CYAN}This device info:${NC}\n\n"
        if [ ! -f "$DMT_DEVICE_FILE" ]; then
          printf "${RED}Reminder ‚óè ${GRAY}you still need to configure this device ‚óè ${CYAN}please run ‚Üí \n\n${GREEN}  dmt device select${NC}\n\n"
          return
        fi
      fi
    fi

    if [ -z "$1" ]; then
      matching_opt="info"
    else
      return
    fi
  fi

  shift

  case "$matching_opt" in
    help)
      dmt_help
      ;;

    docs)
      dmt_docs
      ;;

    info)
      if [ -n "$hosts" ]; then
        node "$DMT_CLI" "${hosts}" info "$@"
      else
        if [ -n "$proc" ]; then
          node "$DMT_CLI" info "$@"
        fi
      fi
      ;;

    debug)
      local markerfile="$DMT_STATE/.debug-mode"
      if [ -z "$1" ] || [ "$1" == "on" ] || [ "$1" == "enable" ]; then
        if [ -f "$markerfile" ]; then
          printf "${GRAY}Debug mode ${YELLOW}was already enabled${NC}\n"
        else
          touch "$markerfile"
          printf "${YELLOW}Debug mode ‚öôÔ∏è  enabled${NC}\n"
        fi

        printf "\n${MAGENTA}Micro-Debugging options:${NC}\n"

        printf "\nEdit ${YELLOW}${markerfile}${NC} file to increase debug log level (one line, one category like ${GREEN}mpv${NC}, ${GREEN}lan${NC} etc.)${NC}\n"

        echo

        printf "${GREEN}mpv${NC} ${GRAY}enables mpv process logging into ~/.dmt/log/mpv.dmt (requires dmt restart ${GREEN}while other commands do not!${NC})${NC}\n"
        printf "${GREEN}mpv:ipc${NC} ${GRAY}enables debug messages between ${MAGENTA}dmt-process${NC} ${GRAY}and${NC} ${CYAN}mpv${NC} ${GRAY}process${NC}\n"
        printf "${GREEN}ws${NC} ${GRAY}enables debug messages about websocket connections (port 7780 -- metagui)${NC}\n"
        printf "${GREEN}lan${NC} ${GRAY}enables debug messages about lanbus${NC}\n"
      fi

      if [ "$1" == "off" ] || [ "$1" == "disable" ] || [ "$1" == "stop" ]; then
        if [ -f "$markerfile" ]; then
          rm "$markerfile"
          printf "${GREEN}Debug mode disabled üèÑ${NC}\n"
        else
          printf "${GRAY}Debug mode was already disabled${NC}\n"
        fi
      fi
      ;;

    search)
      if [ -n "$hosts" ]; then
        search "${hosts}" "$@"
      else
        search "$@"
      fi
      ;;

    music)
      if [ -n "$hosts" ]; then
        m "${hosts}" "$@"
      else
        m "$@"
      fi
      ;;

    services)
      if [ -n "$hosts" ]; then
        node "$DMT_CLI" "${hosts}" services "$@"
      else
        node "$DMT_CLI" services "$@"
      fi
      ;;

    version)
      dmt_version
      ;;

    device)
      dmt_device "$@"
      ;;

    next)
      dmt_next
      #gui reload
      #dmt restart
      ;;

    core)
      dmt_core "$@"
      ;;

    update) # updates the whole folder, doesn't restart the service
      dmt_update "$@"
      ;;

    renew) # updates the whole folder and restarts the service
      dmt_renew "$@"
      ;;

    remove)
      dmt_remove
      ;;

    install)
      dmt_install "$@"
      ;;

    deactivate)
      dmt_deactivate
      ;;

    symlink)
      local cwd="`pwd`"
      cd "$DMT_NODE_CORE/.scripts"
      ./symlink_dmt_deps "$@"
      cd "$cwd"
      ;;

    start)
      printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is starting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" start
      printf "\n${CYAN}dmt-proc${NC} ${GRAY}should now be running, use ${GREEN}dmt log ${GRAY}to see events and information.${NC}\n"
      ;;

    stop)
      printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is stopping...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" stop
      ;;

    restart)
      printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is restarting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" restart
      if [ $? -eq 0 ]; then
        printf "\n${CYAN}dmt-proc${NC} ${GRAY}restarted, use ${GREEN}dmt log ${GRAY}to see events and information.${NC}\n"
      fi
      ;;

    restart2)
      printf "${CYAN}DMT${NC} ${WHITE}is *fully* restarting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" stop
      killall mpv
      killall dmt-proc
      "${DMT_PATH}/etc/onboot/daemons" start
      ;;

    log)
      dmt_log "$@"
      ;;

    # FOREGROUND

    logfg)
      dmt_log fg "$@"
      ;;

    startfg)
      printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is starting in ${CYAN}foreground${NC} ...\n\n"
      node --trace-warnings "${DMT_NODE_CORE}/dmt-controller/daemons/dmt-proc.js"
      ;;

    # undocumented:

    flash)
      dmt_flash "$@"
      ;;

    bin)
      dmt_bin "$@"
      ;;

    cd)
      dmt_cd
      ;;

  esac
}

function dmt_device {
  declare -a opts=(
    "cd"
    "select"
    "def"
    "edit"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    local device_name=''
    get_current_device device_name

    if [ -n "$device_name" ]; then
      printf "${CYAN}Device name: üí° ${MAGENTA}${device_name}${NC}\n\n"
    else
      printf "${GRAY}This device is ${RED}unnamed ü§î${GRAY}, please name it by running ${GREEN}dmt device select${GRAY} (or shorter: ${GREEN}dev sel${GRAY}).${NC}\n\n"
      return
    fi

    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd${NC} ${GRAY}move to directory with curent device's configuration${NC}\n"
    printf "${GREEN}select${NC} ${GRAY}select configuration for this device from existing configurations or create a new configuration and assign it to this device${NC}\n"
    printf "${GREEN}def${NC} ${GRAY}shows parsed device.def definition in json format${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}edit current device's device.def${NC}\n"
    return
  fi

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"

  shift

  case "$matching_opt" in
    cd)
      device_helper cd
      ;;

    edit)
      device_helper edit
      ;;

    select)
      local script="$DMT_SCRIPTS/setup_device"
      if [ -f "$script" ]; then
        "$script"
      fi
      ;;

    def)
      printf "${YELLOW}Showing parsed defice definition:${NC}\n"
      local cli="$DMT_NODE_CORE/dmt-controller/cli/device.js"
      if [ -n "$hosts" ]; then
        node "$cli" "${hosts}" "$@"
      else
        node "$cli" "$@"
      fi
      ;;
  esac
}

function dev {
  dmt_device "$@"
}

function device_helper {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd${NC} ${GRAY}${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}${NC}\n"
    printf "${GREEN}list${NC} ${GRAY}${NC}\n"
    printf "${GREEN}ping${NC} ${GRAY}${NC}\n"
  else
    declare -a opts=(
      "cd"
      "edit"
      "list"
      "ping"
    )

    local matching_opt=''
    opts_matcher matching_opt "$1" "${opts[@]}"
    if [ $? -ne 0 ]; then # error
      printf "${YELLOW}Use ${GREEN}help ${YELLOW}for more options${NC}\n\n"
      #matching_opt="aaa" # default
    fi

    shift

    case "$matching_opt" in
      cd)
        if [ -z "$1" ]; then
          AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices
          if [ $? -eq 0 ] && [ -d "this/def" ]; then
            cd "this/def"
          fi
        else
          AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices "$1"

          if [ $? -eq 0 ]; then
            if [ -d "def" ]; then
              cd "def"
            fi
          else
            printf "${RED}not found${NC}\n"
          fi
        fi
        ;;

      edit)
        local dir="${DMT_USER_PATH}/devices/this"
        if [ -d "$dir" ]; then
          local file="${dir}/def/device.def"
          if [ -f "$file" ]; then
            e "$file"
          else
            echo $file
            printf "${RED}device.def file not found${NC}\n"
          fi
        else
          printf "${RED}Device is unknown${GRAY}, please select the definition file by using ${GREEN}dev select${GRAY}, then try again.${NC}\n"
        fi
        ;;

      # edit)
      #   local file="${DMT_USER_PATH}/devices/devices.json"
      #   if [ -f "$file" ]; then
      #     e "$file"
      #   else
      #     printf "${RED}File not found${NC}\n"
      #   fi
      #   ;;

      list)
        for_all_devices "list"
        ;;

      ping)
        for_all_devices
        ;;

      # exec)
      #   for_all_devices "exec" "$@"
      #   ;;

      # update)
      #   for_all_devices "update"
      #   ;;
    esac
  fi
}

function state {

  if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}state${NC} ${GRAY}show program state${NC}\n"
    printf "${GREEN}state [store]${NC} ${GRAY}show a specific store state (controller, player etc.)${NC}\n"
    printf "${GREEN}state [store].[key]${NC} ${GRAY}ex.: player.playlist, controller.weather${NC}\n"
    printf "${GREEN}state purge${NC} ${GRAY}delete program state${NC}\n"
    return
  fi

  local DMT_STATE_FILE="$DMT_PATH/state/program.json"

  if [ -f "$DMT_STATE_FILE" ]; then
    if [ "$1" == "purge" ]; then
      if [ -f "$DMT_STATE_FILE" ]; then
        #dmt stop
        rm "$DMT_STATE_FILE"
        printf "${GREEN}purged dmt state${NC}\n"
        #dmt start
      fi
    else
      if [ -n "$1" ]; then
        cat "${DMT_STATE_FILE}" | jq ".$1"
      else
        cat "${DMT_STATE_FILE}" | jq
      fi
    fi
  else
    printf "${YELLOW}dmt state not found on disk${NC}\n"
  fi
}

function gui_build_all {
  local cwd="`pwd`"

  local base_dir="$DMT_PATH/core/node/dmt-gui/gui-frontend-core"

  cd "$base_dir"

  for component in *; do
    if [ -d "$component" ] && [ "$component" != "common_assets" ]; then
      cd $component
      if [ -f "package.json" ]; then
        npm run build
      else
        echo "not sure how to build this gui component: ${component}"
      fi
    fi
    cd "$base_dir"
  done

  cd "$cwd"
}

function gui {
  local dir="$DMT_PATH/core/node/dmt-gui/gui-frontend-core"
  local backendDir="$DMT_PATH/core/node/dmt-gui/gui-backend"

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}gui cd [gui]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}gui run [gui]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}gui build${NC} ${GRAY}build all GUIs${NC}\n"
    printf "${GREEN}gui build [gui]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}gui reload${NC} ${GRAY}send request to frontend via websocket requesting refresh of current url${NC}\n"
    printf "${GREEN}gui reload [gui]${NC} ${GRAY}reloads the specified gui view (home, player, debug etc.)${NC}\n"
    printf "${GREEN}gui debug${NC} ${GRAY}shows debugging info for current gui issues troubleshooting${NC}\n"
    return
  fi

  case "$1" in
    cd)
      awesome_cd "$dir" "$2"
      if [ $? -eq 0 ] && [ -d "src" ]; then
        cd "src"
      fi
      ;;

    reload)
      local action="reload"
      if [ -n "$2" ]; then
        action="${action}:${2}"
      fi
      node "${backendDir}/ws_servers/index.js" localhost "$action" frontend
      ;;

    run)
      if [ -z "$2" ]; then
        npm run dev
      else
        awesome_cd "$dir" "$2"
        if [ $? -eq 0 ]; then
          npm run dev
        fi
      fi
      ;;

    build)
      if [ -z "$2" ]; then
        gui_build_all
        return
      fi

      awesome_cd "$dir" "$2"
      if [ $? -eq 0 ]; then
        npm run build
      fi
      ;;

    debug)
      echo "TODO"
      ;;

    *)
      awesome_cd "$dir" "$1"
      ;;
  esac
}

function dmt_log {
  local foreground=false

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt log${NC} ${GRAY}get last 10 log lines on this machine${NC}\n"
    printf "${GREEN}dmt @host log${NC} ${GRAY}get last 10 log lines for remote machine${NC}\n"
    printf "${GREEN}dmt logfg${NC} ${GRAY}local log in foreground (updates are visible as they come)${NC}\n"
    return
  fi

  local logfile="$DMT_PATH/log/dmt.log"

  if [ "$1" == "fg" ]; then
    tail -f -n 100 "$logfile"
  else
    if [ -n "$hosts" ]; then
      node "$DMT_CLI" "${hosts}" log "$@"
    else
      node "$DMT_CLI" log "$@"
    fi
  fi
}

function dmt_help {
  printf "${YELLOW}Info:${NC}\n"
  printf "${GREEN}dmt help ${GRAY}shows this help${NC}\n"
  printf "${GREEN}dmt docs ${MAGENTA}shows documentation in a browser${NC}\n"
  printf "${GREEN}dmt version ${GRAY}shows dmt version, like v$(cat "$DMT_PATH/.version")${NC}\n"
  printf "${GREEN}dmt device ${GRAY}device configuration and information${NC}\n"
  echo
  printf "${YELLOW}Clone to more of your devices:${NC}\n"
  printf "${GREEN}dmt next ${GRAY}gets the latest code from public repo on github (DMT SYSTEM never auto-updates)${NC}\n"
  printf "${GREEN}dmt update [host] ${GRAY}or ${GREEN}dmt install [host] ${GRAY}clones dmt to another machine of yours (via SSH)${NC}\n"
  printf "${GREEN}dmt deactivate ${GRAY}deactivates shell but keep it present (to get it back just do ${CYAN}./install${GRAY})${NC}\n"
  printf "${GREEN}dmt remove ${GRAY}self-destroys on this machine (except the user definitions and data)${NC}\n"
  echo
  printf "${MAGENTA}dmt-proc ${YELLOW}management:\n${NC}"
  printf "${CYAN}‚ñ† services will not persist after reboot ‚Äî ${MAGENTA}use the docs${CYAN} to easily configure this.${NC}"
  echo
  printf "${GREEN}dmt start ${GRAY}starts the background services üí°üöÄüé∏${NC}\n"
  printf "${GREEN}dmt stop ${GRAY}self-describing${NC}\n"
  printf "${GREEN}dmt restart ${GRAY}self-describing${NC}\n"
  echo
  printf "${GREEN}dmt info ${GRAY}gets information about current device${NC}\n"
  printf "${GREEN}dmt @hostOrIp info ${GRAY}gets information about a device on local network${NC}\n"
  printf "${GREEN}dmt @@remoteIpOrHost info ${GRAY}gets information about remote device on the other side of router WAN port${NC}\n"
  echo
  printf "${GREEN}dmt log ${GRAY}gets latest log of recent activity (only if daemons are running)${NC}\n"
  printf "${GREEN}dmt @hostOrIp log ${GRAY}self-describing${NC}\n"
  printf "${GREEN}dmt @@remoteIpOrHost log ${GRAY}self-describing${NC}\n"
}

function dmt_docs {
  if [ -f ~/.dmt/docs/index.html ]; then
    open ~/.dmt/docs/index.html
  else
    printf "${RED}Docs missing${NC}\n"
  fi
  #open https://github.com/uniqpath/dmt/blob/master/docs/README.md
}

function dmt_version {
  printf "${MAGENTA}v$(cat "$DMT_PATH/.version")${NC}\n\n"
  local NUM=$(cat $HOME/.bash_aliases | grep function | wc -l | xargs)
  printf "${WHITE}${NUM} bash functions ${GRAY}\nin ~/.bash_aliases${NC}\n"
}

function dmt_devices {
  devices "$@"
}

function dmt_next {
  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  local cwd="`pwd`"

  cd "$DMT_PATH"
  git fetch
  git reset --hard origin/master

  if [ -d "./core/.git" ]; then
    cd core
    git fetch
    git reset --hard origin/master
    cd ..
  fi

  if [ -d "./bin/.git" ]; then
    cd bin
    git fetch
    git reset --hard origin/master
    cd ..
  fi

  if [ -d "$DMT_NODE_CORE/.scripts" ]; then
    cd "$DMT_NODE_CORE/.scripts"
    ./symlink_dmt_deps
  fi

  rel

  cd "$cwd"
}

function dmt_core {
  printf "${MAGENTA}CURRENT DMT-CORE REPO${NC}\n"
  cat "$DMT_CORE/.git/config" | grep "url ="

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt core [handle]${NC} ${GRAY}replaces current core with the one at github.com/[handle]/dmt${NC}\n"
    return
  fi

  local DMT_CORE_BACKUP="$DMT_PATH/cores_extra/prev-core-backup"

  if [ -d "$DMT_CORE_BACKUP" ]; then
    rm -rf "$DMT_CORE_BACKUP"
  fi

  mkdir -p "$DMT_CORE_BACKUP"

  if [ -d "$DMT_CORE" ]; then
    printf "${GRAY}Backing up current core to ${YELLOW}${DMT_CORE_BACKUP}${NC}\n"
    mv "$DMT_CORE" "$DMT_CORE_BACKUP"
  fi

  local cwd="`pwd`"

  cd "$DMT_PATH"
  git clone "https://github.com/${1}/dmt-core" core

  if [ -d "$DMT_NODE_CORE/.scripts" ]; then
    cd "$DMT_NODE_CORE/.scripts"
    ./symlink_dmt_deps
  fi

  dmt_core "-h"

  cd "$cwd"
}

function dmt_install {
  # multi install: dmt update dev1 dev2 ... devn
  if [ -n "$2" ]; then
    for dev in "$@"
    do
      dmt_install "$dev"
    done
    return
  fi

  local cwd="`pwd`"
  cd "$DMT_PATH"
  . ./install "from-dmt-install" "$@" # calling with . preserves the newly loaded env
  cd "$cwd"
}

function dmt_update {
  if [ -z "$1" ]; then
    if dev_machine; then
      printf "${RED}Prevented on dev machine${NC}\n"
    fi
  else
    dmt_install "$@"
  fi
}

function u {
  dmt_update "$@"
}

function re {
  dmt_renew "$@"
}

function dmt_renew {
  # supports multi install: dmt renew dev1 dev2 ... devN
  if [ -z "$2" ]; then
    dmt_update "$1"
    restart_remote_device "$1"
  else
    for device in "$@"
    do
      dmt_renew "$device"
    done
  fi
}

function dmt_remove {
  printf "${GRAY}Please copy and execute:${NC}\n\n"
  printf "1) ${GREEN}dmt deactivate${NC}\n"
  printf "2) ${RED}rm -rf ~/.dmt${NC}\n"
}

function restart_remote_device {
  local cmd="source ~/.dmt/etc/.bash_aliases_slim && se \\\"if [ -f ~/.dmt/user/devices/this/before-renew ]; then ~/.dmt/user/devices/this/before-renew; fi; ~/.dmt/etc/onboot/daemons restart\\\""

  local host="$1"

  if [ "$host" == "ap" ]; then
    host="$DMT_AP_DEFAULT_HOST"
  else
    local matching_host=''
    local ssh_port=''
    get_full_host matching_host ssh_port "$host"
    if [ $? -ne 1 ]; then # not error
      host="$matching_host"
    fi
  fi

  if [ -n "$host" ]; then
    remote -h "$host" --port "$ssh_port" "$cmd"
  else
    printf "${RED}Unknown host${NC}\n"
  fi
  #fi
}

function dmt_deactivate {
  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  local backup_file="$HOME/.bash_aliases-backup-by-dmt"

  if [ -L "$LOGNAME_HOME/.bash_aliases" ] && [ "$(head -3 $LOGNAME_HOME/.bash_aliases | tail -1)" == "# DMT ALIASES" ]; then
    rm ~/.bash_aliases

    if [ -f "$backup_file" ]; then
      mv "$backup_file" ~/.bash_aliases
    fi

    printf "${MAGENTA}dmt${NC} ${CYAN}was unlinked${NC}, only the folder ${CYAN}~/.dmt${NC} remains and is not active in any way.\n"
    echo
    printf "${CYAN}To reinstall${NC}\n"
    printf "${GREEN}cd $HOME/.dmt${NC}\n"
    printf "${GREEN}./install${NC}\n"
    echo
    printf "${CYAN}To remove the unused directory${NC}\n"
    printf "${GREEN}rm -rf $HOME/.dmt${NC}\n"
    echo
    printf "${WHITE}If you want to confirm that dmt is uninstalled you have to first reload the shell.${NC}\n"
  else
    printf "${RED}dmt is not installed${NC}\n"
  fi
}

function dmt_cd {
  cd "$DMT_PATH"
}

function dmt_bin {
  declare -a opts=(
    "compile"
    "download"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "${opts[@]}"
    return
  fi

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "Use -h to see valid options\n\n"
    #matching_opt="aaa" # default
    return
  fi

  shift

  case "$matching_opt" in
    compile)
      if [ -d $DMT_RUST_CORE ]; then
        dmt_compile_bin
      else
        echo "rust core doesn't exists"
      fi
      ;;

    download)
      ;;
  esac
}

function dmt_compile_bin {
  local cwd="`pwd`"

  # todo: ... + generalize the process somehow....

  printf "${MAGENTA}$DMT_RUST_CORE/walkdir${NC}\n"
  if [ -d "$DMT_RUST_CORE/walkdir" ]; then
    cd "$DMT_RUST_CORE/walkdir"
    cargo build --release --example walkdir
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/examples/walkdir "${DMT_PLATFORM_BIN}/walkdir" >/dev/null 2>&1; then
        printf "${GREEN}‚úì Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/examples/walkdir "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}‚úì Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  echo

  printf "${MAGENTA}$DMT_RUST_CORE/walksearch${NC}\n"
  if [ -d "$DMT_RUST_CORE/walksearch" ]; then
    cd "$DMT_RUST_CORE/walksearch"
    cargo build --release
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/walksearch "${DMT_PLATFORM_BIN}/walksearch" >/dev/null 2>&1; then
        printf "${GREEN}‚úì Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/walksearch "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}‚úì Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  cd "$cwd"
}

