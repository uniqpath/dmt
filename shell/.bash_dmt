#!/bin/bash

DMT_CLI="$DMT_NODE_CORE/controller/cli/dmt.js"

function dmt {
  if [ -z "$1" ] || [ "$1" == "help" ] || [ "$1" == "version" ]; then
    printf "${MAGENTA}      âˆž DMT âˆž${NC}\n"
    printf "${CYAN}Freedom to imagine${NC}\n"
    #printf "${CYAN}${NC}\n"
    echo
  fi

  # dmt [command] @hosts [terms]
  local command=''

  if [[ "$1" != @* ]]; then
    command="$1"
    shift
  fi

  # extract host from @ symbol but replace @all with the name of current network !
  local hosts=""

  local args
  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"
  do
    if [ "$arg" == "@all" ]; then
      local network_id=''
      get_current_network network_id
      if [ -n "$network_id" ]; then
        hosts="${hosts} @@$network_id"
        shift
      fi
    elif [[ "$arg" == @* ]] && [[ ! "$arg" =~ = ]]; then # @attr=val should not be treated as hostnames
      hosts="${hosts} ${arg}"
      shift
    fi
  done

  hosts=$(echo "$hosts" | xargs) # remove trailing whitespace

  declare -a opts=(
    "help"
    "info"
    "gui"
    "status"
    "version"
    "device"
    "services"
    "next"
    "core"
    "update"
    "debug"
    "renew"
    "log"
    "logfg"
    "loglan"
    "install"
    "start"
    "startfg"
    "startprofiler"
    "restart"
    "restart2"
    "stop"
    "state"
    "link"
    "unlink"
    "relink"
    "deactivate"
    "bin"
    "media"
    "search"
    "rel"
  )

  if dev_machine; then
    declare -a opts_admin=(
      "cd"
    )

    opts=("${opts[@]}" "${opts_admin[@]}")
  fi

  if [ -z "$command" ] || [ "$command" == '-h' ] || [ "$command" == '--help' ]; then
    command="help"
  fi

  local matching_opt=''
  dmt_opts_matcher matching_opt "$command" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    if [ -z "$hosts" ]; then
      printf "Try ${GREEN}dmt help${NC}.\n"
      if [ -z "$1" ] && [ -n "$proc" ] ; then
        echo
        printf "${CYAN}This device info:${NC}\n\n"
        if [ ! -f "$DMT_DEVICE_FILE" ]; then
          printf "${RED}Reminder â— ${GRAY}you still need to configure this device â— ${CYAN}please run â†’ \n\n${GREEN}  dmt device select${NC}\n\n"
          return
        fi
      fi
    fi

    if [ -z "$1" ]; then
      matching_opt="help"
    else
      return
    fi
  fi

  local dmt_proc_pid=''
  local dmt_fg_bg=''
  get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

  local proc_manager=$(ps -ef | grep "dmt-proc" | grep "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -z "$hosts" ]; then # if we're targeting remote hosts, information about our own local process is irrelevant
    if [ "$matching_opt" != "next" ] && [ "$matching_opt" != "start" ] && [ "$matching_opt" != "startfg" ] && [ "$matching_opt" != "debug" ] && [ "$matching_opt" != "device" ]; then
      if [ -n "$dmt_proc_pid" ]; then
        printf "${WHITE}dmt-proc${NC} seems to be running with ${YELLOW}pid ${dmt_proc_pid}${NC}\n"
      elif [ "$matching_opt" != "stop" ] && [ "$matching_opt" != "restart" ]; then
        printf "âš ï¸  ${WHITE}dmt-proc${NC} ${RED}does not seem to be running${NC} ${YELLOW}â†’ use${NC} ${GREEN}dmt start${NC} ðŸš€\n"
        if [ -n "$proc_manager" ]; then
          printf ".... ${GREEN}looks like dmt process manager is currently (re)starting ${WHITE}dmt-proc${NC} ....\n"
        fi
      fi
      echo
    fi
  fi
  # ----

  case "$matching_opt" in
    help)
      dmt_help

      if [ -n "$hosts" ]; then
        dmt_help_explain_rpc
      else
        dmt_help_explain_rpc

        if [ -z "$dmt_proc_pid" ]; then
          printf "${GRAY}_____________________________________________________________________________${NC}\n"
          echo
          printf "${RED}âœ–${NC} ${MAGENTA}dmt-proc${NC} ${GRAY}is not running${NC}"
          printf " ${GRAY}â†’ please use ${GREEN}dmt start${NC} ${GRAY}to start it! ðŸ’¡ðŸš€ðŸŽ¸\n"
          echo
        else
          printf "${GREEN}âœ“${NC} ${CYAN}dmt-proc${NC} ${GRAY}is running on this device${NC}\n"
        fi
      fi
      ;;

    info)
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" info "$@"
      else
        if [ -n "$dmt_proc_pid" ]; then
          $DMT_NODEJS_EXEC "$DMT_CLI" info "$@"
        fi
      fi
      ;;

    rel)
      reload_shell
      ;;

    gui)
      if [ -n "$hosts" ]; then
        dmt_gui "$hosts" "$@"
      else
        # if [ -n "$dmt_proc_pid" ]; then
        #   node "$DMT_CLI" gui_test "$@"
        # fi
        dmt_gui "$@"
      fi
      ;;

    debug)
      local markerfile="$DMT_STATE/.debug-mode"
      local markerfile_display="~/.dmt/state/.debug-mode"

      # dmt debug edit
      if [ "$1" == "edit" ]; then
        echo "#mpv" > $markerfile
        echo "#mpv-ipc" >> $markerfile
        echo "#ws" >> $markerfile
        echo "#lanbus" >> $markerfile
        echo "#network-detect" >> $markerfile
        echo "#mqtt-sent" >> $markerfile
        echo "#mqtt-received" >> $markerfile

        nano $markerfile

        return
      fi

      if [ -z "$1" ] || [ "$1" == "on" ] || [ "$1" == "enable" ]; then
        if [ -f "$markerfile" ]; then
          printf "${GRAY}âœ“ Debug mode was already enabled${NC}\n"
        else
          touch "$markerfile"
          printf "${GREEN}âœ“ ${YELLOW}Debug mode âš™ï¸  enabled${NC}\n"
        fi

        printf "\n${MAGENTA}Debugging options:${NC}\n"

        printf "\nExecute ${GREEN}dmt debug edit${NC} and remove comments to increase particular debug log level (one line, one category).\n"
        printf "\nTo make it more permanent, add this to device.def ${GRAY}(command:${NC} ${GREEN}dev edit${NC}${GRAY})${NC}:\n"
        printf "${MAGENTA}debug:${NC}\n"
        printf "  ${MAGENTA}log: ${GRAY}mpv${NC}\n"
        printf "  ${MAGENTA}log: ${GRAY}lanbus${NC}\n"
        printf "  ${MAGENTA}log: ${GRAY}...${NC}\n"
        printf "\nâš ï¸  ${GRAY}This, however, requires ${GREEN}dmt restart${GRAY} while editing the ${YELLOW}.debug-mode${GRAY} file does not.${NC}\n"

        echo

        printf "${MAGENTA}Options:${NC}\n"
        printf "${MAGENTA}--------${NC}\n\n"

        printf "${GREEN}mpv${NC} ${GRAY}enables mpv process logging into ~/.dmt/log/mpv.log (requires dmt restart ${NC}while other commands do not!${NC})${NC}\n"
        printf "${GREEN}mpv-ipc${NC} ${GRAY}enables debug messages between ${MAGENTA}dmt-process${NC} ${GRAY}and${NC} ${CYAN}mpv${NC} ${GRAY}process${NC}\n"
        printf "${GREEN}ws${NC} ${GRAY}enables debug messages about websocket connections (port 7780 -- metagui)${NC}\n"
        printf "${GREEN}lanbus${NC} ${GRAY}enables debug messages about lanbus${NC}\n"
        printf "${GREEN}network-detect${NC} ${GRAY}enables debugging of current lan network and network segments identification${NC}\n"
        printf "${GREEN}mqtt-sent${NC} ${GRAY}enables debug messages about sent mqtt messages${NC}\n"
        printf "${GREEN}mqtt-received${NC} ${GRAY}enables debug messages about received mqtt messages${NC}\n"
        #printf "${GREEN}beats${NC} ${GRAY}todo${NC}\n"
      fi

      if [ "$1" == "off" ] || [ "$1" == "disable" ] || [ "$1" == "stop" ]; then
        if [ -f "$markerfile" ]; then
          rm "$markerfile"
          printf "${CYAN}Debug mode disabled${NC}\n"
        else
          printf "${GRAY}Debug mode was already disabled${NC}\n"
        fi
      fi
      ;;

    search)
      if [ -n "$hosts" ]; then
        dmt_search "${hosts}" "$@"
      else
        dmt_search "$@"
      fi
      ;;

    media)
      if [ -n "$hosts" ]; then
        dmt_media "${hosts}" "$@"
      else
        dmt_media "$@"
      fi
      ;;

    services)
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" services "$@"
      else
        $DMT_NODEJS_EXEC "$DMT_CLI" services "$@"
      fi
      ;;

    version)
      dmt_version
      ;;

    device)
      dmt_device "$@"
      ;;

    next)
      dmt_next "$@"
      ;;

    update) # updates the whole folder, doesn't restart the service
      dmt_update "$@"
      ;;

    renew) # updates the whole folder and restarts the service
      dmt_renew "$@"
      ;;

    deactivate)
      dmt_deactivate
      ;;

    link)
      local dir="$DMT_NODE_CORE/.scripts"
      if [ -d "$dir" ]; then
        local cwd="`pwd`"
        cd "$dir"
        ./symlink_dmt_deps
        # printf "${GREEN}Linked.${NC}\n"
        cd "$cwd"
      fi
      ;;

    unlink)
      local dir="$DMT_NODE_CORE/.scripts"
      if [ -d "$dir" ]; then
        local cwd="`pwd`"
        cd "$dir"
        ./symlink_dmt_deps "remove"
        # printf "${MAGENTA}Unlinked.${NC}\n"
        cd "$cwd"
      fi
      ;;

    # checklink)
    #   local cwd="`pwd`"
    #   cd "$DMT_NODE_CORE/.scripts"
    #   ./symlink_dmt_deps "check"
    #   cd "$cwd"
    #   ;;

    relink) #rarely used, usually "dmt link" is enough for this purpose as well... use "dmt relink" only if suddenly symlinks should point somewewhere else... if just some new symlinks have to be added, there is no need to unlink first, the symlinking script (dmt link) will add what's missing
      dmt unlink
      dmt link
      ;;

    start)
      if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
        return
      fi

      dmt_symlink_nodejs_deps
      compile_gui_if_missing

      printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is starting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" start

      # see if process is actually running
      local dmt_proc_pid=''
      local dmt_fg_bg=''
      get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

      if [ -n "$dmt_proc_pid" ]; then
        printf "\n${CYAN}dmt-proc${NC} ${GRAY}should now be running, use ${GREEN}dmt log ${GRAY}to see log entries.${NC}\n"
      else
        printf "\n${RED}Problem starting ${CYAN}dmt-proc${RED}, please use ${GREEN}dmt logfg ${RED}to determine the reason${NC}\n"
      fi
      ;;

    startfg) # START FOREGROUND
      if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
        return
      fi

      dmt_symlink_nodejs_deps
      compile_gui_if_missing

      printf "${MAGENTA}dmt-proc${NC} ${WHITE}is starting in ${CYAN}foreground${NC} ...\n\n"
      $DMT_NODEJS_EXEC --trace-warnings "${DMT_NODE_CORE}/controller/daemons/dmt-proc.js"  --fg # --fg: only for informative purposes to signal that we ran it in foreground as opposed to daemonizing (dmt start)
      ;;

    startprofiler)
      if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
        return
      fi

      dmt_symlink_nodejs_deps
      compile_gui_if_missing

      printf "${MAGENTA}dmt-proc${NC} ${WHITE}is starting in ${CYAN}foreground${NC} ...\n\n"
      $DMT_NODEJS_EXEC --trace-warnings --prof "${DMT_NODE_CORE}/controller/daemons/dmt-proc.js"  --fg # --fg: only for informative purposes to signal that we ran it in foreground as opposed to daemonizing (dmt start)
      ;;

    state)
      dmt_state "$@"
      ;;

    stop)
      local dmt_proc_pid=''
      local dmt_fg_bg=''
      get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

      if [[ $dmt_fg_bg == 'fg' ]]; then
        printf "${MAGENTA}dmt-proc${NC} ${RED}is already running in 'foreground'${NC}, it was started with ${CYAN}dmt startfg${NC} in another terminal tab.\n"
        printf "${YELLOW}Please go to the other terminal tab and press ${GREEN}CTRL+C${NC}\n"
        echo
        printf "You can also use ${GREEN}sudo kill -9 ${dmt_proc_pid}${NC} to kill the process now.\n"
        return
      fi

      if [ -n "$dmt_proc_pid" ]; then
        printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is stopping...${NC}\n\n"
        "${DMT_PATH}/etc/onboot/daemons" stop
      else
        printf "${YELLOW}dmt-proc is not currently running ...${NC}\n"
      fi
      ;;

    restart)
      dmt_symlink_nodejs_deps
      compile_gui_if_missing

      printf "${CYAN}DMT PROCESS${NC} ${MAGENTA}is restarting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" restart
      if [ $? -eq 0 ]; then
        #printf "\n${CYAN}dmt-proc${NC} ${GRAY}restarted, use ${GREEN}dmt log ${GRAY}to see log entries.${NC}\n"
        # see if process is actually running
        local dmt_proc_pid=''
        local dmt_fg_bg=''
        get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

        if [ -n "$dmt_proc_pid" ]; then
          printf "\n${CYAN}dmt-proc${NC} ${GRAY}restarted, use ${GREEN}dmt log ${GRAY}to see log entries.${NC}\n"
        else
          printf "\n${RED}Problem restarting ${CYAN}dmt-proc${RED}, please use ${GREEN}dmt logfg ${RED}to determine the reason${NC}\n"
        fi
      fi
      ;;

    log) # requestion to the service to get latest few log lines
      dmt_log "$@"
      ;;

    logfg) # show log in foreground and keep it updated
      dmt_log fg "$@"
      ;;

    loglan) # show LAN log in foreground and keep it updated
           # this will run a node listener process that will gather log messages from the entire LAN network and show them according to their timestamp
      dmt_log lan "$@"
      ;;

    # undocumented:

    flash)
      dmt_flash "$@"
      ;;

    bin)
      dmt_bin "$@"
      ;;

    cd)
      dmt_cd
      ;;

  esac
}

function dmt_symlink_nodejs_deps {
  local script="$DMT_NODE_CORE/.scripts/symlink_dmt_deps"

  if [ -f "$script" ]; then
    # changed recently!! if symlinking logic changes, we cannot just check if one symlink is present to know
    # if we have to do something!!
    #if [ ! -L "$DMT_NODE_CORE/dmt-bridge/node_modules" ] || [ ! -d "$DMT_USER_PATH/core/node/node_modules" ]; then
      local cwd="`pwd`"
      cd "$DMT_NODE_CORE/.scripts"
      ./symlink_dmt_deps
      cd "$cwd"
    #fi
  fi
}

function compile_gui_if_missing {
  if [ ! -f "$DMT_NODE_CORE/gui/gui-frontend-core/app/public/bundle.js" ]; then
    dmt_gui build
  fi
}

# Reload the environment
function reload_shell {
  # if [ -f "$DMT_PATH/shell/compile" ]; then
  #   compile
  # fi
  # if [ -f ~/.bash_aliases ]; then
  #   . ~/.bash_aliases
  # fi

  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
  if [ -f ~/.bash_profile ]; then
    . ~/.bash_profile
  fi
  if [ -f ~/.profile ]; then
    . ~/.profile
  fi

  printf "${GREEN}Shell reloaded âœ“${NC}\n"
}

function get_dmt_proc_pid {
  # space in " dmt-proc" is required
  local proc=$(ps -ef | grep " dmt-proc" | grep -v "nano dmt-proc" | grep -v "eslint" | grep -v "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')
  local procFG=$(ps -ef | grep "controller/daemons/dmt-proc.js" | grep -v "eslint" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -n "$proc" ]; then
    #ps -ef | grep " dmt-proc" | grep -v "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep
    eval "$1='$proc'"
    eval "$2='bg'"
    return
  fi

  # dmt process running in foreground
  if [ -n "$procFG" ]; then
    #ps -ef | grep "controller/daemons/dmt-proc.js" | grep -v "command -v openssl >/dev/null" | grep -v grep
    eval "$1='$procFG'"
    eval "$2='fg'"
  fi
}

function report_dmt_running {
  local dmt_proc_pid="$1"
  local fg_bg="$2"

  if [ -n "$dmt_proc_pid" ]; then
    local fg_bg_msg=""
    if [ "$fg_bg" == 'fg' ]; then
      fg_bg_msg="${MAGENTA}in foreground${NC} "
    fi
    printf "${WHITE}dmt-proc${NC} ${GREEN}seems to already be running ${fg_bg_msg}with ${YELLOW}pid ${dmt_proc_pid}${NC}\n"
    return 0
  fi

  return 1
}

# warning: duplicated in ~/.dmt/etc/onboot/daemons
# function save_dmt_state {
#   local dmt_cli="${DMT_NODE_CORE}/controller/cli/dmt.js"
#   if [ -f "$dmt_cli" ]; then
#     node "$dmt_cli" save_state
#   fi
# }

function dmt_device {
  declare -a opts=(
    "cd"
    "select"
    "def"
    "edit"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    local device_name=''
    get_current_device device_name

    if [ -n "$device_name" ]; then
      printf "${CYAN}Device name: ðŸ’¡ ${MAGENTA}${device_name}${NC}\n\n"
    else
      printf "${GRAY}This device is ${RED}unnamed ðŸ¤”${GRAY}, please name it by running ${GREEN}dmt device select${GRAY} (or shorter: ${GREEN}dev sel${GRAY}).${NC}\n\n"
      return
    fi

    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd [device]${NC} ${GRAY}move to directory with device definition (${GREEN}dev cd ${GRAY}moves to this device's def)${NC}\n"
    printf "${GREEN}select${NC} ${GRAY}select configuration for this device from existing configurations or create a new configuration and assign it to this device${NC}\n"
    printf "${GREEN}def${NC} ${GRAY}shows parsed device.def definition in json format${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}edit current device's device.def${NC}\n"
    return
  fi

  local matching_opt=''
  dmt_opts_matcher matching_opt "$1" "${opts[@]}"

  shift

  case "$matching_opt" in
    cd)
      device_helper cd "$@"
      ;;

    edit)
      device_helper edit
      ;;

    select)
      local script="$DMT_SCRIPTS/setup_device"
      if [ -f "$script" ]; then
        "$script" "$@"
      fi
      ;;

    def)
      printf "${YELLOW}Showing device definition in json format (parsed from .def):${NC}\n"
      local cli="$DMT_NODE_CORE/controller/cli/device.js"
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$cli" "${hosts}" "$@"
      else
        $DMT_NODEJS_EXEC "$cli" "$@"
      fi
      ;;
  esac
}

function dev {
  dmt_device "$@"
}

function device {
  dmt_device "$@"
}

function device_helper {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd${NC} ${GRAY}${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}${NC}\n"
    printf "${GREEN}list${NC} ${GRAY}${NC}\n"
    printf "${GREEN}ping${NC} ${GRAY}${NC}\n"
  else
    declare -a opts=(
      "cd"
      "edit"
      "list"
      "ping"
    )

    local matching_opt=''
    dmt_opts_matcher matching_opt "$1" "${opts[@]}"
    if [ $? -ne 0 ]; then # error
      printf "${YELLOW}Use ${GREEN}help ${YELLOW}for more options${NC}\n\n"
      #matching_opt="aaa" # default
    fi

    shift

    case "$matching_opt" in
      cd)
        local device="$1"

        if [ -z "$device" ]; then
          device="this"
        fi

        # if [ -z "$1" ]; then
        #   AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices
        #   if [ $? -eq 0 ] && [ -d "this/def" ]; then
        #     cd "this/def"
        #   fi
        # else

        AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices "$device"

        if [ $? -eq 0 ]; then
          if [ -d "def" ]; then
            cd "def"
          else
            printf "${GRAY}Moved to ${CYAN}${device}${GRAY} device directory but ${YELLOW}def ${GRAY}subdirectory is not present, please create it ...${NC}\n"
          fi
        else
          printf "${RED}not found${NC}\n"
        fi

        ;;

      edit)
        local dir="${DMT_USER_PATH}/devices/this"
        if [ -d "$dir" ]; then
          local file="${dir}/def/device.def"
          if [ -f "$file" ]; then
            nano "$file"
          else
            echo $file
            printf "${RED}device.def file not found${NC}\n"
          fi
        else
          printf "${RED}Device is unknown${GRAY}, please select the definition file by using ${GREEN}dev select${GRAY}, then try again.${NC}\n"
        fi
        ;;

      list)
        for_all_devices "list"
        ;;

      ping)
        for_all_devices
        ;;
    esac
  fi
}

function dmt_state {

  if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt state${NC} ${GRAY}show program state${NC}\n"
    printf "${GREEN}dmt state [store]${NC} ${GRAY}show a specific store state (controller, player etc.)${NC}\n"
    printf "${GREEN}dmt state [store].[key]${NC} ${GRAY}ex.: player.playlist, controller.weather${NC}\n"
    printf "${GREEN}dmt state purge${NC} ${GRAY}delete program state${NC}\n"
    return
  fi

  local DMT_STATE_FILE="$DMT_PATH/state/program.json"

  if [ -f "$DMT_STATE_FILE" ]; then
    if [ "$1" == "purge" ]; then
      if [ -f "$DMT_STATE_FILE" ]; then
        #dmt stop
        rm "$DMT_STATE_FILE"
        printf "${GREEN}purged dmt state${NC}\n"
        #dmt start
      fi
    else
      if [ -n "$1" ]; then
        cat "${DMT_STATE_FILE}" | jq ".$1"
      else
        cat "${DMT_STATE_FILE}" #| jq
      fi
    fi
  else
    printf "${YELLOW}dmt state not found on storage media${NC}\n"
  fi
}

function gui_build_all {
  local cwd="`pwd`"

  local base_dir="$DMT_PATH/core/node/gui/gui-frontend-core"

  cd "$base_dir"

  for component in *; do
    if [ -d "$component" ] && [ "$component" != "common_assets" ]; then
      cd $component
      if [ -f "package.json" ]; then
        npm run build
      else
        printf "${GREEN}Gui component ${YELLOW}${component}${NC} ${GREEN}not buildable in isolation, it was probably (hopefuly) included from some other components...${NC}\n"
      fi
    fi
    cd "$base_dir"
  done

  cd "$cwd"
}

function gui_send_action_to_frontend {
  local cliGUI="$DMT_PATH/core/node/gui/cli/gui.js"
  local action="$1"
  local payload
  if [ -n "$2" ]; then
    #action="${action}:${2}"
    payload="$2"
  fi
  $DMT_NODEJS_EXEC "${cliGUI}" "$action" "$payload"
}

function dmt_gui {
  local dir="$DMT_PATH/core/node/gui/gui-frontend-core"
  local backendDir="$DMT_PATH/core/node/gui/gui-backend"

  # extract host from @ symbol but replace @all with the name of current network !
  local hosts=""

  local args
  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"
  do
    if [ "$arg" == "@all" ]; then
      local network_id=''
      get_current_network network_id
      if [ -n "$network_id" ]; then
        hosts="${hosts} @@$network_id"
        shift
      fi
    elif [[ "$arg" == @* ]] && [[ ! "$arg" =~ = ]]; then # @attr=val should not be treated as hostnames
      hosts="${hosts} ${arg}"
      shift
    fi
  done

  hosts=$(echo "$hosts" | xargs) # remove trailing whitespace

  local option="$1"

  if [ -z "$option" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt gui test${NC} ${GRAY}display a test notification on the gui${NC}\n"
    printf "${GREEN}dmt gui @deviceId test${NC} ${GRAY}display a test notification on remote gui${NC}\n"
    #printf "${GREEN}dmt gui cd [view]${NC} ${GRAY}${NC}\n"
    # printf "${GREEN}dmt_gui run${NC} ${GRAY}${NC}\n"
    # printf "${GREEN}dmt_gui build${NC} ${GRAY}build all GUIs${NC}\n"
    # printf "${GREEN}dmt_gui build [gui]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}dmt gui load [view]${NC} ${GRAY}loads the specified gui view (home, player, debug etc.)${NC}\n"
    printf "${GREEN}dmt gui reload${NC} ${GRAY}send request to frontend via websocket requesting reload of current url${NC}\n"
    printf "${GREEN}dmt gui reload [view]${NC} ${GRAY}reloads to the specified gui view (home, player, debug etc.)${NC}\n"
    printf "${GREEN}dmt gui switch [ip]${NC} ${GRAY}switches gui to specified IP (todo: use deviceId instead of ip)${NC}\n"
    # printf "${GREEN}dmt_gui debug${NC} ${GRAY}shows debugging info for current gui issues troubleshooting${NC}\n"
    return
  fi

  shift

  case "$option" in
    test)
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" gui_test "$@"
      else
        $DMT_NODEJS_EXEC "$DMT_CLI" gui_test "$@"
      fi
      ;;
    cd)
      awesome_cd "$dir" "$1"
      if [ $? -eq 0 ] && [ -d "src" ]; then
        cd "src"
      fi
      ;;

    load)
      local view="$1"
      gui_send_action_to_frontend "load" "$view"
      ;;

    reload)
      local view="$1"
      gui_send_action_to_frontend "reload" "$view"
      ;;

    switch)
      local ip="$1"
      gui_send_action_to_frontend "switch" "$ip"
      ;;

    run)
      dmt_symlink_nodejs_deps # does not have an influence - this builds dmt apps, not dmt core.. will fix later
      local cwd="`pwd`"
      cd "$dir/app"
      npm run dev
      cd "$cwd"

      # if [ -z "$1" ]; then
      #   gui run app
      # elif [ "$1" == "." ]; then
      #   npm run dev
      # else
      #   awesome_cd "$dir" "$1"
      #   if [ $? -eq 0 ]; then
      #     npm run dev
      #   fi
      # fi
      ;;

    build)
      dmt_symlink_nodejs_deps # does not have an influence - this builds dmt apps, not dmt core.. will fix later
      local cwd="`pwd`"
      cd "$dir/app"
      npm run build
      cd "$cwd"

      # if [ -z "$1" ]; then
      #   dmt_gui build app
      #   cd "$cwd"
      #   return
      # fi

      # awesome_cd "$dir" "$1"
      # if [ $? -eq 0 ]; then
      #   npm run build
      # fi


      ;;

    debug)
      echo "TODO"
      ;;

    *)
      awesome_cd "$dir" "$option"
      ;;
  esac
}

function dmt_log {
  local foreground=false

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt log${NC} ${GRAY}get last 10 log lines on this machine${NC}\n"
    printf "${GREEN}dmt @host log${NC} ${GRAY}get last 10 log lines for remote machine${NC}\n"
    printf "${GREEN}dmt logfg${NC} ${GRAY}local log in foreground (updates are visible as they come)${NC}\n"
    return
  fi

  local logfile="$DMT_PATH/log/dmt.log"

  if [ "$1" == "fg" ]; then
    # ISSUE: 1) dmt logfg 2) COMMAND+K (clear screen) 3) renew device.. 4) PROBLEM: even older log messages will be shown
    tail -f -n 100 "$logfile"
  elif [ "$1" == "lan" ]; then
    printf "${MAGENTA}Not yet implemented ...${NC}\n"
    printf "${CYAN}Expect it in the next minor release of ${MAGENTA}dmt-system${NC}.${NC}\n"
  else
    if [ -n "$hosts" ]; then
      $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" log "$@"
    else
      $DMT_NODEJS_EXEC "$DMT_CLI" log "$@"
    fi
  fi
}

function dmt_help {
  printf "${YELLOW}Basic info:${NC}\n"
  echo
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt help ${GRAY}shows this help screen${NC}\n"
  #printf "${GREEN}dmt docs ${MAGENTA}shows documentation in a browser${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt version ${GRAY}shows dmt version â€” v$(cat "$DMT_PATH/.version")${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt device ${GRAY}device configuration and information${NC}\n"

  echo
  # printf "${YELLOW}Deactivation:${NC}\n"
  # echo
  # printf "  ${CYAN}â– ${NC} ${GREEN}dmt deactivate ${GRAY}deactivates shell but keep it present (to get it back just do ${CYAN}./install${GRAY})${NC}\n"
  # echo
  printf "${CYAN}dmt-proc${NC} ${YELLOW}management:${NC}\n"
  # printf "${CYAN}â–  services will not persist after reboot â€” ${MAGENTA}use the docs${CYAN} to easily configure this.${NC}"
  echo
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt start ${GRAY}starts the background process ${MAGENTA}(dmt-proc)${NC} ðŸ’¡ðŸš€ðŸŽ¸${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt startfg ${GRAY}starts dmt-proc visible in terminal foreground${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt stop ${GRAY}stops the process${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt restart ${GRAY}restarts the process${NC}\n"
  echo
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt log ${GRAY}shows a few recent log entries (${CYAN}dmt-proc${GRAY} has to be running) ${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt logfg ${GRAY}shows log in current tab (to get last few lines use ${GREEN}dmt log${GRAY} - makes a rpc call, see below)${NC}\n"
  #printf "  ${CYAN}â– ${NC} ${GREEN}dmt loglan ${GRAY}starts listening to network log message broadcasts${NC}\n"

  echo
  printf "${YELLOW}Process replication:${NC}\n"
  echo
  printf "  ${GREEN}â– ${NC} ${GREEN}dmt next ${GRAY}gets the latest dmt-system code from the source${NC}\n"
  #printf "  ${GREEN}â– ${NC} ${GREEN}dmt next --dry ${GRAY}show what would ${WHITE}dmt next${GRAY} command do${NC}\n"
  echo
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt update [deviceId|ip_address] ${GRAY}clones or updates ~/.dmt directory at another machine via SSH${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt renew [deviceId|ip_address] ${GRAY}same as above and in addition it restarts the process after update${NC}\n"
  echo
  printf "  Another way to clone/update: ${CYAN}curl [machineIp]:1111 | bash ${NC}â†’ ${GRAY}replicates ~/.dmt directory\n"
  printf "  ${GRAY}(without ~/.dmt/user|state|log) from [machineIp] to machine where command was executed${NC}\n"

  echo
  printf "${YELLOW}Other:\n${NC}"
  echo
  #printf "  ${CYAN}â– ${NC} ${CYAN}dmt services ${GRAY}shows configured services (${CYAN}dmt-proc${GRAY} has to be running) ${NC}\n"
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt gui [option] ${GRAY}various methods related to GUIs (${CYAN}dmt-proc${GRAY} has to be running) ${NC}\n"
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt media [option] ${GRAY}various methods for cli media player manipulation (${CYAN}dmt-proc${GRAY} has to be running) ${NC}\n"
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt search [option] ${GRAY}various methods for cli search (${CYAN}dmt-proc${GRAY} has to be running) ${NC}\n"
}

function dmt_help_explain_rpc {
  echo
  return

  echo
  printf "${GRAY}_____________________________________________________________________________${NC}\n"
  echo
  printf "How to refer to other ${CYAN}dmt-proc${NC} instances on local network? ${YELLOW}Use ${MAGENTA}the @ symbol${NC} â†’${NC}\n"
  echo
  printf "  ${MAGENTA}â– ${NC} ${GREEN}dmt ${MAGENTA}@deviceId${GREEN} [log|services|etc.] ${GRAY}gets information about a device on local network${NC}\n"
  printf "  ${MAGENTA}â– ${NC} ${GREEN}dmt ${MAGENTA}@ip_address${GREEN} [log|services|etc.] ${GRAY}same as above but directly with ip address instead of deviceId from device.def${NC}\n"
  printf "  while ${GREEN}dmt [log|services|etc.] ${GRAY}gets information about current device as usual${NC}\n"
  # printf "${GREEN}dmt @@remoteIpOrHost info ${GRAY}gets information about remote device on the other side of router WAN port${NC}\n"
  echo
  printf "  All methods in ${CYAN}cyan${NC} work in this way where an optional ${MAGENTA}@${NC} symbol\n"
  printf "  can be used to refer to other device on local area network.\n"
  echo
}

function dmt_version {
  printf "${MAGENTA}v$(cat "$DMT_PATH/.version")${NC}\n\n"
  local NUM=$(cat $HOME/.dmt/etc/.bash_aliases_bundle | grep function | wc -l | xargs)
  printf "${WHITE}${NUM} bash functions\n"
}

function get_dmt_source_from_user_def {
  local __dmt_source=''

  if [ -f "$DMT_USER_DEF_FILE" ]; then
    dmt_def_reader __dmt_source "$DMT_USER_DEF_FILE" "dmtSource"
  fi

  eval "$1='$__dmt_source'"

  # return

  # local _gatewayMac=''
  # get_gateway_mac _gatewayMac

  # if [ "$_gatewayMac" == "$LOCAL_DMT_SOURCE_MAC" ]; then
  #   eval "$1='local'"
  # else
  #   eval "$1='global'"
  # fi
}

function stop_dmt_if_running {
  local dmt_proc_pid=''
  local dmt_fg_bg=''
  get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

  if [ -n "$dmt_proc_pid" ]; then
    dmt stop
  fi
}

function dmt_next {

  #return

  # if dev_machine; then
  #   printf "${RED}Prevented on dev machine${NC}\n"
  #   return
  # fi

    # option 1: specify from where to fetch via an argument:
  # dmt next [dmtSource]
  # or from user.def ->
  # user:
  #  dmtSource: [dmtSource]

  local dry_run=false
  local fetch=false
  local reflect_version=false

  ARGS=()
  while (( "$#" )); do
    case "$1" in
      --dry)
        dry_run=true
        shift 1
        ;;
      --fetch)
        fetch=true
        shift 1
        ;;
      --help)
        dmt_next_help
        return
        ;;
      -h)
        dmt_next_help
        return
        ;;
      --) # end argument parsing
        shift
        break
        ;;
      -*|--*=) # unsupported flags
        printf "${RED}Error: Unsupported flag ${YELLOW}$1${NC}\n"
        #echo ""
        return
        ;;
      *) # preserve positional arguments
        ARGS+=($1)
        shift
        ;;
    esac
  done

  # dmt next --dry
  # dmt next --dry url.com
  # if [ "$1" == "--dry" ]; then
  #   dry_run=true
  #   shift
  # fi

  # # dmt next url.com --dry
  # if [ "$2" == "--dry" ]; then
  #   dry_run=true
  # fi

  # 1) dmtSource from argument
  local arg=${ARGS[0]}

  # if [ "$arg" == "--help" ] || [  "$arg" == "-h" ]; then
  #   #dmt_next_help
  #   return
  # else
  #   printf "${GRAY}To read help for this command use: ${GREEN}dmt next -h${NC}\n"
  # fi

  # 2) dmtSource from user.def
  local dmt_source="$arg"

  if [ -n "$dmt_source" ]; then
    if $dry_run; then
      printf "${CYAN}1)${NC} ${MAGENTA}dmtSource${NC} provided as argument: ${MAGENTA}${dmt_source}${NC}\n"
    fi
  else
    if $dry_run; then
      printf "${CYAN}1)${NC} ${MAGENTA}dmtSource ${GRAY}not provided as argument to this command ${NC}...\n"
      printf "${CYAN}2)${NC} ${GRAY}Checking ~/.dmt/user/def/user.def for ${MAGENTA}dmtSource ${NC} ...\n"
    fi

    get_dmt_source_from_user_def dmt_source

    if [ -n "$dmt_source" ] && $dry_run; then
      printf "   ${GREEN}â—â—â— found it!${NC}\n"
    fi
  fi

  # aborting if couldn't determine dmtSource

  if [ -z "$dmt_source" ]; then
    if $dry_run; then echo; fi
    printf "${GRAY}Could not determine ${MAGENTA}dmtSource ${GRAY}... ${NC}"

    if [ -d "$DMT_PATH/.git" ]; then

      local cwd2="`pwd`"
      cd "$DMT_PATH"

      if $dry_run; then
        printf "${GRAY}Would fetch from the github origin:${NC}\n"
        #git remote show -n origin
        git remote get-url origin
      else
        local gitsource=`git remote get-url origin`

        if [[ "$gitsource" =~ uniqpath/dmt ]]; then
          echo
          printf "${GREEN}Found git origin âœ“\n"
          printf "${GRAY}Updating from ${CYAN}${gitsource} ${GRAY}...${NC}\n"

          git fetch origin
          git checkout master
          git reset --hard origin/master

          printf "${GREEN}âœ“âœ“ Done fetching latest version via git.${NC}\n\n"
          printf "${CYAN}Please run ${GREEN}dmt restart${NC} ${CYAN}now${NC} ...\n\n"
          printf "${GRAY}Sometimes it is recommended to reload the terminal shell as well:\n"
          printf "â†’ try ${GREEN}rel${NC} ${GRAY}command or logout and back in.${NC}\n"
        else
          printf "${RED}Aborting fetch from unknown git source.${NC}"
        fi
      fi
    else
      if ! $dry_run; then printf "${RED}aborting.${NC}"; fi
      echo
    fi

    cd "$cwd2"
    return
  fi

  # dry run
  if $dry_run; then
    echo
    printf "${GREEN}dmt next${NC} ${YELLOW}command would fetch the code from â†’ ${MAGENTA}${dmt_source}${NC}\n"
    return
  fi

  # FETCHING ONLY ------------

  if $fetch; then
    local dir=~/.dmt/state

    if [ -d "$dir" ]; then
      local cwd="`pwd`"
      cd "$dir"

      local fetched_file="dmt_in_progress.zip"

      if [ -f $fetched_file ]; then
        printf "${YELLOW}REMOVING FIRST${NC}\n"
        rm $fetched_file
      fi

      printf "${GREEN}Fetching ${MAGENTA}dmt.zip${NC} from ${CYAN}${dmt_source}${NC} â†’ ${YELLOW}${dir}${NC} ... ${NC}\n"

      if curl -L --fail "${dmt_source}/dmt.zip" -o $fetched_file; then
        mv $fetched_file dmt.zip
        echo
        printf "${GREEN}âœ“ Fetched file ${YELLOW}${dir}/dmt.zip${NC}\n"
        printf "${GRAY}It will be served on ${dmt_source}/dmt.zip requests as long as it stays in this folder${NC}\n"
        printf "${GRAY}instead of process self-replication via streaming archiver.${NC}\n"
        echo
        printf "${GRAY}Saving corresponding version number of dmt.zip contents...${NC}\n"
        # a bit of duplication
        local remoteVersion=$(curl "$dmt_source"/version 2>/dev/null)

        if [[ "$remoteVersion" =~ "â– " ]]; then # 1.1.2 â–  2020-05-03
          echo "$remoteVersion" > dmt.zip.version.txt
        else
          printf "âš ï¸  ${YELLOW}Failed to fetch remote version ...${NC}\n"
        fi
      else
        echo
        printf "${RED}Failed to fetch ${YELLOW}${dir}/dmt.zip ${RED}âœ–${NC}\n"
      fi

      cd "$cwd"
    else
      printf "${RED}${dir} directory does not exist, aborting.${NC}\n"
    fi

    # end of fetch option
    return
  fi

  # Safeguard
  if [ -f ~/.dmt/.prevent_dmt_next ]; then
    printf "${RED}Prevented operation because ~/.dmt/.prevent_dmt_next file is present, please remove it to continue${NC}\n"
    return
  fi

  # ---------------------------

  if [ "$dmt_source" == "get-dmt.com" ]; then

    # a bit of duplication
    local remoteVersion=$(curl http://get-dmt.com/version 2>/dev/null)

    if [[ ! "$remoteVersion" =~ "â– " ]]; then # 1.1.2 â–  2020-05-03
      printf "${MAGENTA}get-dmt.com${NC} ${RED}server is currently not accessible...\n"
      printf "${YELLOW}Please try again later.${NC}\n"
      return
    fi

    local localVersion=$(cat ~/.dmt/.version)

    if [ "$localVersion" == "$remoteVersion" ]; then
      echo
      printf "${CYAN}Your version ${MAGENTA}${localVersion}${NC} ${CYAN}is current!${NC}\n"
      echo
      printf "${GREEN}No need to update ðŸ˜Š${NC}\n"
      return
    fi

    printf "You have    : ${GRAY}${localVersion}${NC}\n"
    printf "New version : ${MAGENTA}${remoteVersion}${NC}\n"

    echo

    printf "${YELLOW}Do you want to update?${NC}...\n"
    read -r -p "[Y/n] " response
    if [[ $response =~ ^([nN])$ ]]
    then
      printf "${RED}Aborting ...${NC}\n"
      return
    fi

  fi

  # ------------

  stop_dmt_if_running

  local cwd="`pwd`"

  printf "${MAGENTA}dmtSource${NC} = ${CYAN}${dmt_source}${NC}\n"

  curl -L "${dmt_source}" | bash

  # ~/.dmt directory will get replaced under us ...
  # we move to it again ....
  cd "$cwd"

  mkdir -p ~/.dmt/state
  touch ~/.dmt/state/gui_reload.txt

  dmt start

  printf "${GREEN}Done.${NC}\n"
}

function dmt_next_help {
  printf "${YELLOW}Usage:${NC}\n"
  printf "${GREEN}dmt next ${GRAY}read ${MAGENTA}dmtSource ${GRAY}from user.def, dmtSource is just an url from where to fetch the entire ${CYAN}dmt-proc ${GRAY}code${NC}\n"
  printf "${GREEN}dmt next [dmtSource] ${GRAY}specify manually (has precedence over user.def, careful!)${NC}\n"

  printf "${GREEN}dmt next --dry ${GRAY}does not do anything except showing you what would be the determined ${MAGENTA}dmtSource ${GRAY}value${NC}\n"

  # echo
  # printf "${MAGENTA}Supported formats for ${CYAN}dmtSource${NC}:\n"

  # printf "Regular url: ${CYAN}dmt-system.com/urlpath${NC} (attaches /getdmt to the end if urlpath is missing - example: just 'dmt-system.com' becomes 'dmt-system.com/getdmt')\n"
  # printf "${YELLOW}this options gets the bash script from the endpoint and executes it${NC}\n"

  # printf "Github url: ${CYAN}github.com/uniqpath/dmt${NC}\n"

  # printf "Local network: ${CYAN}192.168.0.50${NC} (attaches :1111 port if there is no port specified - example: just '192.168.0.70' becomes '192.168.0.70:1111')\n"
  # printf "Regular url or ip apart from 192.168.* with port specified: ${CYAN}somedomain.com:2222${NC}\n"

  # OPTION A -  dmt next dmt-system.com
  # dmt next github.com/uniqpath/dmt
  # OPTION C - local network - dmt next 192.168.0.50
  # OPTION C2 - local network with port included - dmt next 192.168.0.50:1111
  # OPTION D - regular url with port included: dmt next dmt-system.com:1111
}

function dmt_update {
  dmt_symlink_nodejs_deps

  if [ -z "$1" ]; then
    if dev_machine; then
      printf "${RED}Prevented on dev machine${NC}\n"
    fi
  else
    compile_gui_if_missing

    local cwd="`pwd`"
    cd "$DMT_PATH"
    . ./install "$@" # calling with . preserves the newly loaded env
    cd "$cwd"
  fi
}

function dmt_renew {
  dmt_update --restart "$@"
}

function dmt_deactivate {
  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  local backup_file="$LOGNAME_HOME/.bash_aliases-backup-by-dmt"

  if [ -L "$LOGNAME_HOME/.bash_aliases" ] && [ "$(head -3 $LOGNAME_HOME/.bash_aliases | tail -1)" == "# DMT ALIASES" ]; then
    rm ~/.bash_aliases

    if [ -f "$backup_file" ]; then
      mv "$backup_file" ~/.bash_aliases
    fi

    printf "${MAGENTA}dmt${NC} ${CYAN}was unlinked${NC}, only the folder ${CYAN}~/.dmt${NC} remains and is not active in any way.\n"
    echo
    printf "${CYAN}To reinstall${NC}\n"
    printf "${GREEN}cd $LOGNAME_HOME/.dmt${NC}\n"
    printf "${GREEN}./install${NC}\n"
    echo
    printf "${CYAN}To remove the unused directory${NC}\n"
    printf "${GREEN}rm -rf $LOGNAME_HOME/.dmt${NC}\n"
    echo
    printf "${WHITE}If you want to confirm that dmt is uninstalled you have to first reload the shell.${NC}\n"
  else
    printf "${RED}dmt is not installed${NC}\n"
  fi
}

function dmt_cd {
  cd "$DMT_PATH"
}

function dmt_bin {
  declare -a opts=(
    "compile"
    "download"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "${opts[@]}"
    return
  fi

  local matching_opt=''
  dmt_opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "Use -h to see valid options\n\n"
    #matching_opt="aaa" # default
    return
  fi

  shift

  case "$matching_opt" in
    compile)
      if [ -d $DMT_RUST_CORE ]; then
        dmt_compile_bin
      else
        echo "rust core doesn't exists"
      fi
      ;;

    download)
      ;;
  esac
}

function dmt_compile_bin {
  local cwd="`pwd`"

  # todo: ... + generalize the process somehow....

  printf "${MAGENTA}$DMT_RUST_CORE/walkdir${NC}\n"
  if [ -d "$DMT_RUST_CORE/walkdir" ]; then
    cd "$DMT_RUST_CORE/walkdir"
    cargo build --release --example walkdir
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/examples/walkdir "${DMT_PLATFORM_BIN}/walkdir" >/dev/null 2>&1; then
        printf "${GREEN}âœ“ Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/examples/walkdir "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}âœ“ Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  echo

  printf "${MAGENTA}$DMT_RUST_CORE/walksearch${NC}\n"
  if [ -d "$DMT_RUST_CORE/walksearch" ]; then
    cd "$DMT_RUST_CORE/walksearch"
    cargo build --release
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/walksearch "${DMT_PLATFORM_BIN}/walksearch" >/dev/null 2>&1; then
        printf "${GREEN}âœ“ Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/walksearch "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}âœ“ Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  cd "$cwd"
}
