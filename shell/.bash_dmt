#!/bin/bash

CLI_DIR="$DMT_NODE_CORE/controller/cli/"

DMT_CLI="$CLI_DIR/dmt.js"

TAIL_LOG_LINES=300

DMT_AUTO_UPDATE_LOG="$DMT_PATH/log/.auto_update_log"

function dmt {
  local o

  if [ "$1" == "o" ]; then
    o=true
    shift
  fi

  if [ -z "$1" ] || [ "$1" == "help" ]; then
    echo
    if [[ $o ]]; then
      #printf "${CYAN}Freedom to Imagine${NC}"
      printf "${CYAN}‚Äî ${MAGENTA}‚àûoOo‚àû ${CYAN}‚Äî ${GRAY}v$(cat "$DMT_PATH/.version")${NC}\n"
    else
      printf "${MAGENTA}        ‚àû DMT ‚àû${NC}\n"
      printf "${CYAN}Digital Mastery Techniques${NC}\n"
      printf " ${CYAN}‚Äî ${GRAY}v$(cat "$DMT_PATH/.version") ${CYAN}‚Äî${NC}\n"
      echo
    printf "üí° Keep up with developments and ${CYAN}update with ${GREEN}dmt next${NC} ${NC}at least once every ${CYAN}1-3 months${NC}\n"
    fi
    #printf "${CYAN}Freedom to imagine${NC}\n"
    # printf " ${GRAY}It is reommended to update${NC}\n"

    # show auto-update status !
    if [ -f $DMT_AUTO_UPDATE_LOG ] && [ -d ~/.dmt/.git ]; then
      local file_age=''
      dmt_get_file_age file_age $DMT_AUTO_UPDATE_LOG

      #local file_age=$(( `date +%s` - `stat -L --format %Y $DMT_AUTO_UPDATE_LOG` ))
      #local file_age=$(date +%s -r $DMT_AUTO_UPDATE_LOG)
      #date +%s -r ~/.dmt/log

      if [ $file_age -le $((5*60+5)) ]; then # 5 minutes plus 5s
        printf " ‚Ü≥ Not actually needed on this machine: ${MAGENTA}auto-update${NC} is set up (see ${GREEN}dmt autoupdate ${NC}for more information)${NC}\n"
        #printf "${GREEN}‚úì This is less than 5min ago ${CYAN}‚Üí${CYAN} cron setup seems to be working correctly${NC}\n"
      fi
    fi

    echo
  fi

  # dmt [command] @hosts [terms]
  local command=''

  if [[ "$1" != @* ]]; then
    command="$1"
    shift
  fi

  # extract host from @ symbol but replace @all with the name of current network !
  local hosts=""

  local args
  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"
  do
    if [ "$arg" == "@all" ]; then
      local network_id=''
      get_current_network network_id
      if [ -n "$network_id" ]; then
        hosts="${hosts} @@$network_id"
        shift
      fi
    elif [[ "$arg" == @* ]] && [[ ! "$arg" =~ = ]]; then # @attr=val should not be treated as hostnames
      hosts="${hosts} ${arg}"
      shift
    fi
  done

  hosts=$(echo "$hosts" | xargs) # remove trailing whitespace

  declare -a opts=(
    "help"
    "info"
    "gui"
    "status"
    "version"
    "device"
    "nearby"
    "protocols"
    "identity"
    "actors"
    "state"
    "reach"
    "connections"
    "services"
    "next"
    "core"
    "update"
    "copy"
    "debug"
    "log"
    "install"
    "start"
    "run"
    "startprofiler"
    "restart"
    "restart2"
    "stop"
    "state"
    "link"
    "unlink"
    "relink"
    "deactivate"
    "autoupdate"
    "shell"
    "bin"
    "media"
    "search"
    "reload"
  )

  if dev_machine; then
    declare -a opts_admin=(
      "cd"
    )

    opts=("${opts[@]}" "${opts_admin[@]}")
  fi

  if [ "$command" == '-h' ] || [ "$command" == '--help' ]; then
    command="help"
  fi

  local matching_opt=''
  dmt_opts_matcher matching_opt "$command" "${opts[@]}"

  if [ -z "$matching_opt" ] && [ -n "$command" ]; then
    printf "üí° Try ${GREEN}dmt help${NC} to see the available options.\n"
    echo
    return
  fi

  # show process info

  local dmt_proc_pid=''
  local dmt_fg_bg=''
  get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

  local proc_manager=$(ps -ef | grep "dmt-proc" | grep "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -z "$hosts" ]; then # if we're targeting remote hosts, information about our own local process is irrelevant
    if [ "$matching_opt" != "next" ] && [ "$matching_opt" != "start" ] && [ "$matching_opt" != "run" ] && [ "$matching_opt" != "debug" ] && [ "$matching_opt" != "device" ]; then
      if [ -n "$dmt_proc_pid" ]; then
        local comment='';
        if [ "$dmt_fg_bg" == "fg" ]; then
          comment=" ${GRAY}in another terminal (it is not 'daemonized')${NC}"
        fi

        printf "${GREEN}${CYAN}üåÄ DMT PROC${GREEN} is running üëå${comment} ¬∑ ${YELLOW}Process ID (PID) ${dmt_proc_pid}${NC}\n"

        # TIP üí° friendly help
        if [ -z "$matching_opt" ]; then
          echo
          # has a duplicate!
          printf "${YELLOW}üí° TIPS:${NC}\n\n"
          if [ "$dmt_fg_bg" == "fg" ]; then
            #printf "You can also use ${GREEN}sudo kill -9 ${dmt_proc_pid}${NC} to kill the process now.\n"

            printf "  ${CYAN}‚ñ†${NC} ${GREEN}sudo kill -9 ${dmt_proc_pid} ${GRAY}stop the process ${GRAY}(you can also switch to the other terminal and press ${UNDERLINE}ctrl+c${RESET}${GRAY})${NC}\n"
          else
            printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt stop ${GRAY}stop the process ${dmt_proc_pid}${NC}\n"
            printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt restart ${GRAY}restart the process ${dmt_proc_pid}${NC}\n"
          fi

          printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt log ${GRAY}shows realtime log, to quit press ${UNDERLINE}ctrl+c${RESET}${NC}\n"
        fi
      elif [ "$matching_opt" != "stop" ] && [ "$matching_opt" != "restart" ]; then
        printf "${RED}‚úñ ${MAGENTA}üåÄ DMT PROC${NC} ${WHITE}is not currently running.${NC}\n"
        if [ -n "$proc_manager" ]; then
          printf ".... ${YELLOW}looks like dmt process manager is currently (re)starting ${WHITE}dmt-proc${NC} ....\n"
        fi

        # TIP üí° friendly help
        if [ -z "$matching_opt" ]; then
          echo
          # has a duplicate!
          # printf "üí° ${WHITE}Two options for starting:\n\n"
          printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt start ${MAGENTA}‚Äî recommended ‚Äî ${GRAY}starts the daemonized process (in background, not inside a terminal)${NC}\n"
          printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt run ${GRAY}runs ${CYAN}dmt-proc${GRAY} in terminal foreground (stop it with ${UNDERLINE}ctrl+c${RESET}${GRAY})${NC}\n"
        fi
      fi
      echo
    fi
  fi

  # exit if no argument was given
  if [ -z "$matching_opt" ]; then
    if [ -z "$hosts" ]; then
      printf "Use ${GREEN}dmt help${NC} for more options.\n"
      echo

    #   if [ -z "$1" ] && [ -n "$proc" ] ; then
    #     echo
    #     printf "${CYAN}This device info:${NC}\n\n"
    #     if [ ! -f "$DMT_DEVICE_FILE" ]; then
    #       printf "${RED}Reminder ‚óè ${GRAY}you still need to configure this device ‚óè ${CYAN}please run ‚Üí \n\n${GREEN}  dmt device select${NC}\n\n"
    #       return
    #     fi
    #   fi
    fi

    return

    # if [ -z "$1" ]; then
    #   matching_opt="help"
    # else
    #   return
    # fi
  fi

  case "$matching_opt" in
    help)
      dmt_help

      if [ -n "$hosts" ]; then
        dmt_help_explain_rpc
      else
        dmt_help_explain_rpc

        printf "${GRAY}_____________________________________________________________________________${NC}\n"
        echo

        if [ -z "$dmt_proc_pid" ]; then
          printf "${RED}‚úñ${NC} ${MAGENTA}üåÄ DMT PROC${NC} ${WHITE}is not running${NC}"
          printf " ${CYAN}‚Üí Please use ${GREEN}dmt start${NC} üí°üöÄüé∏\n"
          echo
        else
          printf "${GREEN}‚úì${NC} ${CYAN}üåÄ DMT PROC${NC} ${GRAY}is ${WHITE}currently running${GRAY} on this device ‚Ä¶${NC}\n"
          echo
        fi
      fi
      ;;

    info)
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" info "$@"
      else
        if [ -n "$dmt_proc_pid" ]; then
          $DMT_NODEJS_EXEC "$DMT_CLI" info "$@"
        fi
      fi
      ;;

    nearby)
      if [ -n "$dmt_proc_pid" ]; then
        dmt_nearby "$@"
      fi
      ;;

    state)
      if [ -n "$dmt_proc_pid" ]; then
        $DMT_NODEJS_EXEC "$CLI_DIR/state.js" "$@"
      fi
      ;;

    connections)
      if [ -n "$dmt_proc_pid" ]; then
        $DMT_NODEJS_EXEC "$CLI_DIR/connections.js" "$@"
      fi
      ;;

    protocols)
      if [ -n "$dmt_proc_pid" ]; then
        $DMT_NODEJS_EXEC "$CLI_DIR/protocols.js" "$@"
      fi
      ;;

    actors)
      if [ -n "$dmt_proc_pid" ]; then
        $DMT_NODEJS_EXEC "$CLI_DIR/actors.js" "$@"
      fi
      ;;

    reach)
      if [ -n "$dmt_proc_pid" ]; then
        $DMT_NODEJS_EXEC "$CLI_DIR/reach.js" "$@"
      fi
      ;;

    reload)
      reload_shell
      ;;

    gui)
      if [ -n "$hosts" ]; then
        dmt_gui "$hosts" "$@"
      else
        # if [ -n "$dmt_proc_pid" ]; then
        #   node "$DMT_CLI" gui_test "$@"
        # fi
        dmt_gui "$@"
      fi
      ;;

    debug)
      local markerfile="$DMT_STATE/.debug-mode"
      local markerfile_display="~/.dmt/state/.debug-mode"

      if [ "$1" == "off" ] || [ "$1" == "disable" ] || [ "$1" == "stop" ]; then
        if [ -f "$markerfile" ]; then
          rm "$markerfile"
          printf "${MAGENTA}Debug mode disabled${NC}\n"
        else
          printf "${YELLOW}Debug mode was already disabled${NC}\n"
        fi
      fi

      # dmt debug edit
      if [ "$1" == "edit" ]; then
        if [ ! -f "$markerfile" ]; then
          setup_default_debug_marker_file "$markerfile"
        fi

        nano "$markerfile"

        printf "${GREEN}‚úì ${YELLOW}Debug mode ‚öôÔ∏è  is enabled with selected additional logging:${NC}\n"

        echo

        show_debug_levels_from_markerfile "$markerfile"

        echo
        printf "${CYAN}Options:${NC}\n"
        echo
        printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt debug off ${GRAY}stop debugging${NC}\n"
        echo

        return
      fi

      if [ -z "$1" ] || [ "$1" == "on" ] || [ "$1" == "enable" ]; then
        if [ -f "$markerfile" ]; then
          printf "${YELLOW}‚úì Debug mode was already enabled${NC}\n"
        else
          setup_default_debug_marker_file "$markerfile"

          printf "${GREEN}‚úì ${YELLOW}Debug mode ‚öôÔ∏è  enabled${NC}\n"
          #printf "${GRAY}General debug messages are now appearing in dmt log.${NC}\n"
        fi

        echo
        printf "${CYAN}What this means?${NC}\n"
        echo
        printf "${MAGENTA}General debug messages are now appearing in dmt log.${NC}\n"
        printf "\nIf you need more debugging messages please use ${GREEN}dmt debug edit${NC} and remove '#' in front of particular debug log levels:\n"

        #printf "\n${MAGENTA}Debugging options:${NC}\n"

        # printf "\nTo make it more permanent, add this to device.def ${GRAY}(command:${NC} ${GREEN}dev edit${NC}${GRAY})${NC}:\n"
        # printf "${MAGENTA}debug:${NC}\n"
        # printf "  ${MAGENTA}log: ${GRAY}mpv${NC}\n"
        # printf "  ${MAGENTA}log: ${GRAY}lanbus${NC}\n"
        # printf "  ${MAGENTA}log: ${GRAY}...${NC}\n"
        # printf "\n‚ö†Ô∏è  ${GRAY}This, however, requires ${GREEN}dmt restart${GRAY} while editing the ${YELLOW}.debug-mode${GRAY} file does not.${NC}\n"

        echo

        show_debug_levels_from_markerfile "$markerfile"
        #printf "${GREEN}beats${NC} ${GRAY}todo${NC}\n"
      fi

      echo
      printf "${CYAN}Options:${NC}\n"
      echo
      printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt debug [on] ${GRAY}start debugging${NC}\n"
      printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt debug off ${GRAY}stop debugging${NC}\n"
      printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt debug edit ${GRAY}enable or disable additional logging${NC}\n"
      echo

      ;;

    search)
      if [ -n "$hosts" ]; then
        dmt_search "${hosts}" "$@"
      else
        dmt_search "$@"
      fi
      ;;

    media)
      if [ -n "$hosts" ]; then
        dmt_media "${hosts}" "$@"
      else
        dmt_media "$@"
      fi
      ;;

    services)
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" services "$@"
      else
        $DMT_NODEJS_EXEC "$DMT_CLI" services "$@"
      fi
      ;;

    version)
      dmt_version
      ;;

    device)
      dmt_device "$@"
      ;;

    next)
      dmt_next "$@"
      ;;

    update) # updates the whole folder and restarts the service
      dmt_update "$@"
      ;;

    copy) # updates the whole folder, doesn't restart the service
      dmt_copy "$@"
      ;;

    deactivate)
      dmt_deactivate
      ;;

    autoupdate)
      dmt_autoupdate "$@"
      ;;

    shell)
      dmt_shell_setup "$@"
      ;;

    # link)
    #   local dir="$DMT_NODE_CORE/.scripts"
    #   if [ -d "$dir" ]; then
    #     local cwd="`pwd`"
    #     cd "$dir"
    #     ./symlink_dmt_deps
    #     # printf "${GREEN}Linked.${NC}\n"
    #     cd "$cwd"
    #   fi
    #   ;;

    # unlink)
    #   local dir="$DMT_NODE_CORE/.scripts"
    #   if [ -d "$dir" ]; then
    #     local cwd="`pwd`"
    #     cd "$dir"
    #     ./symlink_dmt_deps "remove"
    #     # printf "${MAGENTA}Unlinked.${NC}\n"
    #     cd "$cwd"
    #   fi
    #   ;;

    # checklink)
    #   local cwd="`pwd`"
    #   cd "$DMT_NODE_CORE/.scripts"
    #   ./symlink_dmt_deps "check"
    #   cd "$cwd"
    #   ;;

    # relink) #rarely used, usually "dmt link" is enough for this purpose as well... use "dmt relink" only if suddenly symlinks should point somewewhere else... if just some new symlinks have to be added, there is no need to unlink first, the symlinking script (dmt link) will add what's missing
    #   dmt unlink
    #   dmt link
    #   ;;

    start)
      if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
        return
      fi

      compile_gui_if_missing

      dmt_sync_apps_into_dmt_engine

      printf "${CYAN}üåÄ DMT PROC${NC} ${MAGENTA}is starting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" start

      # see if process is actually running
      local dmt_proc_pid=''
      local dmt_fg_bg=''
      get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

      if [ -n "$dmt_proc_pid" ]; then
        printf "\n${CYAN}‚úì dmt-proc${NC} ${GRAY}should now be running, use ${GREEN}dmt log ${GRAY}to see recent log entries.${NC}\n"
        echo
          # has a duplicate!
          printf "${YELLOW}üí° TIPS:${NC}\n\n"
          printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt stop ${GRAY}stop the process ${dmt_proc_pid}${NC}\n"
          printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt restart ${GRAY}restart the process ${dmt_proc_pid}${NC}\n"
          printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt log ${GRAY}shows realtime log, to quit press ${UNDERLINE}ctrl+c${RESET}${NC}\n"
          echo
      else
        printf "\n${RED}Problem starting ${CYAN}dmt-proc${RED}, please use ${GREEN}dmt logfg ${RED}to determine the reason${NC}\n"
      fi
      ;;

    run) # START FOREGROUND
      if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
        return
      fi

      compile_gui_if_missing

      dmt_sync_apps_into_dmt_engine

      printf "${CYAN}üåÄ DMT PROC${NC} ${WHITE}is running in terminal foreground ${NC}(this is marked with ${RED}'‚úù'${NC})\n"
      echo
      printf "‚ö†Ô∏è  Process will be ${RED}‚úùerminated${NC} if you ${UNDERLINE}close the terminal tab${RESET}${NC} or ${UNDERLINE}exit the remote terminal ssh session${RESET}.${NC}\n"
      echo
      printf "üí° Stop it manually when needed by pressing ${UNDERLINE}ctrl+c${RESET}${NC}\n"
      echo
      printf "üí° To keep the process active ('daemonized') in the background please use ${GREEN}dmt start${NC}.\n"
      printf "   You can see the equivalent realtime log output of the daemonized process with ${GREEN}dmt log${NC}.\n"
      echo

      $DMT_NODEJS_EXEC --trace-warnings "${DMT_NODE_CORE}/controller/daemons/dmt-proc.js" --fg # --fg: only for informative purposes to signal that we ran it in foreground as opposed to daemonizing (dmt start)
      ;;

    # startprofiler)
    #   if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
    #     return
    #   fi

    #   dmt_symlink_nodejs_deps
    #   compile_gui_if_missing

    #   printf "${MAGENTA}dmt-proc${NC} ${WHITE}is starting in ${CYAN}foreground${NC} ...\n\n"
    #   $DMT_NODEJS_EXEC --trace-warnings --prof "${DMT_NODE_CORE}/controller/daemons/dmt-proc.js"  --fg # --fg: only for informative purposes to signal that we ran it in foreground as opposed to daemonizing (dmt start)
    #   ;;

    stop)
      local dmt_proc_pid=''
      local dmt_fg_bg=''
      get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

      if [[ $dmt_fg_bg == 'fg' ]]; then
        printf "‚ö†Ô∏è  ${RED}Cannot stop ${CYAN}dmt-proc${NC} !\n"
        printf "   ${WHITE}Reason${NC} ‚Üí it is running in ${WHITE}${UNDERLINE}another terminal${RESET}${NC} (it was started with ${WHITE}${UNDERLINE}dmt run${RESET}${NC} command).${NC}\n"
        echo
        printf "üí° Please switch to that terminal and press ${UNDERLINE}ctrl+c${RESET} to stop the process.${NC}\n"
        printf "   Or you can use ${GREEN}sudo kill -9 ${dmt_proc_pid}${NC} to kill the process from this terminal.\n"
        echo
        return
      fi

      if [ -n "$dmt_proc_pid" ]; then
        printf "${CYAN}üåÄ DMT PROC${NC} ${MAGENTA}is stopping...${NC}\n\n"
        "${DMT_PATH}/etc/onboot/daemons" stop

        echo
        # has a duplicate!
        printf "üí° ${YELLOW}TIPS:\n\n"
        printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt start ${MAGENTA}¬∑ recommended ¬∑ ${GRAY}starts the daemonized process (in background, not in a terminal)${NC}\n"
        printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt run ${GRAY}runs ${CYAN}dmt-proc${GRAY} in terminal foreground (stop it with ${UNDERLINE}ctrl+c${RESET}${GRAY})\n"
        echo
      else
        printf "${RED}‚úñ ${MAGENTA}üåÄ DMT PROC${NC} ${WHITE}is not currently running${NC}\n"
      fi
      ;;

    restart)
      #dmt_symlink_nodejs_deps
      compile_gui_if_missing

      printf "${CYAN}üåÄ DMT PROC${NC} ${MAGENTA}is restarting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" restart
      if [ $? -eq 0 ]; then
        local dmt_proc_pid=''
        local dmt_fg_bg=''
        get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

        if [ -n "$dmt_proc_pid" ]; then
          printf "\n${GREEN}‚úì${NC} ${CYAN}dmt-proc${NC} ${GRAY}restarted, use ${GREEN}dmt log ${GRAY}to see recent log entries if needed.${NC}\n"
        else
          printf "\n${RED}Problem restarting ${CYAN}dmt-proc${RED}, please use ${GREEN}dmt log ${RED}to determine the reason${NC}\n"
        fi
      fi
      ;;

    log) # show log in foreground and keep it updated
      dmt_log "$@"
      ;;

    # undocumented:

    flash)
      dmt_flash "$@"
      ;;

    bin)
      dmt_bin "$@"
      ;;

    cd)
      dmt_cd
      ;;

  esac
}

# function dmt_symlink_nodejs_deps {
#   local script="$DMT_NODE_CORE/.scripts/symlink_dmt_deps"

#   if [ -f "$script" ]; then
#     # changed recently!! if symlinking logic changes, we cannot just check if one symlink is present to know
#     # if we have to do something!!
#     #if [ ! -L "$DMT_NODE_CORE/dmt-bridge/node_modules" ] || [ ! -d "$DMT_USER_PATH/core/node/node_modules" ]; then
#       local cwd="`pwd`"
#       cd "$DMT_NODE_CORE/.scripts"
#       ./symlink_dmt_deps
#       cd "$cwd"
#     #fi
#   fi
# }

function setup_default_debug_marker_file {
  local markerfile="$1"

  echo "#mpv" > $markerfile
  echo "#mpv-ipc" >> $markerfile
  echo "#ws" >> $markerfile
  echo "#lanbus" >> $markerfile
  echo "#network-detect" >> $markerfile
  echo "#mqtt-sent" >> $markerfile
  echo "#mqtt-received" >> $markerfile
}

function debug_levels_from_markerfile_check_if_enabled {
  local markerfile="$1"
  local debug_level="$2"

  if grep -Fxq "$2" "$markerfile"
  then
      printf " ${GREEN}‚úì ${CYAN}"
  else
      printf "  ${GRAY}#${WHITE}"
  fi
}

function show_debug_levels_from_markerfile {
  local markerfile="$1"

  debug_levels_from_markerfile_check_if_enabled "$markerfile" "mpv"
  printf "mpv${NC} ${GRAY}enables mpv process logging into ${CYAN}~/.dmt/log/mpv.log${NC} ${NC}(‚ö†Ô∏è  requires ${GREEN}dmt restart${NC})${NC}\n"
  debug_levels_from_markerfile_check_if_enabled "$markerfile" "mpv-ipc"
  printf "mpv-ipc${NC} ${GRAY}enables debug messages between ${CYAN}dmt-proc${NC} ${GRAY}and${NC} ${CYAN}mpv${NC} ${GRAY}process in dmt log${NC}\n"
  debug_levels_from_markerfile_check_if_enabled "$markerfile" "ws"
  printf "ws${NC} ${GRAY}enables debug messages about websocket connections (port 7780)${NC}\n"
  debug_levels_from_markerfile_check_if_enabled "$markerfile" "lanbus"
  printf "lanbus${NC} ${GRAY}enables debug messages about lanbus${NC}\n"
  debug_levels_from_markerfile_check_if_enabled "$markerfile" "network-detect"
  printf "network-detect${NC} ${GRAY}enables debugging of current lan network and network segments identification${NC}\n"
  debug_levels_from_markerfile_check_if_enabled "$markerfile" "mqtt-sent"
  printf "mqtt-sent${NC} ${GRAY}enables debug messages about sent mqtt messages${NC}\n"
  debug_levels_from_markerfile_check_if_enabled "$markerfile" "mqtt-received"
  printf "mqtt-received${NC} ${GRAY}enables debug messages about received mqtt messages${NC}\n"
}

function compile_gui_if_missing {
  if [ ! -f "$DMT_NODE_CORE/gui/gui-frontend-core/app/public/bundle.js" ]; then
    dmt_gui build
  fi
}

# Reload the environment
function reload_shell {
  # if [ -f "$DMT_PATH/shell/compile" ]; then
  #   compile
  # fi
  # if [ -f ~/.bash_aliases ]; then
  #   . ~/.bash_aliases
  # fi

  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
  if [ -f ~/.bash_profile ]; then
    . ~/.bash_profile
  fi
  if [ -f ~/.profile ]; then
    . ~/.profile
  fi

  printf "${GREEN}Shell reloaded ‚úì${NC}\n"
}

function get_dmt_proc_pid {
  # space in " dmt-proc" is required
  local proc=$(ps -ef | grep " dmt-proc" | grep -v "nano dmt-proc" | grep -v "eslint" | grep -v "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')
  local procFG=$(ps -ef | grep "controller/daemons/dmt-proc.js" | grep -v "eslint" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -n "$proc" ]; then
    #ps -ef | grep " dmt-proc" | grep -v "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep
    eval "$1='$proc'"
    eval "$2='bg'"
    return
  fi

  # dmt process running in foreground
  if [ -n "$procFG" ]; then
    #ps -ef | grep "controller/daemons/dmt-proc.js" | grep -v "command -v openssl >/dev/null" | grep -v grep
    eval "$1='$procFG'"
    eval "$2='fg'"
  fi
}

function report_dmt_running {
  local dmt_proc_pid="$1"
  local fg_bg="$2"

  if [ -n "$dmt_proc_pid" ]; then
    local fg_bg_msg=""
    if [ "$fg_bg" == 'fg' ]; then
      fg_bg_msg="${MAGENTA}in foreground${NC} "
    fi
    printf "${CYAN}dmt-proc${NC} ${GREEN}is already running ${fg_bg_msg}with ${YELLOW}pid ${dmt_proc_pid}${NC}\n"
    return 0
  fi

  return 1
}

# warning: duplicated in ~/.dmt/etc/onboot/daemons
# function save_dmt_state {
#   local dmt_cli="${DMT_NODE_CORE}/controller/cli/dmt.js"
#   if [ -f "$dmt_cli" ]; then
#     node "$dmt_cli" save_state
#   fi
# }

function dmt_device {
  declare -a opts=(
    "cd"
    "select"
    "def"
    "edit"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    local device_name=''
    get_current_device device_name

    if [ -n "$device_name" ]; then
      printf "${CYAN}Device name: üí° ${MAGENTA}${device_name}${NC}\n\n"
    else
      printf "${GRAY}This device is ${RED}unnamed ü§î${GRAY}, please name it by running ${GREEN}dmt device select${GRAY} (or shorter: ${GREEN}dev sel${GRAY}).${NC}\n\n"
      return
    fi

    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd [device]${NC} ${GRAY}move to directory with device definition (${GREEN}dev cd ${GRAY}moves to this device's def)${NC}\n"
    printf "${GREEN}select${NC} ${GRAY}select configuration for this device from existing configurations or create a new configuration and assign it to this device${NC}\n"
    printf "${GREEN}def${NC} ${GRAY}shows parsed device.def definition in json format${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}edit current device's device.def${NC}\n"
    return
  fi

  local matching_opt=''
  dmt_opts_matcher matching_opt "$1" "${opts[@]}"

  shift

  case "$matching_opt" in
    cd)
      device_helper cd "$@"
      ;;

    edit)
      device_helper edit
      ;;

    select)
      local script="$DMT_SCRIPTS/setup_device"
      if [ -f "$script" ]; then
        "$script" "$@"
      fi
      ;;

    def)
      printf "${YELLOW}Showing device definition in json format (parsed from .def):${NC}\n"
      local cli="$DMT_NODE_CORE/controller/cli/device.js"
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$cli" "${hosts}" "$@"
      else
        $DMT_NODEJS_EXEC "$cli" "$@"
      fi
      ;;
  esac
}

function dev {
  dmt_device "$@"
}

function device {
  dmt_device "$@"
}

function device_helper {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd${NC} ${GRAY}${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}${NC}\n"
    printf "${GREEN}list${NC} ${GRAY}${NC}\n"
    printf "${GREEN}ping${NC} ${GRAY}${NC}\n"
  else
    declare -a opts=(
      "cd"
      "edit"
      "list"
      "ping"
    )

    local matching_opt=''
    dmt_opts_matcher matching_opt "$1" "${opts[@]}"
    if [ $? -ne 0 ]; then # error
      printf "Use ${GREEN}dmt help${NC} for more options.\n"
      echo
      #matching_opt="aaa" # default
    fi

    shift

    case "$matching_opt" in
      cd)
        local device="$1"

        if [ -z "$device" ]; then
          device="this"
        fi

        # if [ -z "$1" ]; then
        #   AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices
        #   if [ $? -eq 0 ] && [ -d "this/def" ]; then
        #     cd "this/def"
        #   fi
        # else

        AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices "$device"

        if [ $? -eq 0 ]; then
          if [ -d "def" ]; then
            cd "def"
          else
            printf "${GRAY}Moved to ${CYAN}${device}${GRAY} device directory but ${YELLOW}def ${GRAY}subdirectory is not present, please create it ...${NC}\n"
          fi
        else
          printf "${RED}not found${NC}\n"
        fi

        ;;

      edit)
        local dir="${DMT_USER_PATH}/devices/this"
        if [ -d "$dir" ]; then
          local file="${dir}/def/device.def"
          if [ -f "$file" ]; then
            nano "$file"
          else
            echo $file
            printf "${RED}device.def file not found${NC}\n"
          fi
        else
          printf "${RED}Device is unknown${GRAY}, please select the definition file by using ${GREEN}dev select${GRAY}, then try again.${NC}\n"
        fi
        ;;

      list)
        for_all_devices "list"
        ;;

      ping)
        for_all_devices
        ;;
    esac
  fi
}

function dmt_state {

  if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt state${NC} ${GRAY}show program state${NC}\n"
    printf "${GREEN}dmt state [store]${NC} ${GRAY}show a specific store state (device, player etc.)${NC}\n"
    printf "${GREEN}dmt state [store].[key]${NC} ${GRAY}ex.: player.playlist, device.deviceKey${NC}\n"
    printf "${GREEN}dmt state purge${NC} ${GRAY}delete program state${NC}\n"
    return
  fi

  local DMT_STATE_FILE="$DMT_PATH/state/program.json"

  if [ -f "$DMT_STATE_FILE" ]; then
    if [ "$1" == "purge" ]; then
      if [ -f "$DMT_STATE_FILE" ]; then
        #dmt stop
        rm "$DMT_STATE_FILE"
        printf "${GREEN}purged dmt state${NC}\n"
        #dmt start
      fi
    else
      if [ -n "$1" ]; then
        cat "${DMT_STATE_FILE}" | jq ".$1"
      else
        cat "${DMT_STATE_FILE}" #| jq
      fi
    fi
  else
    printf "${YELLOW}dmt state not found on storage media${NC}\n"
  fi
}

function gui_build_all {
  local cwd="`pwd`"

  local base_dir="$DMT_PATH/core/node/gui/gui-frontend-core"

  cd "$base_dir"

  for component in *; do
    if [ -d "$component" ] && [ "$component" != "common_assets" ]; then
      cd $component
      if [ -f "package.json" ]; then
        npm run build
      else
        printf "${GREEN}Gui component ${YELLOW}${component}${NC} ${GREEN}not buildable in isolation, it was probably (hopefuly) included from some other components...${NC}\n"
      fi
    fi
    cd "$base_dir"
  done

  cd "$cwd"
}

function gui_send_action_to_frontend {
  local cliGUI="$DMT_PATH/core/node/gui/cli/gui.js"
  local action="$1"
  local payload
  if [ -n "$2" ]; then
    #action="${action}:${2}"
    payload="$2"
  fi
  $DMT_NODEJS_EXEC "${cliGUI}" "$action" "$payload"
}

function dmt_gui {
  local dir="$DMT_PATH/core/node/gui/gui-frontend-core"
  local backendDir="$DMT_PATH/core/node/gui/gui-backend"

  # extract host from @ symbol but replace @all with the name of current network !
  local hosts=""

  local args
  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"
  do
    if [ "$arg" == "@all" ]; then
      local network_id=''
      get_current_network network_id
      if [ -n "$network_id" ]; then
        hosts="${hosts} @@$network_id"
        shift
      fi
    elif [[ "$arg" == @* ]] && [[ ! "$arg" =~ = ]]; then # @attr=val should not be treated as hostnames
      hosts="${hosts} ${arg}"
      shift
    fi
  done

  hosts=$(echo "$hosts" | xargs) # remove trailing whitespace

  local option="$1"

  if [ -z "$option" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt gui test${NC} ${GRAY}display a test notification on the gui${NC}\n"
    printf "${GREEN}dmt gui @deviceName test${NC} ${GRAY}display a test notification on remote gui${NC}\n"
    #printf "${GREEN}dmt gui cd [view]${NC} ${GRAY}${NC}\n"
    # printf "${GREEN}dmt_gui run${NC} ${GRAY}${NC}\n"
    # printf "${GREEN}dmt_gui build${NC} ${GRAY}build all GUIs${NC}\n"
    # printf "${GREEN}dmt_gui build [gui]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}dmt gui load [view]${NC} ${GRAY}loads the specified gui view (home, player, debug etc.)${NC}\n"
    printf "${GREEN}dmt gui reload${NC} ${GRAY}send request to frontend via websocket requesting reload of current url${NC}\n"
    printf "${GREEN}dmt gui reload [view]${NC} ${GRAY}reloads to the specified gui view (home, player, debug etc.)${NC}\n"
    printf "${GREEN}dmt gui switch [ip]${NC} ${GRAY}switches gui to specified IP (todo: use deviceName instead of ip)${NC}\n"
    # printf "${GREEN}dmt_gui debug${NC} ${GRAY}shows debugging info for current gui issues troubleshooting${NC}\n"
    return
  fi

  shift

  case "$option" in
    test)
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" gui_test "$@"
      else
        $DMT_NODEJS_EXEC "$DMT_CLI" gui_test "$@"
      fi
      ;;
    cd)
      awesome_cd "$dir" "$1"
      if [ $? -eq 0 ] && [ -d "src" ]; then
        cd "src"
      fi
      ;;

    load)
      local view="$1"
      gui_send_action_to_frontend "load" "$view"
      ;;

    reload)
      local view="$1"
      gui_send_action_to_frontend "reload" "$view"
      ;;

    switch)
      local ip="$1"
      gui_send_action_to_frontend "switch" "$ip"
      ;;

    run)
      #dmt_symlink_nodejs_deps # does not have an influence - this builds dmt apps, not dmt core.. will fix later
      local cwd="`pwd`"
      cd "$dir/app"
      npm run dev
      cd "$cwd"

      # if [ -z "$1" ]; then
      #   gui run app
      # elif [ "$1" == "." ]; then
      #   npm run dev
      # else
      #   awesome_cd "$dir" "$1"
      #   if [ $? -eq 0 ]; then
      #     npm run dev
      #   fi
      # fi
      ;;

    build)
      #dmt_symlink_nodejs_deps # does not have an influence - this builds dmt apps, not dmt core.. will fix later
      local cwd="`pwd`"
      cd "$dir/app"
      npm run build
      cd "$cwd"

      # if [ -z "$1" ]; then
      #   dmt_gui build app
      #   cd "$cwd"
      #   return
      # fi

      # awesome_cd "$dir" "$1"
      # if [ $? -eq 0 ]; then
      #   npm run build
      # fi


      ;;

    debug)
      echo "TODO"
      ;;

    *)
      awesome_cd "$dir" "$option"
      ;;
  esac
}

function dmt_log {
  #local foreground=false

  # if [ "$1" == "-h" ]; then
  #   printf "${YELLOW}Usage:${NC}\n"
  #   printf "${GREEN}dmt log${NC} ${GRAY}get last 10 log lines on this machine${NC}\n"
  #   printf "${GREEN}dmt @host log${NC} ${GRAY}get last 10 log lines for remote machine${NC}\n"
  #   printf "${GREEN}dmt logfg${NC} ${GRAY}local log in foreground (updates are visible as they come)${NC}\n"
  #   return
  # fi

  local logfile="$DMT_PATH/log/dmt.log"

  if [ "$1" == "full" ]; then
    cat "$logfile"
  else
    # ISSUE: 1) dmt logfg 2) COMMAND+K (clear screen) 3) update device.. 4) PROBLEM: even older log messages will be shown
    tail -f -n ${TAIL_LOG_LINES} "$logfile"
  fi
  # elif [ "$1" == "lan" ]; then
  #   printf "${MAGENTA}Not yet implemented ...${NC}\n"
  #   printf "${CYAN}Expect it in the next minor release of ${MAGENTA}dmt-system${NC}.${NC}\n"
  # else
  #   if [ -n "$hosts" ]; then
  #     $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" log "$@"
  #   else
  #     $DMT_NODEJS_EXEC "$DMT_CLI" log "$@"
  #   fi
  # fi
}

function dmt_help {
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt help ${GRAY}shows this help screen${NC}\n"
  #printf "${GREEN}dmt docs ${MAGENTA}shows documentation in a browser${NC}\n"
  #printf "  ${CYAN}‚ñ†${NC} ${GREEN}${UNDERLINE}dmt version${RESET} ${GRAY}¬∑ shows dmt version ‚Äî v$(cat "$DMT_PATH/.version")${NC}\n"
  #printf "  ${CYAN}‚ñ†${NC} ${GREEN}${UNDERLINE}dmt device${RESET} ${GRAY} ¬∑ device configuration and information${NC}\n"

  echo
  # printf "${YELLOW}Deactivation:${NC}\n"
  # echo
  # printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt deactivate ${GRAY} ¬∑ deactivates shell but keep it present (to get it back just do ${CYAN}./install${GRAY} ¬∑ )${NC}\n"
  # echo
  printf "${CYAN}üí° DMT PROC${NC} ${WHITE}management:${NC}\n"
  # printf "${CYAN}‚ñ† services will not persist after reboot ‚Äî ${MAGENTA}use the docs${CYAN} to easily configure this.${NC}"
  echo
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt start ${GRAY}starts the daemonized process ${CYAN}(dmt-proc)${NC}\n"
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt stop ${GRAY}stops the process${NC}\n"
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt restart ${GRAY}restarts the process${NC}\n"
  echo
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt run ${GRAY}runs dmt-proc visible in terminal foreground (mostly used for debugging)${NC}\n"
  echo
  # printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt log ${GRAY}shows a few recent log entries (${CYAN}dmt-proc${GRAY} has to be running) ${NC}\n"
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt log ${GRAY}shows realtime log, to quit press ${UNDERLINE}ctrl+c${RESET}${NC}\n"
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt log full ${GRAY}dumps the entire log to screen and doesn't wait for realtime output (another difference is that ${NC}dmt log ${GRAY}shows only the recent ${TAIL_LOG_LINES} entries)${NC}\n"
  #printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt loglan ${GRAY}starts listening to network log message broadcasts${NC}\n"

  echo
  printf "üëØ ${YELLOW}Code replication:${NC}\n"
  echo
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt next ${GRAY}gets the latest ${CYAN}dmt-proc${NC} ${GRAY}version from your source${NC}\n"
  #printf "  ${GREEN}‚ñ†${NC} ${GREEN}dmt next --dry ${GRAY}show what would ${WHITE}dmt next${GRAY} command do${NC}\n"
  echo
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt update [deviceName | ip_address] ${GRAY}clones ~/.dmt directory to another machine via SSH and restarts the process after update${NC}\n"
  printf "  ${CYAN}‚ñ†${NC} ${GREEN}dmt copy [deviceName | ip_address] ${GRAY}same as above but without process restart (only in-browser GUI is reloaded) ${NC}\n"
  echo
  printf "  If you want to do the reverse with the same effect,\n  you can fetch from machine with no dmt-proc currently installed:\n"
  echo
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}curl ${GRAY}[IP]${CYAN}:1111 | bash ${NC}\n"
  echo
  printf "  This replicates ${UNDERLINE}~/.dmt-proc${RESET} ${NC}from the remote machine where ${CYAN}dmt-proc${NC} is running to your machine.${NC}\n"

  echo
  # printf "‚ö†Ô∏è  ‚â° ${YELLOW}Not yet implemented${NC}\n"
  # echo
  printf "${MAGENTA}DMT Connectome${NC}\n"
  echo
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt nearby ${GRAY}shows nearby devices ${NC}\n"
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt connections ${GRAY}shows dmt-proc ${UNDERLINE}incoming${RESET} ${GRAY}and ${UNDERLINE}outgoing connections${RESET}${NC}\n"
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt protocols${NC} ${GRAY}show registered realtime communication protocols${NC}\n"
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt identities${NC} ${GRAY}manage cryptographic user identities${NC}\n"
  echo

  printf "${MAGENTA}GUI and State${NC}\n"
  echo
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt gui ${GRAY}various methods related to ${UNDERLINE}dmt-gui${RESET}\n"
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt state ${GRAY}shows dmt-proc ${UNDERLINE}in-memory program state${RESET} ${GRAY}(part of this is saved to ${UNDERLINE}program.json${RESET} ${GRAY}file)${NC}\n"
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt actors ${GRAY}shows dmt-proc registered actor objects than can be called over connectome or cli${NC}\n"
  echo

  printf "${MAGENTA}Search and Multimedia${NC}\n"
  echo
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt search ${GRAY}various methods for cli search\n"
  printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt media ${GRAY}various methods for cli media player manipulation\n"
  #printf "  ${CYAN}‚ñ†${NC} ${CYAN}dmt reach${NC} ${GRAY}[todo]${NC}\n"
}

function dmt_help_explain_rpc {
  echo
  return

  echo
  printf "${GRAY}_____________________________________________________________________________${NC}\n"
  echo
  printf "How to refer to other ${CYAN}dmt-proc${NC} instances on local network? ${YELLOW}Use ${MAGENTA}the @ symbol${NC} ‚Üí${NC}\n"
  echo
  printf "  ${MAGENTA}‚ñ†${NC} ${GREEN}dmt ${MAGENTA}@deviceName${GREEN} [log|services|etc.] ${GRAY}gets information about a device on local network${NC}\n"
  printf "  ${MAGENTA}‚ñ†${NC} ${GREEN}dmt ${MAGENTA}@ip_address${GREEN} [log|services|etc.] ${GRAY}same as above but directly with ip address instead of deviceName from device.def${NC}\n"
  printf "  while ${GREEN}dmt [log|services|etc.] ${GRAY}gets information about current device as usual${NC}\n"
  # printf "${GREEN}dmt @@remoteIpOrHost info ${GRAY}gets information about remote device on the other side of router WAN port${NC}\n"
  echo
  printf "  All methods in ${CYAN}cyan${NC} work in this way where an optional ${MAGENTA}@${NC} symbol\n"
  printf "  can be used to refer to other device on local area network.\n"
  echo
}

function dmt_version {
  printf "${MAGENTA}v$(cat "$DMT_PATH/.version")${NC}\n\n"
  local NUM=$(cat $HOME/.dmt/etc/.bash_aliases_bundle | grep function | wc -l | xargs)
  printf "${WHITE}${NUM} bash functions\n"
}

function get_dmt_source_from_user_def {
  local __dmt_source=''

  if [ -f "$DMT_USER_DEF_FILE" ]; then
    dmt_def_reader __dmt_source "$DMT_USER_DEF_FILE" "dmtSource"
  fi

  eval "$1='$__dmt_source'"

  # return

  # local _gatewayMac=''
  # get_gateway_mac _gatewayMac

  # if [ "$_gatewayMac" == "$LOCAL_DMT_SOURCE_MAC" ]; then
  #   eval "$1='local'"
  # else
  #   eval "$1='global'"
  # fi
}

function stop_dmt_if_running {
  local dmt_proc_pid=''
  local dmt_fg_bg=''
  get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

  if [ -n "$dmt_proc_pid" ]; then
    dmt stop
  fi
}

function dmt_nearby {
  if [ "$1" == "update" ] || [ "$1" == "copy" ]; then
    $DMT_NODEJS_EXEC "$CLI_DIR/nearby.js"

    local action="$1"

    shift

    local devices=()
    while read device
    do
      devices+=( "$device" )
    done < <( $DMT_NODEJS_EXEC "$CLI_DIR/nearby.js" --simple "$@" )

    #while read device
    for device in "${devices[@]}"; do
      echo

      local deviceInfo=(${device//;/ })
      local deviceName="${deviceInfo[0]}"
      local ipWithUser="${deviceInfo[1]}"

      printf "Updating device ${MAGENTA}${deviceName}${NC} ...\n"

      # todo: paralellize with screen as in update_all
      dmt "$action" "$ipWithUser" # dmt update | dmt copy
    done
    # this was not working anymore since we added ssh .. ~/.dmt/etc/scripts/dmt_via_git .. check in ./install
    # for some reason ... if we create array first then iterate over it, then it works in all cases !
    # done < <($DMT_NODEJS_EXEC "$CLI_DIR/nearby.js" --simple "$@")
  else
    $DMT_NODEJS_EXEC "$CLI_DIR/nearby.js" "$@"
    echo
    printf "üí° ${MAGENTA}Update all nearby devices:${NC}\n"
    echo
    printf "${CYAN}‚ñ†${NC} ${GREEN}dmt nearby update ${GRAY}¬∑ update all nearby devices (copy + restart ${UNDERLINE}dmt-proc${RESET}${GRAY})${NC}\n"
    echo
    #printf "${CYAN}‚ñ†${NC} ${GRAY}dmt nearby copy ${GRAY}¬∑ copy ~/.dmt to all nearby devices without restarting ${UNDERLINE}dmt-proc${RESET} ${GRAY}on each device${NC}\n"
  fi
}

function dmt_cache_current_version {
  mkdir -p ~/.dmt-here/tmp
  cp ~/.dmt/.version ~/.dmt-here/tmp/.prev_version
}

function dmt_next {
  # option 1: specify from where to fetch via an argument:
  # dmt next [dmtSource]
  # or from user.def ->
  # user:
  #  dmtSource: [dmtSource]

  local dry_run=false
  local save_zip=false
  local reflect_version=false
  local force=false
  local origin=false

  ARGS=()
  while (( "$#" )); do
    case "$1" in
      --dry)
        dry_run=true
        shift 1
        ;;
      --save-dmt-zip)
        save_zip=true
        shift 1
        ;;
      --force)
        force=true
        shift 1
        ;;
      --origin)
        origin=true
        shift 1
        ;;
      --help)
        dmt_next_help
        return
        ;;
      -h)
        dmt_next_help
        return
        ;;
      --) # end argument parsing
        shift
        break
        ;;
      -*|--*=) # unsupported flags
        printf "${RED}Error: Unsupported flag ${YELLOW}$1${NC}\n"
        #echo ""
        return
        ;;
      *) # preserve positional arguments
        ARGS+=($1)
        shift
        ;;
    esac
  done

  if $origin; then
    read -r -p "Are you sure you want to reset to github: uniqpath/dmt origin? [Y/n] " response
    if [[ $response =~ ^([nN])$ ]]
    then
      printf "${GRAY}‚Ü≥ Exiting ...${NC}\n"
      return
    fi

    setup_github_uniqpath_dmt_origin
    return
  fi

  # dmt next --dry
  # dmt next --dry url.com
  # if [ "$1" == "--dry" ]; then
  #   dry_run=true
  #   shift
  # fi

  # # dmt next url.com --dry
  # if [ "$2" == "--dry" ]; then
  #   dry_run=true
  # fi

  # 1) dmtSource from argument
  local arg=${ARGS[0]}

  # if [ "$arg" == "--help" ] || [  "$arg" == "-h" ]; then
  #   #dmt_next_help
  #   return
  # else
  #   printf "${GRAY}To read help for this command use: ${GREEN}dmt next -h${NC}\n"
  # fi

  # 2) dmtSource from user.def
  local dmt_source="$arg"

  if [ -n "$dmt_source" ]; then
    if $dry_run; then
      printf "${CYAN}1)${NC} ${MAGENTA}dmtSource${NC} provided as argument: ${MAGENTA}${dmt_source}${NC}\n"
    fi
  else
    if $dry_run; then
      echo
      printf "${CYAN}1.${NC} ${MAGENTA}dmtSource ${GRAY}not provided as argument to this command ${NC}...\n"
      printf "${CYAN}2.${NC} ${GRAY}Checking ~/.dmt/user/def/user.def for ${MAGENTA}dmtSource ${NC}...\n"
    fi

    get_dmt_source_from_user_def dmt_source

    #if [ -n "$dmt_source" ] && $dry_run; then
      #echo
      #printf "   ${GREEN}Found it!${NC}\n"
    #fi
  fi

  # aborting if couldn't determine dmtSource

  if [ -z "$dmt_source" ]; then
    if $dry_run; then echo; fi
    printf "${GRAY}Could not determine ${MAGENTA}dmtSource ${GRAY}... ${NC}"

    if [ -d "$DMT_PATH/.git" ]; then

      local cwd2="`pwd`"
      cd "$DMT_PATH"

      if $dry_run; then
        printf "${GRAY}Would fetch from the github origin:${NC}\n"
        #git remote show -n origin
        git remote get-url origin
      else
        local gitsource=`git remote get-url origin`

        if [[ "$gitsource" =~ uniqpath/dmt ]]; then
          echo
          printf "${GREEN}Found git origin ‚úì\n"
          printf "${GRAY}Updating from ${CYAN}${gitsource} ${GRAY}...${NC}\n"

          git fetch origin
          git checkout -f main

          echo
          printf "üî® ${MAGENTA}Hard resetting to ${CYAN}origin/main${NC} ...\n"

          git reset --hard origin/main

          printf "${GREEN}‚úì Done fetching latest code with git.${NC}\n\n"

          # duplicated in cron 5min
          if [ -f ~/.dmt-here/tmp/.prev_version ]; then
            prevVersion=$(cat ~/.dmt-here/tmp/.prev_version)
            currentVersion=$(cat ~/.dmt/.version)

            if [ "$prevVersion" != "$currentVersion" ]; then
              printf "Restarting dmt-proc after dmt next because version changed from ${CYAN}${prevVersion}${NC} to ${MAGENTA}${currentVersion}${NC}\n"
              echo

              dmt restart

              echo
              printf "It is also recommended to ${YELLOW}reload the terminal${NC} ‚Üí "
              printf "try ${GREEN}dmt reload${NC} command or logout and back in.\n"
            else
              printf "${WHITE}Version ${MAGENTA}(${currentVersion})${NC} did not change.${NC}\n"

              if $force; then
                printf "${GRAY}Restarting ${CYAN}dmt-proc ${GRAY}because of ${WHITE}--force${NC}\n"
                echo
                dmt restart
              # else
              #   printf "${GRAY}Not restarting ${CYAN}dmt-proc${NC}\n"
              fi
            fi
          else
            dmt restart
          fi

          # yet to decide ... we do this with automatic updates on server but (for now) we don't clean everything on manual updates..
          # git clean -f -d
          # maybe do it in the future if it's concluded that some manual files can interfere

          # printf "${CYAN}üí° Please run ${GREEN}dmt restart${NC} ${CYAN}now${NC} ...\n\n"

          echo

          dmt_cache_current_version
        else
          printf "${RED}Aborting fetch from unknown git source.${NC}"
        fi
      fi
    else
      if ! $dry_run; then printf "${RED}aborting.${NC}"; fi
      echo
      echo
      printf "üí° You can use ${GREEN}dmt next --origin${NC} to setup updates from ${CYAN}github: uniqpath/dmt\n"
      echo
    fi

    cd "$cwd2"
    return
  fi

  echo
  printf "${GREEN}‚úì Determined ${MAGENTA}dmtSource: ${CYAN}${dmt_source}${NC}\n"
  echo

  # dry run
  if $dry_run; then
    printf "${YELLOW}Conclusion: ${GREEN}dmt next${NC} ${WHITE}command would update DMT from ${CYAN}${dmt_source}${NC}\n"
    echo
    return
  fi

  # FETCHING ONLY ------------

  if $save_zip; then
    local dir=~/.dmt/state

    if [ -d "$dir" ]; then
      local cwd="`pwd`"
      cd "$dir"

      local fetched_file="dmt_in_progress.zip"

      if [ -f $fetched_file ]; then
        printf "${YELLOW}REMOVING FIRST${NC}\n"
        rm $fetched_file
      fi

      printf "${GREEN}Fetching ${MAGENTA}dmt.zip${NC} from ${CYAN}${dmt_source}${NC} ‚Üí ${YELLOW}${dir}${NC} ... ${NC}\n"

      if curl -L --fail "${dmt_source}/dmt.zip" -o $fetched_file; then
        mv $fetched_file dmt.zip
        echo
        printf "${GREEN}‚úì Fetched file ${YELLOW}${dir}/dmt.zip${NC}\n"
        printf "${GRAY}It will be served on ${dmt_source}/dmt.zip requests as long as it stays in this folder${NC}\n"
        printf "${GRAY}instead of process self-replication via streaming archiver.${NC}\n"
        echo
        printf "${GRAY}Saving corresponding version number of dmt.zip contents...${NC}\n"
        # a bit of duplication
        local remoteVersion=$(curl "$dmt_source"/version 2>/dev/null)

        if [[ "$remoteVersion" =~ "¬∑" ]]; then # 1.1.2 ¬∑ 2020-05-03
          echo "$remoteVersion" > dmt.zip.version.txt
        else
          printf "‚ö†Ô∏è  ${YELLOW}Failed to fetch remote version ...${NC}\n"
        fi
      else
        echo
        printf "${RED}Failed to fetch ${YELLOW}${dir}/dmt.zip ${RED}‚úñ${NC}\n"
      fi

      cd "$cwd"
    else
      printf "${RED}${dir} directory does not exist, aborting.${NC}\n"
    fi

    # end of fetch option
    return
  fi

  # Safeguard
  # duplicate above for --origin option
  #
  # we do this in adition to dev_machine check because it's safer
  # if we switch between device definitions temporarily for testing
  # then we're not "dev machine" anymore but it would still be a disaster to overwrite the main code
  if [ -f ~/.dmt/.prevent_dmt_next ]; then
    printf "${RED}Prevented operation because ~/.dmt/.prevent_dmt_next file is present, please remove it to continue${NC}\n"
    return
  fi

  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  # -----------------------------------------
  # .... Install from get-dmt.com server ....
  # -----------------------------------------

  if [[ "$dmt_source" =~ get-dmt.com$ ]]; then # get-dmt.com || alpha.get-dmt.com || ...

    # a bit of duplication
    local remoteVersion=$(curl http://${dmt_source}/version 2>/dev/null)

    if [[ ! "$remoteVersion" =~ "¬∑" ]]; then # 1.1.2 ¬∑ 2020-05-03
      printf "‚ö†Ô∏è  ${MAGENTA}${dmt_source}${NC} ${RED}is currently inaccessible...\n"
      echo
      printf "${YELLOW}Please try again later.${NC}\n"
      return
    fi

    local localVersion=$(cat ~/.dmt/.version)

    if ! "$force" && [ "$localVersion" == "$remoteVersion" ]; then
      printf "${CYAN}Your version ${MAGENTA}${localVersion}${NC} ${CYAN}is current!${NC}\n"
      echo
      printf "${GREEN}No need to update üòä${NC}\n"
      return
    fi

    if $force; then
      printf "${MAGENTA}--force flag: ${CYAN}update even if version has not officially changed but the code may still contain minor corrections${GRAY}${NC}\n"
      echo
    fi

    printf "Current version : ${GRAY}${localVersion}${NC}\n"
    printf "${MAGENTA}Next version${NC}    : ${MAGENTA}${remoteVersion}${NC}\n"

    echo

    if ! $force; then
      printf "${YELLOW}Do you want to update?${NC} ‚Ä¶\n"
      read -r -p "[Y/n] " response
      if [[ $response =~ ^([nN])$ ]]
      then
        printf "${GRAY}‚Ü≥ Exiting ...${NC}\n"
        echo
        return
      fi
    fi

  fi

  # ------------

  stop_dmt_if_running

  local cwd="`pwd`"

  #printf "${MAGENTA}dmtSource${NC} = ${CYAN}${dmt_source}${NC}\n"

  curl -L "${dmt_source}" | bash

  # ~/.dmt directory will get replaced under us ...
  # we move to it again ....
  cd "$cwd"

  mkdir -p ~/.dmt/state
  touch ~/.dmt/state/gui_reload.txt

  dmt start

  printf "${GREEN}Done.${NC}\n"
  echo
}

function setup_github_uniqpath_dmt_origin {
  # Safeguard
  # duplicate
  if [ -f ~/.dmt/.prevent_dmt_next ]; then
    printf "${RED}Prevented operation because ~/.dmt/.prevent_dmt_next file is present, please remove it to continue${NC}\n"
    return
  fi

  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  if [ ! -d ~/.dmt ]; then
    printf "${RED}~/.dmt directory is missing${NC}\n"
    return
  fi

  if [ -d ~/.dmt/.git ]; then
    rm -rf ~/.dmt/.git
  fi

  local cwd="`pwd`"

  cd ~/.dmt

  git init
  git remote add origin https://github.com/uniqpath/dmt.git
  git fetch origin

  git reset --hard origin/main # we have to do this because of possible local changes.. we will automatically create master branch as a side effect (in older version of git ?)
  git checkout -b main origin/main # create our main branch and make it track origin/main

  git branch -D master # delete accidentaly created master branch

  dmt_cache_current_version

  cd "$cwd"
}

function dmt_next_help {
  printf "${YELLOW}Usage:${NC}\n"
  printf "${GREEN}dmt next ${GRAY}read ${MAGENTA}dmtSource ${GRAY}from user.def, dmtSource is just an url from where to fetch the entire ${CYAN}dmt-proc ${GRAY}code${NC}\n"
  printf "${GREEN}dmt next [dmtSource] ${GRAY}specify manually (has precedence over user.def, careful!)${NC}\n"

  printf "${GREEN}dmt next --dry ${GRAY}does not do anything except showing you what would be the determined ${MAGENTA}dmtSource ${GRAY}value${NC}\n"
  echo
  printf "${GRAY}Rarely used:${NC}\n"
  printf "${CYAN}dmt next --force ${GRAY}fetch even if reported versions are the same${NC}\n"
  printf "${CYAN}dmt next --origin ${GRAY}setup fetching from github: uniqpath/dmt${NC}\n"

  # echo
  # printf "${MAGENTA}Supported formats for ${CYAN}dmtSource${NC}:\n"

  # printf "Regular url: ${CYAN}dmt-system.com/urlpath${NC} (attaches /getdmt to the end if urlpath is missing - example: just 'dmt-system.com' becomes 'dmt-system.com/getdmt')\n"
  # printf "${YELLOW}this options gets the bash script from the endpoint and executes it${NC}\n"

  # printf "Github url: ${CYAN}github.com/uniqpath/dmt${NC}\n"

  # printf "Local network: ${CYAN}192.168.0.50${NC} (attaches :1111 port if there is no port specified - example: just '192.168.0.70' becomes '192.168.0.70:1111')\n"
  # printf "Regular url or ip apart from 192.168.* with port specified: ${CYAN}somedomain.com:2222${NC}\n"

  # OPTION A -  dmt next dmt-system.com
  # dmt next github.com/uniqpath/dmt
  # OPTION C - local network - dmt next 192.168.0.50
  # OPTION C2 - local network with port included - dmt next 192.168.0.50:1111
  # OPTION D - regular url with port included: dmt next dmt-system.com:1111
}

function dmt_update {
  # dmt update nearby == dmt nearby update
  if [ "$1" == "nearby" ]; then
    dmt nearby update
    return
  fi

  dmt_copy --restart "$@"
}

function dmt_sync_apps_into_dmt_engine {
  local SYNC_APPS_SCRIPT="$DMT_THIS_DEVICE/scripts/sync_dmt_apps_into_engine"

  if [ -f "$SYNC_APPS_SCRIPT" ]; then
    "$SYNC_APPS_SCRIPT"
  fi
}

function dmt_copy {
  # dmt copy nearby == dmt nearby copy
  if [ "$1" == "nearby" ]; then
    dmt nearby copy
    return
  fi

  #dmt_symlink_nodejs_deps

  if [ -z "$1" ]; then
    if dev_machine; then
      printf "${RED}Prevented on dev machine${NC}\n"
    fi
  else
    compile_gui_if_missing

    dmt_sync_apps_into_dmt_engine

    local cwd="`pwd`"
    cd "$DMT_PATH"
    . ./install "$@" # calling with . preserves the newly loaded env
    cd "$cwd"
  fi
}

function dmt_deactivate {
  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  local backup_file="$LOGNAME_HOME/.bash_aliases-backup-by-dmt"

  if [ -L "$LOGNAME_HOME/.bash_aliases" ] && [ "$(head -3 $LOGNAME_HOME/.bash_aliases | tail -1)" == "# DMT ALIASES" ]; then
    rm ~/.bash_aliases

    if [ -f "$backup_file" ]; then
      mv "$backup_file" ~/.bash_aliases
    fi

    printf "${MAGENTA}dmt${NC} ${CYAN}was unlinked${NC}, only the folder ${CYAN}~/.dmt${NC} remains and is not active in any way.\n"
    echo
    printf "${CYAN}To reinstall${NC}\n"
    printf "${GREEN}cd $LOGNAME_HOME/.dmt${NC}\n"
    printf "${GREEN}./install${NC}\n"
    echo
    printf "${CYAN}To remove the unused directory${NC}\n"
    printf "${GREEN}rm -rf $LOGNAME_HOME/.dmt${NC}\n"
    echo
    printf "${WHITE}If you want to confirm that dmt is uninstalled you have to first reload the shell.${NC}\n"
  else
    printf "${RED}dmt is not installed${NC}\n"
  fi
}

function dmt_shell_setup {
  echo "dmt shell setup -- soon: coming in v1.2.0 --"
  # if [ -f ~/.dmt/user/def/user.def ]; then # should exist for sure -- except if user forgot to do ./install (when sample_user gets copied over) after cloning the dmt repo
  #   sed -i 's/#shell: full/shell: full/' ~/.dmt/user/def/user.def # uncomment this line in user.def (#shell: full ==> shell: full)
  # fi
}

function dmt_autoupdate_on {
  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  if [ -d ~/.dmt ]; then

    printf "${YELLOW}Enable autoupdate?${NC}\n"
    echo

    read -r -p "This will set up a git repo, any code changes to ~/.dmt will be overwritten [Y/n] " response
    if [[ $response =~ ^([nN])$ ]]
    then
      printf "${GRAY}‚Ü≥ Exiting ...${NC}\n"
      echo
      return
    fi

    which git > /dev/null 2>&1

    if [ ! $? -eq 0 ]; then
      printf "‚ö†Ô∏è  ${RED}git command does not seem to be installed, autoupdates will not work${NC}\n"
      return
    fi

    if [ -d ~/.dmt/.git ]; then
      rm -rf ~/.dmt/.git
    fi

    setup_github_uniqpath_dmt_origin # dangerous! -- we should always ask for permission before (Are you sure you want to enable autoupdate ‚Üë)

    echo
    dmt restart

    echo
    dmt_autoupdate # print info
  else
    printf "${RED}Directory ~/.dmt does not exist${NC}\n"
  fi
}

function dmt_autoupdate_off {
  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  if [ -d ~/.dmt/.git ]; then

    read -r -p "Are you sure you want to disable autoupdate? This will execute rm -rf ~/.dmt/.git [Y/n] " response
    if [[ ! $response =~ ^([nN])$ ]]
    then
      rm -rf ~/.dmt/.git

      printf "${CYAN}Auto-updates disabled.${NC}\n"
      echo
      dmt_autoupdate # print info
    fi

  else
    printf "${YELLOW}This device is not currently auto-updating because ~/.dmt/.git does not exist.${NC}\n"
  fi
}

function dmt_autoupdate {

  if [ "$1" == "on" ]; then
    dmt_autoupdate_on
    return
  fi

  if [ "$1" == "off" ]; then
    dmt_autoupdate_off
    return
  fi

  printf "‚Äî 1.) Prerequisites check ‚Äî ${CYAN}is periodic (5-min) cron task set up correctly?${NC}\n"
  echo

  local basic_setup_correct=0

  if [ -f $DMT_AUTO_UPDATE_LOG ]; then
    local file_age=$(( `date +%s` - `stat -L --format %Y $DMT_AUTO_UPDATE_LOG` ))
    printf "‚è±Ô∏è  ${MAGENTA}Auto-update was last tried ${WHITE}${file_age}s ago${NC} ${MAGENTA}via cron${NC}\n"
    #printf "${GRAY}(it is an extremely lightweight operation ‚Äî git fetch)${NC}\n"

    if [ $file_age -ge $((5*60+5)) ]; then # 5 minutes plus 5s
      echo
      printf "‚ö†Ô∏è  ${RED}It seems that cron-job is not setup correctly because more than 5 min elapsed since last auto-update check${NC}\n"
      basic_setup_correct=1
    else
      printf "${GREEN}‚úì This is less than 5min ago ${CYAN}‚Üí${CYAN} cron setup seems to be working correctly${NC}\n"
      echo
      printf "${YELLOW}Auto-update report log for previous check:${NC}\n"
      echo
      printf "${GRAY}------- REPORT -------${NC}\n"
      printf "${GRAY}( if you recently enabled auto-update please wait for${NC}\n"
      printf "${GRAY}  one 5min cycle to see up-to-date information )${NC}\n"
      echo
      cat $DMT_AUTO_UPDATE_LOG
      printf "${GRAY}----- END REPORT -----${NC}\n"
    fi
  else
    basic_setup_correct=1
    printf "${YELLOW}Auto-update seems to be disabled at cron-level${NC}\n"
    echo "(cron task is not set up or is set up incorrectly)"
    printf "${GRAY}It could also be very recently enabled ‚Üí please wait 5min and run this command again to be sure.${NC}\n"
  fi

  echo
  printf "‚Äî 2.) ${CYAN}Conclusion${NC}\n"
  echo

  if [[ "$basic_setup_correct" -eq 0 ]]; then

    if [ -d ~/.dmt/.git ]; then
      which git > /dev/null 2>&1

      if [ $? -eq 0 ]; then

        local cwd="`pwd`"
        cd ~/.dmt

        local gitsource=`git remote get-url origin`

        if [[ "$gitsource" =~ uniqpath/dmt ]]; then
          printf "${GREEN}‚úì‚úì ${MAGENTA}Auto-update is set up correctly.${NC}\n"
        else
          printf "‚ö†Ô∏è  ${YELLOW}Auto-update is working but from an incorrect source:${NC}\n"
          printf "${RED}Source:${NC}\n"
          git remote -v | grep origin | grep fetch
          echo
          printf "Should be: ${MAGENTA}origin  https://github.com/uniqpath/dmt.git${NC}\n"
        fi

        #...
        cd "$cwd"

        echo
        printf "üí° ${CYAN}You can turn auto-update off with ${GREEN}dmt autoupdate off${NC}\n"
        echo
      else
        printf "${GREEN}Basic setup seems correct with cron working but ‚Ü¥${NC}\n"
        printf "‚ö†Ô∏è  ${RED}git command does not seem to be installed, auto-update will not work${NC}\n"
      fi
    else
      printf "${GREEN}‚úì Basic setup is correct with periodic checks working but ‚Ü¥${NC}\n"
      echo
      printf "${YELLOW}‚Äî Auto-update is currently disabled because ${CYAN}~/.dmt ${YELLOW}is not a git repository.${NC}\n"
      echo
      printf "üí° ${CYAN}You can turn auto-update on with: ${GREEN}dmt autoupdate on${NC}\n"
      echo
    fi
  else
    printf "${YELLOW}‚úñ Cron setup is likely not correct (or you have to wait up to 5 min for it to take effect).${NC}\n"
    echo
    printf "${WHITE}Please try to set up cron tasks with:${NC}\n"
    printf "${GRAY}cd ~/.dmt/etc/cron${NC}\n"
    printf "${GRAY}./setup_cron${NC}\n"
    printf "${GRAY}(then wait for up to 5min to see the effects through ${GREEN}dmt autoupdate${GRAY})${NC}\n"
    echo
    printf "${YELLOW}Root (if you need Zeta certificate updates for lighttpd every 3 months${NC}\n"
    # printf "${GRAY}sudo su${NC}\n"
    printf "${GRAY}sudo su${NC}\n"
    printf "${GRAY}cd $HOME/.dmt/etc/cron/root${NC}\n"
    printf "${GRAY}./setup_root ${USER}${NC}\n"
  fi

  local CERT_UPDATE_LOG=~/.dmt-here/https/zetaseek.com/cert_auto_update_report.txt

  if [ -f $CERT_UPDATE_LOG ]; then
    local file_age=$(( `date +%s` - `stat -L --format %Y $CERT_UPDATE_LOG` ))

    if [ $file_age -le $((60*60+5)) ]; then # 1h plus 5s
      printf "‚Äî 3.) ${CYAN}Extra:${NC}\n"
      echo
      printf "${GREEN}‚úì ${MAGENTA}ZetaSeek ${GREEN}https certificate auto-update is set up correctly${NC}\n"
    fi
  fi
}

function dmt_cd {
  cd "$DMT_PATH"
}

function dmt_bin {
  declare -a opts=(
    "compile"
    "download"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "${opts[@]}"
    return
  fi

  local matching_opt=''
  dmt_opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "Use -h to see valid options\n\n"
    #matching_opt="aaa" # default
    return
  fi

  shift

  case "$matching_opt" in
    compile)
      if [ -d $DMT_RUST_CORE ]; then
        dmt_compile_bin
      else
        echo "rust core doesn't exists"
      fi
      ;;

    download)
      ;;
  esac
}

function dmt_compile_bin {
  local cwd="`pwd`"

  # todo: ... + generalize the process somehow....

  printf "${MAGENTA}$DMT_RUST_CORE/walkdir${NC}\n"
  if [ -d "$DMT_RUST_CORE/walkdir" ]; then
    cd "$DMT_RUST_CORE/walkdir"
    cargo build --release --example walkdir
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/examples/walkdir "${DMT_PLATFORM_BIN}/walkdir" >/dev/null 2>&1; then
        printf "${GREEN}‚úì Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/examples/walkdir "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}‚úì Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  echo

  printf "${MAGENTA}$DMT_RUST_CORE/walksearch${NC}\n"
  if [ -d "$DMT_RUST_CORE/walksearch" ]; then
    cd "$DMT_RUST_CORE/walksearch"
    cargo build --release
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/walksearch "${DMT_PLATFORM_BIN}/walksearch" >/dev/null 2>&1; then
        printf "${GREEN}‚úì Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/walksearch "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}‚úì Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  cd "$cwd"
}
