#!/bin/bash

CLI_DIR="$DMT_NODE_CORE/controller/cli/"

DMT_CLI="$CLI_DIR/dmt.js"

TAIL_LOG_LINES=300

function dmt {
  if [ -z "$1" ] || [ "$1" == "help" ] || [ "$1" == "version" ]; then
    echo
    printf "${MAGENTA}        âˆž DMT âˆž${NC}\n"
    #printf "${CYAN}Freedom to imagine${NC}\n"
    printf "${CYAN}Digital Mastery Techniques${NC}\n"
    printf " ${CYAN}â€” ${GRAY}v$(cat "$DMT_PATH/.version") ${CYAN}â€”${NC}\n"
    #printf "${CYAN}${NC}\n"
    echo
  fi

  # dmt [command] @hosts [terms]
  local command=''

  if [[ "$1" != @* ]]; then
    command="$1"
    shift
  fi

  # extract host from @ symbol but replace @all with the name of current network !
  local hosts=""

  local args
  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"
  do
    if [ "$arg" == "@all" ]; then
      local network_id=''
      get_current_network network_id
      if [ -n "$network_id" ]; then
        hosts="${hosts} @@$network_id"
        shift
      fi
    elif [[ "$arg" == @* ]] && [[ ! "$arg" =~ = ]]; then # @attr=val should not be treated as hostnames
      hosts="${hosts} ${arg}"
      shift
    fi
  done

  hosts=$(echo "$hosts" | xargs) # remove trailing whitespace

  declare -a opts=(
    "help"
    "info"
    "gui"
    "status"
    "version"
    "device"
    "nearby"
    "state"
    "reach"
    "connections"
    "services"
    "next"
    "core"
    "update"
    "copy"
    "debug"
    "log"
    "install"
    "start"
    "run"
    "startprofiler"
    "restart"
    "restart2"
    "stop"
    "state"
    "link"
    "unlink"
    "relink"
    "deactivate"
    "bin"
    "media"
    "search"
    "reload"
  )

  if dev_machine; then
    declare -a opts_admin=(
      "cd"
    )

    opts=("${opts[@]}" "${opts_admin[@]}")
  fi

  if [ "$command" == '-h' ] || [ "$command" == '--help' ]; then
    command="help"
  fi

  local matching_opt=''
  dmt_opts_matcher matching_opt "$command" "${opts[@]}"

  if [ -z "$matching_opt" ] && [ -n "$command" ]; then
    printf "ðŸ’¡ Try ${GREEN}dmt help${NC} to see the available options.\n"
    echo
    return
  fi

  # show process info

  local dmt_proc_pid=''
  local dmt_fg_bg=''
  get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

  local proc_manager=$(ps -ef | grep "dmt-proc" | grep "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -z "$hosts" ]; then # if we're targeting remote hosts, information about our own local process is irrelevant
    if [ "$matching_opt" != "next" ] && [ "$matching_opt" != "start" ] && [ "$matching_opt" != "run" ] && [ "$matching_opt" != "debug" ] && [ "$matching_opt" != "device" ]; then
      if [ -n "$dmt_proc_pid" ]; then
        local comment='';
        if [ "$dmt_fg_bg" == "fg" ]; then
          comment=" ${GRAY}in another terminal (it is not 'daemonized')${NC}"
        fi

        printf "${GREEN}${CYAN}ðŸŒ€ DMT Process${GREEN} is running ðŸ‘Œ${comment} Â· ${YELLOW}Process ID (PID) ${dmt_proc_pid}${NC}\n"

        # TIP ðŸ’¡ friendly help
        if [ -z "$matching_opt" ]; then
          echo
          # has a duplicate!
          printf "${YELLOW}ðŸ’¡ TIPS:${NC}\n\n"
          if [ "$dmt_fg_bg" == "fg" ]; then
            #printf "You can also use ${GREEN}sudo kill -9 ${dmt_proc_pid}${NC} to kill the process now.\n"

            printf "  ${CYAN}â– ${NC} ${GREEN}sudo kill -9 ${dmt_proc_pid} ${GRAY}stop the process ${GRAY}(you can also switch to the other terminal and press ${UNDERLINE}ctrl+c${RESET}${GRAY})${NC}\n"
          else
            printf "  ${CYAN}â– ${NC} ${GREEN}dmt stop ${GRAY}stop the process ${dmt_proc_pid}${NC}\n"
            printf "  ${CYAN}â– ${NC} ${GREEN}dmt restart ${GRAY}restart the process ${dmt_proc_pid}${NC}\n"
          fi

          printf "  ${CYAN}â– ${NC} ${GREEN}dmt log ${GRAY}shows realtime log, to quit press ${UNDERLINE}ctrl+c${RESET}${NC}\n"
        fi
      elif [ "$matching_opt" != "stop" ] && [ "$matching_opt" != "restart" ]; then
        printf "${RED}âœ– ${MAGENTA}ðŸŒ€ DMT Process${NC} ${WHITE}is not currently running.${NC}\n"
        if [ -n "$proc_manager" ]; then
          printf ".... ${GREEN}looks like dmt process manager is currently (re)starting ${WHITE}dmt-proc${NC} ....\n"
        fi

        # TIP ðŸ’¡ friendly help
        if [ -z "$matching_opt" ]; then
          echo
          # has a duplicate!
          # printf "ðŸ’¡ ${WHITE}Two options for starting:\n\n"
          printf "  ${CYAN}â– ${NC} ${GREEN}dmt start ${MAGENTA}â€” recommended â€” ${GRAY}starts the daemonized proccess (in background, not inside a terminal)${NC}\n"
          printf "  ${CYAN}â– ${NC} ${GREEN}dmt run ${GRAY}runs ${CYAN}dmt-proc${GRAY} in terminal foreground (stop it with ${UNDERLINE}ctrl+c${RESET}${GRAY})${NC}\n"
        fi
      fi
      echo
    fi
  fi

  # exit if no argument was given
  if [ -z "$matching_opt" ]; then
    if [ -z "$hosts" ]; then
      printf "Use ${GREEN}dmt help${NC} for more options.\n"
      echo

    #   if [ -z "$1" ] && [ -n "$proc" ] ; then
    #     echo
    #     printf "${CYAN}This device info:${NC}\n\n"
    #     if [ ! -f "$DMT_DEVICE_FILE" ]; then
    #       printf "${RED}Reminder â— ${GRAY}you still need to configure this device â— ${CYAN}please run â†’ \n\n${GREEN}  dmt device select${NC}\n\n"
    #       return
    #     fi
    #   fi
    fi

    return

    # if [ -z "$1" ]; then
    #   matching_opt="help"
    # else
    #   return
    # fi
  fi

  case "$matching_opt" in
    help)
      dmt_help

      if [ -n "$hosts" ]; then
        dmt_help_explain_rpc
      else
        dmt_help_explain_rpc

        printf "${GRAY}_____________________________________________________________________________${NC}\n"
        echo

        if [ -z "$dmt_proc_pid" ]; then
          printf "${RED}âœ–${NC} ${MAGENTA}ðŸŒ€ DMT Process${NC} ${WHITE}is not running${NC}"
          printf " ${CYAN}â†’ Please use ${GREEN}dmt start${NC} ðŸ’¡ðŸš€ðŸŽ¸\n"
          echo
        else
          printf "${GREEN}âœ“${NC} ${CYAN}ðŸŒ€ DMT Process${NC} ${GRAY}is ${WHITE}currently running${GRAY} on this device â€¦${NC}\n"
          echo
        fi
      fi
      ;;

    info)
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" info "$@"
      else
        if [ -n "$dmt_proc_pid" ]; then
          $DMT_NODEJS_EXEC "$DMT_CLI" info "$@"
        fi
      fi
      ;;

    nearby)
      if [ -n "$dmt_proc_pid" ]; then
        dmt_nearby "$@"
      fi
      ;;

    state)
      if [ -n "$dmt_proc_pid" ]; then
        $DMT_NODEJS_EXEC "$CLI_DIR/state.js" "$@"
      fi
      ;;

    connections)
      if [ -n "$dmt_proc_pid" ]; then
        $DMT_NODEJS_EXEC "$CLI_DIR/connections.js" "$@"
      fi
      ;;

    reach)
      if [ -n "$dmt_proc_pid" ]; then
        $DMT_NODEJS_EXEC "$CLI_DIR/reach.js" "$@"
      fi
      ;;

    reload)
      reload_shell
      ;;

    gui)
      if [ -n "$hosts" ]; then
        dmt_gui "$hosts" "$@"
      else
        # if [ -n "$dmt_proc_pid" ]; then
        #   node "$DMT_CLI" gui_test "$@"
        # fi
        dmt_gui "$@"
      fi
      ;;

    debug)
      local markerfile="$DMT_STATE/.debug-mode"
      local markerfile_display="~/.dmt/state/.debug-mode"

      # dmt debug edit
      if [ "$1" == "edit" ]; then
        echo "#mpv" > $markerfile
        echo "#mpv-ipc" >> $markerfile
        echo "#ws" >> $markerfile
        echo "#lanbus" >> $markerfile
        echo "#network-detect" >> $markerfile
        echo "#mqtt-sent" >> $markerfile
        echo "#mqtt-received" >> $markerfile

        nano $markerfile

        return
      fi

      if [ -z "$1" ] || [ "$1" == "on" ] || [ "$1" == "enable" ]; then
        if [ -f "$markerfile" ]; then
          printf "${GRAY}âœ“ Debug mode was already enabled${NC}\n"
        else
          touch "$markerfile"
          printf "${GREEN}âœ“ ${YELLOW}Debug mode âš™ï¸  enabled${NC}\n"
        fi

        printf "\n${MAGENTA}Debugging options:${NC}\n"

        printf "\nExecute ${GREEN}dmt debug edit${NC} and remove comments to increase particular debug log level (one line, one category).\n"
        printf "\nTo make it more permanent, add this to device.def ${GRAY}(command:${NC} ${GREEN}dev edit${NC}${GRAY})${NC}:\n"
        printf "${MAGENTA}debug:${NC}\n"
        printf "  ${MAGENTA}log: ${GRAY}mpv${NC}\n"
        printf "  ${MAGENTA}log: ${GRAY}lanbus${NC}\n"
        printf "  ${MAGENTA}log: ${GRAY}...${NC}\n"
        printf "\nâš ï¸  ${GRAY}This, however, requires ${GREEN}dmt restart${GRAY} while editing the ${YELLOW}.debug-mode${GRAY} file does not.${NC}\n"

        echo

        printf "${MAGENTA}Options:${NC}\n"
        printf "${MAGENTA}--------${NC}\n\n"

        printf "${GREEN}mpv${NC} ${GRAY}enables mpv process logging into ~/.dmt/log/mpv.log (requires dmt restart ${NC}while other commands do not!${NC})${NC}\n"
        printf "${GREEN}mpv-ipc${NC} ${GRAY}enables debug messages between ${MAGENTA}dmt-process${NC} ${GRAY}and${NC} ${CYAN}mpv${NC} ${GRAY}process${NC}\n"
        printf "${GREEN}ws${NC} ${GRAY}enables debug messages about websocket connections (port 7780 -- metagui)${NC}\n"
        printf "${GREEN}lanbus${NC} ${GRAY}enables debug messages about lanbus${NC}\n"
        printf "${GREEN}network-detect${NC} ${GRAY}enables debugging of current lan network and network segments identification${NC}\n"
        printf "${GREEN}mqtt-sent${NC} ${GRAY}enables debug messages about sent mqtt messages${NC}\n"
        printf "${GREEN}mqtt-received${NC} ${GRAY}enables debug messages about received mqtt messages${NC}\n"
        #printf "${GREEN}beats${NC} ${GRAY}todo${NC}\n"
      fi

      if [ "$1" == "off" ] || [ "$1" == "disable" ] || [ "$1" == "stop" ]; then
        if [ -f "$markerfile" ]; then
          rm "$markerfile"
          printf "${CYAN}Debug mode disabled${NC}\n"
        else
          printf "${GRAY}Debug mode was already disabled${NC}\n"
        fi
      fi
      ;;

    search)
      if [ -n "$hosts" ]; then
        dmt_search "${hosts}" "$@"
      else
        dmt_search "$@"
      fi
      ;;

    media)
      if [ -n "$hosts" ]; then
        dmt_media "${hosts}" "$@"
      else
        dmt_media "$@"
      fi
      ;;

    services)
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" services "$@"
      else
        $DMT_NODEJS_EXEC "$DMT_CLI" services "$@"
      fi
      ;;

    version)
      dmt_version
      ;;

    device)
      dmt_device "$@"
      ;;

    next)
      dmt_next "$@"
      ;;

    update) # updates the whole folder and restarts the service
      dmt_update "$@"
      ;;

    copy) # updates the whole folder, doesn't restart the service
      dmt_copy "$@"
      ;;

    deactivate)
      dmt_deactivate
      ;;

    link)
      local dir="$DMT_NODE_CORE/.scripts"
      if [ -d "$dir" ]; then
        local cwd="`pwd`"
        cd "$dir"
        ./symlink_dmt_deps
        # printf "${GREEN}Linked.${NC}\n"
        cd "$cwd"
      fi
      ;;

    unlink)
      local dir="$DMT_NODE_CORE/.scripts"
      if [ -d "$dir" ]; then
        local cwd="`pwd`"
        cd "$dir"
        ./symlink_dmt_deps "remove"
        # printf "${MAGENTA}Unlinked.${NC}\n"
        cd "$cwd"
      fi
      ;;

    # checklink)
    #   local cwd="`pwd`"
    #   cd "$DMT_NODE_CORE/.scripts"
    #   ./symlink_dmt_deps "check"
    #   cd "$cwd"
    #   ;;

    relink) #rarely used, usually "dmt link" is enough for this purpose as well... use "dmt relink" only if suddenly symlinks should point somewewhere else... if just some new symlinks have to be added, there is no need to unlink first, the symlinking script (dmt link) will add what's missing
      dmt unlink
      dmt link
      ;;

    start)
      if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
        return
      fi

      dmt_symlink_nodejs_deps
      compile_gui_if_missing

      printf "${CYAN}ðŸŒ€ DMT Process${NC} ${MAGENTA}is starting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" start

      # see if process is actually running
      local dmt_proc_pid=''
      local dmt_fg_bg=''
      get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

      if [ -n "$dmt_proc_pid" ]; then
        printf "\n${CYAN}âœ“ dmt-proc${NC} ${GRAY}should now be running, use ${GREEN}dmt log ${GRAY}to see recent log entries.${NC}\n"
        echo
          # has a duplicate!
          printf "${YELLOW}ðŸ’¡ TIPS:${NC}\n\n"
          printf "  ${CYAN}â– ${NC} ${GREEN}dmt stop ${GRAY}stop the process ${dmt_proc_pid}${NC}\n"
          printf "  ${CYAN}â– ${NC} ${GREEN}dmt restart ${GRAY}restart the process ${dmt_proc_pid}${NC}\n"
          printf "  ${CYAN}â– ${NC} ${GREEN}dmt log ${GRAY}shows realtime log, to quit press ${UNDERLINE}ctrl+c${RESET}${NC}\n"
          echo
      else
        printf "\n${RED}Problem starting ${CYAN}dmt-proc${RED}, please use ${GREEN}dmt logfg ${RED}to determine the reason${NC}\n"
      fi
      ;;

    run) # START FOREGROUND
      if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
        return
      fi

      dmt_symlink_nodejs_deps
      compile_gui_if_missing

      printf "${CYAN}ðŸŒ€ DMT Process${NC} ${WHITE}is running in terminal foreground ${NC}(this is marked with ${RED}'âœ'${NC})\n"
      echo
      printf "âš ï¸  Process will be ${RED}âœerminated${NC} if you ${UNDERLINE}close the terminal tab${RESET}${NC} or ${UNDERLINE}exit the remote terminal ssh session${RESET}.${NC}\n"
      echo
      printf "ðŸ’¡ Stop it manually when needed by pressing ${UNDERLINE}ctrl+c${RESET}${NC}\n"
      echo
      printf "ðŸ’¡ To keep the process active ('daemonized') in the background please use ${GREEN}dmt start${NC}.\n"
      printf "   You can see the equivalent realtime log output of the daemonized process with ${GREEN}dmt log${NC}.\n"
      echo

      $DMT_NODEJS_EXEC --trace-warnings "${DMT_NODE_CORE}/controller/daemons/dmt-proc.js" --fg # --fg: only for informative purposes to signal that we ran it in foreground as opposed to daemonizing (dmt start)
      ;;

    # startprofiler)
    #   if report_dmt_running "$dmt_proc_pid" "$dmt_fg_bg"; then
    #     return
    #   fi

    #   dmt_symlink_nodejs_deps
    #   compile_gui_if_missing

    #   printf "${MAGENTA}dmt-proc${NC} ${WHITE}is starting in ${CYAN}foreground${NC} ...\n\n"
    #   $DMT_NODEJS_EXEC --trace-warnings --prof "${DMT_NODE_CORE}/controller/daemons/dmt-proc.js"  --fg # --fg: only for informative purposes to signal that we ran it in foreground as opposed to daemonizing (dmt start)
    #   ;;

    stop)
      local dmt_proc_pid=''
      local dmt_fg_bg=''
      get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

      if [[ $dmt_fg_bg == 'fg' ]]; then
        printf "âš ï¸  ${RED}Cannot stop ${CYAN}dmt-proc${NC} !\n"
        printf "   ${WHITE}Reason${NC} â†’ it is running in ${WHITE}${UNDERLINE}another terminal${RESET}${NC} (it was started with ${WHITE}${UNDERLINE}dmt run${RESET}${NC} command).${NC}\n"
        echo
        printf "ðŸ’¡ Please switch to that terminal and press ${UNDERLINE}ctrl+c${RESET} to stop the process.${NC}\n"
        printf "   Or you can use ${GREEN}sudo kill -9 ${dmt_proc_pid}${NC} to kill the process from this terminal.\n"
        echo
        return
      fi

      if [ -n "$dmt_proc_pid" ]; then
        printf "${CYAN}ðŸŒ€ DMT Process${NC} ${MAGENTA}is stopping...${NC}\n\n"
        "${DMT_PATH}/etc/onboot/daemons" stop

        echo
        # has a duplicate!
        printf "ðŸ’¡ ${YELLOW}TIPS:\n\n"
        printf "  ${CYAN}â– ${NC} ${GREEN}dmt start ${MAGENTA}Â· recommended Â· ${GRAY}starts the daemonized proccess (in background, not in a terminal)${NC}\n"
        printf "  ${CYAN}â– ${NC} ${GREEN}dmt run ${GRAY}runs ${CYAN}dmt-proc${GRAY} in terminal foreground (stop it with ${UNDERLINE}ctrl+c${RESET}${GRAY})\n"
        echo
      else
        printf "${RED}âœ– ${MAGENTA}ðŸŒ€ DMT Process${NC} ${WHITE}is not currently running${NC}\n"
      fi
      ;;

    restart)
      dmt_symlink_nodejs_deps
      compile_gui_if_missing

      printf "${CYAN}ðŸŒ€ DMT Process${NC} ${MAGENTA}is restarting...${NC}\n\n"
      "${DMT_PATH}/etc/onboot/daemons" restart
      if [ $? -eq 0 ]; then
        local dmt_proc_pid=''
        local dmt_fg_bg=''
        get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

        if [ -n "$dmt_proc_pid" ]; then
          printf "\n${GREEN}âœ“${NC} ${CYAN}dmt-proc${NC} ${GRAY}restarted, use ${GREEN}dmt log ${GRAY}to see recent log entries if needed.${NC}\n"
        else
          printf "\n${RED}Problem restarting ${CYAN}dmt-proc${RED}, please use ${GREEN}dmt log ${RED}to determine the reason${NC}\n"
        fi
      fi
      ;;

    log) # show log in foreground and keep it updated
      dmt_log "$@"
      ;;

    # undocumented:

    flash)
      dmt_flash "$@"
      ;;

    bin)
      dmt_bin "$@"
      ;;

    cd)
      dmt_cd
      ;;

  esac
}

function dmt_symlink_nodejs_deps {
  local script="$DMT_NODE_CORE/.scripts/symlink_dmt_deps"

  if [ -f "$script" ]; then
    # changed recently!! if symlinking logic changes, we cannot just check if one symlink is present to know
    # if we have to do something!!
    #if [ ! -L "$DMT_NODE_CORE/dmt-bridge/node_modules" ] || [ ! -d "$DMT_USER_PATH/core/node/node_modules" ]; then
      local cwd="`pwd`"
      cd "$DMT_NODE_CORE/.scripts"
      ./symlink_dmt_deps
      cd "$cwd"
    #fi
  fi
}

function compile_gui_if_missing {
  if [ ! -f "$DMT_NODE_CORE/gui/gui-frontend-core/app/public/bundle.js" ]; then
    dmt_gui build
  fi
}

# Reload the environment
function reload_shell {
  # if [ -f "$DMT_PATH/shell/compile" ]; then
  #   compile
  # fi
  # if [ -f ~/.bash_aliases ]; then
  #   . ~/.bash_aliases
  # fi

  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
  if [ -f ~/.bash_profile ]; then
    . ~/.bash_profile
  fi
  if [ -f ~/.profile ]; then
    . ~/.profile
  fi

  printf "${GREEN}Shell reloaded âœ“${NC}\n"
}

function get_dmt_proc_pid {
  # space in " dmt-proc" is required
  local proc=$(ps -ef | grep " dmt-proc" | grep -v "nano dmt-proc" | grep -v "eslint" | grep -v "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')
  local procFG=$(ps -ef | grep "controller/daemons/dmt-proc.js" | grep -v "eslint" | grep -v "command -v openssl >/dev/null" | grep -v grep | awk '{print $2}')

  if [ -n "$proc" ]; then
    #ps -ef | grep " dmt-proc" | grep -v "manager.js" | grep -v "command -v openssl >/dev/null" | grep -v grep
    eval "$1='$proc'"
    eval "$2='bg'"
    return
  fi

  # dmt process running in foreground
  if [ -n "$procFG" ]; then
    #ps -ef | grep "controller/daemons/dmt-proc.js" | grep -v "command -v openssl >/dev/null" | grep -v grep
    eval "$1='$procFG'"
    eval "$2='fg'"
  fi
}

function report_dmt_running {
  local dmt_proc_pid="$1"
  local fg_bg="$2"

  if [ -n "$dmt_proc_pid" ]; then
    local fg_bg_msg=""
    if [ "$fg_bg" == 'fg' ]; then
      fg_bg_msg="${MAGENTA}in foreground${NC} "
    fi
    printf "${CYAN}dmt-proc${NC} ${GREEN}is already running ${fg_bg_msg}with ${YELLOW}pid ${dmt_proc_pid}${NC}\n"
    return 0
  fi

  return 1
}

# warning: duplicated in ~/.dmt/etc/onboot/daemons
# function save_dmt_state {
#   local dmt_cli="${DMT_NODE_CORE}/controller/cli/dmt.js"
#   if [ -f "$dmt_cli" ]; then
#     node "$dmt_cli" save_state
#   fi
# }

function dmt_device {
  declare -a opts=(
    "cd"
    "select"
    "def"
    "edit"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    local device_name=''
    get_current_device device_name

    if [ -n "$device_name" ]; then
      printf "${CYAN}Device name: ðŸ’¡ ${MAGENTA}${device_name}${NC}\n\n"
    else
      printf "${GRAY}This device is ${RED}unnamed ðŸ¤”${GRAY}, please name it by running ${GREEN}dmt device select${GRAY} (or shorter: ${GREEN}dev sel${GRAY}).${NC}\n\n"
      return
    fi

    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd [device]${NC} ${GRAY}move to directory with device definition (${GREEN}dev cd ${GRAY}moves to this device's def)${NC}\n"
    printf "${GREEN}select${NC} ${GRAY}select configuration for this device from existing configurations or create a new configuration and assign it to this device${NC}\n"
    printf "${GREEN}def${NC} ${GRAY}shows parsed device.def definition in json format${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}edit current device's device.def${NC}\n"
    return
  fi

  local matching_opt=''
  dmt_opts_matcher matching_opt "$1" "${opts[@]}"

  shift

  case "$matching_opt" in
    cd)
      device_helper cd "$@"
      ;;

    edit)
      device_helper edit
      ;;

    select)
      local script="$DMT_SCRIPTS/setup_device"
      if [ -f "$script" ]; then
        "$script" "$@"
      fi
      ;;

    def)
      printf "${YELLOW}Showing device definition in json format (parsed from .def):${NC}\n"
      local cli="$DMT_NODE_CORE/controller/cli/device.js"
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$cli" "${hosts}" "$@"
      else
        $DMT_NODEJS_EXEC "$cli" "$@"
      fi
      ;;
  esac
}

function dev {
  dmt_device "$@"
}

function device {
  dmt_device "$@"
}

function device_helper {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}cd${NC} ${GRAY}${NC}\n"
    printf "${GREEN}edit${NC} ${GRAY}${NC}\n"
    printf "${GREEN}list${NC} ${GRAY}${NC}\n"
    printf "${GREEN}ping${NC} ${GRAY}${NC}\n"
  else
    declare -a opts=(
      "cd"
      "edit"
      "list"
      "ping"
    )

    local matching_opt=''
    dmt_opts_matcher matching_opt "$1" "${opts[@]}"
    if [ $? -ne 0 ]; then # error
      printf "Use ${GREEN}dmt help${NC} for more options.\n"
      echo
      #matching_opt="aaa" # default
    fi

    shift

    case "$matching_opt" in
      cd)
        local device="$1"

        if [ -z "$device" ]; then
          device="this"
        fi

        # if [ -z "$1" ]; then
        #   AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices
        #   if [ $? -eq 0 ] && [ -d "this/def" ]; then
        #     cd "this/def"
        #   fi
        # else

        AWESOME_SILENCE=true awesome_cd ~/.dmt/user/devices "$device"

        if [ $? -eq 0 ]; then
          if [ -d "def" ]; then
            cd "def"
          else
            printf "${GRAY}Moved to ${CYAN}${device}${GRAY} device directory but ${YELLOW}def ${GRAY}subdirectory is not present, please create it ...${NC}\n"
          fi
        else
          printf "${RED}not found${NC}\n"
        fi

        ;;

      edit)
        local dir="${DMT_USER_PATH}/devices/this"
        if [ -d "$dir" ]; then
          local file="${dir}/def/device.def"
          if [ -f "$file" ]; then
            nano "$file"
          else
            echo $file
            printf "${RED}device.def file not found${NC}\n"
          fi
        else
          printf "${RED}Device is unknown${GRAY}, please select the definition file by using ${GREEN}dev select${GRAY}, then try again.${NC}\n"
        fi
        ;;

      list)
        for_all_devices "list"
        ;;

      ping)
        for_all_devices
        ;;
    esac
  fi
}

function dmt_state {

  if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt state${NC} ${GRAY}show program state${NC}\n"
    printf "${GREEN}dmt state [store]${NC} ${GRAY}show a specific store state (device, player etc.)${NC}\n"
    printf "${GREEN}dmt state [store].[key]${NC} ${GRAY}ex.: player.playlist, device.deviceKey${NC}\n"
    printf "${GREEN}dmt state purge${NC} ${GRAY}delete program state${NC}\n"
    return
  fi

  local DMT_STATE_FILE="$DMT_PATH/state/program.json"

  if [ -f "$DMT_STATE_FILE" ]; then
    if [ "$1" == "purge" ]; then
      if [ -f "$DMT_STATE_FILE" ]; then
        #dmt stop
        rm "$DMT_STATE_FILE"
        printf "${GREEN}purged dmt state${NC}\n"
        #dmt start
      fi
    else
      if [ -n "$1" ]; then
        cat "${DMT_STATE_FILE}" | jq ".$1"
      else
        cat "${DMT_STATE_FILE}" #| jq
      fi
    fi
  else
    printf "${YELLOW}dmt state not found on storage media${NC}\n"
  fi
}

function gui_build_all {
  local cwd="`pwd`"

  local base_dir="$DMT_PATH/core/node/gui/gui-frontend-core"

  cd "$base_dir"

  for component in *; do
    if [ -d "$component" ] && [ "$component" != "common_assets" ]; then
      cd $component
      if [ -f "package.json" ]; then
        npm run build
      else
        printf "${GREEN}Gui component ${YELLOW}${component}${NC} ${GREEN}not buildable in isolation, it was probably (hopefuly) included from some other components...${NC}\n"
      fi
    fi
    cd "$base_dir"
  done

  cd "$cwd"
}

function gui_send_action_to_frontend {
  local cliGUI="$DMT_PATH/core/node/gui/cli/gui.js"
  local action="$1"
  local payload
  if [ -n "$2" ]; then
    #action="${action}:${2}"
    payload="$2"
  fi
  $DMT_NODEJS_EXEC "${cliGUI}" "$action" "$payload"
}

function dmt_gui {
  local dir="$DMT_PATH/core/node/gui/gui-frontend-core"
  local backendDir="$DMT_PATH/core/node/gui/gui-backend"

  # extract host from @ symbol but replace @all with the name of current network !
  local hosts=""

  local args
  IFS=' ' read -r -a args <<< "$@"

  for arg in "${args[@]}"
  do
    if [ "$arg" == "@all" ]; then
      local network_id=''
      get_current_network network_id
      if [ -n "$network_id" ]; then
        hosts="${hosts} @@$network_id"
        shift
      fi
    elif [[ "$arg" == @* ]] && [[ ! "$arg" =~ = ]]; then # @attr=val should not be treated as hostnames
      hosts="${hosts} ${arg}"
      shift
    fi
  done

  hosts=$(echo "$hosts" | xargs) # remove trailing whitespace

  local option="$1"

  if [ -z "$option" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}dmt gui test${NC} ${GRAY}display a test notification on the gui${NC}\n"
    printf "${GREEN}dmt gui @deviceName test${NC} ${GRAY}display a test notification on remote gui${NC}\n"
    #printf "${GREEN}dmt gui cd [view]${NC} ${GRAY}${NC}\n"
    # printf "${GREEN}dmt_gui run${NC} ${GRAY}${NC}\n"
    # printf "${GREEN}dmt_gui build${NC} ${GRAY}build all GUIs${NC}\n"
    # printf "${GREEN}dmt_gui build [gui]${NC} ${GRAY}${NC}\n"
    printf "${GREEN}dmt gui load [view]${NC} ${GRAY}loads the specified gui view (home, player, debug etc.)${NC}\n"
    printf "${GREEN}dmt gui reload${NC} ${GRAY}send request to frontend via websocket requesting reload of current url${NC}\n"
    printf "${GREEN}dmt gui reload [view]${NC} ${GRAY}reloads to the specified gui view (home, player, debug etc.)${NC}\n"
    printf "${GREEN}dmt gui switch [ip]${NC} ${GRAY}switches gui to specified IP (todo: use deviceName instead of ip)${NC}\n"
    # printf "${GREEN}dmt_gui debug${NC} ${GRAY}shows debugging info for current gui issues troubleshooting${NC}\n"
    return
  fi

  shift

  case "$option" in
    test)
      if [ -n "$hosts" ]; then
        $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" gui_test "$@"
      else
        $DMT_NODEJS_EXEC "$DMT_CLI" gui_test "$@"
      fi
      ;;
    cd)
      awesome_cd "$dir" "$1"
      if [ $? -eq 0 ] && [ -d "src" ]; then
        cd "src"
      fi
      ;;

    load)
      local view="$1"
      gui_send_action_to_frontend "load" "$view"
      ;;

    reload)
      local view="$1"
      gui_send_action_to_frontend "reload" "$view"
      ;;

    switch)
      local ip="$1"
      gui_send_action_to_frontend "switch" "$ip"
      ;;

    run)
      dmt_symlink_nodejs_deps # does not have an influence - this builds dmt apps, not dmt core.. will fix later
      local cwd="`pwd`"
      cd "$dir/app"
      npm run dev
      cd "$cwd"

      # if [ -z "$1" ]; then
      #   gui run app
      # elif [ "$1" == "." ]; then
      #   npm run dev
      # else
      #   awesome_cd "$dir" "$1"
      #   if [ $? -eq 0 ]; then
      #     npm run dev
      #   fi
      # fi
      ;;

    build)
      dmt_symlink_nodejs_deps # does not have an influence - this builds dmt apps, not dmt core.. will fix later
      local cwd="`pwd`"
      cd "$dir/app"
      npm run build
      cd "$cwd"

      # if [ -z "$1" ]; then
      #   dmt_gui build app
      #   cd "$cwd"
      #   return
      # fi

      # awesome_cd "$dir" "$1"
      # if [ $? -eq 0 ]; then
      #   npm run build
      # fi


      ;;

    debug)
      echo "TODO"
      ;;

    *)
      awesome_cd "$dir" "$option"
      ;;
  esac
}

function dmt_log {
  #local foreground=false

  # if [ "$1" == "-h" ]; then
  #   printf "${YELLOW}Usage:${NC}\n"
  #   printf "${GREEN}dmt log${NC} ${GRAY}get last 10 log lines on this machine${NC}\n"
  #   printf "${GREEN}dmt @host log${NC} ${GRAY}get last 10 log lines for remote machine${NC}\n"
  #   printf "${GREEN}dmt logfg${NC} ${GRAY}local log in foreground (updates are visible as they come)${NC}\n"
  #   return
  # fi

  local logfile="$DMT_PATH/log/dmt.log"

  if [ "$1" == "full" ]; then
    cat "$logfile"
  else
    # ISSUE: 1) dmt logfg 2) COMMAND+K (clear screen) 3) update device.. 4) PROBLEM: even older log messages will be shown
    tail -f -n ${TAIL_LOG_LINES} "$logfile"
  fi
  # elif [ "$1" == "lan" ]; then
  #   printf "${MAGENTA}Not yet implemented ...${NC}\n"
  #   printf "${CYAN}Expect it in the next minor release of ${MAGENTA}dmt-system${NC}.${NC}\n"
  # else
  #   if [ -n "$hosts" ]; then
  #     $DMT_NODEJS_EXEC "$DMT_CLI" "${hosts}" log "$@"
  #   else
  #     $DMT_NODEJS_EXEC "$DMT_CLI" log "$@"
  #   fi
  # fi
}

function dmt_help {
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt help ${GRAY}shows this help screen${NC}\n"
  #printf "${GREEN}dmt docs ${MAGENTA}shows documentation in a browser${NC}\n"
  #printf "  ${CYAN}â– ${NC} ${GREEN}${UNDERLINE}dmt version${RESET} ${GRAY}Â· shows dmt version â€” v$(cat "$DMT_PATH/.version")${NC}\n"
  #printf "  ${CYAN}â– ${NC} ${GREEN}${UNDERLINE}dmt device${RESET} ${GRAY} Â· device configuration and information${NC}\n"

  echo
  # printf "${YELLOW}Deactivation:${NC}\n"
  # echo
  # printf "  ${CYAN}â– ${NC} ${GREEN}dmt deactivate ${GRAY} Â· deactivates shell but keep it present (to get it back just do ${CYAN}./install${GRAY} Â· )${NC}\n"
  # echo
  printf "${CYAN}ðŸ’¡ DMT Process${NC} ${WHITE}management:${NC}\n"
  # printf "${CYAN}â–  services will not persist after reboot â€” ${MAGENTA}use the docs${CYAN} to easily configure this.${NC}"
  echo
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt start ${GRAY}starts the daemonized process ${CYAN}(dmt-proc)${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt stop ${GRAY}stops the process${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt restart ${GRAY}restarts the process${NC}\n"
  echo
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt run ${GRAY}runs dmt-proc visible in terminal foreground (mostly used for debugging)${NC}\n"
  echo
  # printf "  ${CYAN}â– ${NC} ${CYAN}dmt log ${GRAY}shows a few recent log entries (${CYAN}dmt-proc${GRAY} has to be running) ${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt log ${GRAY}shows realtime log, to quit press ${UNDERLINE}ctrl+c${RESET}${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt log full ${GRAY}dumps the entire log to screen and doesn't wait for realtime output (another difference is that ${NC}dmt log ${GRAY}shows only the recent ${TAIL_LOG_LINES} entries)${NC}\n"
  #printf "  ${CYAN}â– ${NC} ${GREEN}dmt loglan ${GRAY}starts listening to network log message broadcasts${NC}\n"

  echo
  printf "ðŸ‘¯ ${YELLOW}Code replication:${NC}\n"
  echo
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt next ${GRAY}gets the latest ${CYAN}dmt-proc${NC} ${GRAY}version from your source${NC}\n"
  #printf "  ${GREEN}â– ${NC} ${GREEN}dmt next --dry ${GRAY}show what would ${WHITE}dmt next${GRAY} command do${NC}\n"
  echo
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt update [deviceName | ip_address] ${GRAY}clones ~/.dmt directory to another machine via SSH and restarts the process after update${NC}\n"
  printf "  ${CYAN}â– ${NC} ${GREEN}dmt copy [deviceName | ip_address] ${GRAY}same as above but without process restart (only in-browser GUI is reloaded) ${NC}\n"
  echo
  printf "  If you want to do the reverse with the same effect,\n  you can fetch from machine with no dmt-proc currently installed:\n"
  echo
  printf "  ${CYAN}â– ${NC} ${CYAN}curl ${GRAY}[IP]${CYAN}:1111 | bash ${NC}\n"
  echo
  printf "  This replicates ${UNDERLINE}~/.dmt-proc${RESET} ${NC}from the remote machine where ${CYAN}dmt-proc${NC} is running to your machine.${NC}\n"

  echo
  # printf "âš ï¸  â‰¡ ${YELLOW}Not yet implemented${NC}\n"
  # echo
  printf "${MAGENTA}Search and Multimedia${NC}\n"
  echo
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt search ${GRAY}various methods for cli search\n"
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt media ${GRAY}various methods for cli media player manipulation\n"
  echo
  printf "${MAGENTA}GUI and State${NC}\n"
  echo
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt gui ${GRAY}various methods related to ${UNDERLINE}dmt-gui${RESET}\n"
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt state ${GRAY}shows dmt-proc ${UNDERLINE}in-memory program state${RESET} ${GRAY}(part of this is saved to ${UNDERLINE}program.json${RESET} ${GRAY}file)${NC}\n"
  echo
  printf "${MAGENTA}DMT Connectome${NC}\n"
  echo
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt nearby ${GRAY}shows nearby devices ${NC}\n"
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt connections ${GRAY}shows dmt-proc ${UNDERLINE}incoming${RESET} ${GRAY}and ${UNDERLINE}outgoing connections${RESET}${NC}\n"
  printf "  ${CYAN}â– ${NC} ${CYAN}dmt reach${NC} ${GRAY}[todo]${NC}\n"
}

function dmt_help_explain_rpc {
  echo
  return

  echo
  printf "${GRAY}_____________________________________________________________________________${NC}\n"
  echo
  printf "How to refer to other ${CYAN}dmt-proc${NC} instances on local network? ${YELLOW}Use ${MAGENTA}the @ symbol${NC} â†’${NC}\n"
  echo
  printf "  ${MAGENTA}â– ${NC} ${GREEN}dmt ${MAGENTA}@deviceName${GREEN} [log|services|etc.] ${GRAY}gets information about a device on local network${NC}\n"
  printf "  ${MAGENTA}â– ${NC} ${GREEN}dmt ${MAGENTA}@ip_address${GREEN} [log|services|etc.] ${GRAY}same as above but directly with ip address instead of deviceName from device.def${NC}\n"
  printf "  while ${GREEN}dmt [log|services|etc.] ${GRAY}gets information about current device as usual${NC}\n"
  # printf "${GREEN}dmt @@remoteIpOrHost info ${GRAY}gets information about remote device on the other side of router WAN port${NC}\n"
  echo
  printf "  All methods in ${CYAN}cyan${NC} work in this way where an optional ${MAGENTA}@${NC} symbol\n"
  printf "  can be used to refer to other device on local area network.\n"
  echo
}

function dmt_version {
  printf "${MAGENTA}v$(cat "$DMT_PATH/.version")${NC}\n\n"
  local NUM=$(cat $HOME/.dmt/etc/.bash_aliases_bundle | grep function | wc -l | xargs)
  printf "${WHITE}${NUM} bash functions\n"
}

function get_dmt_source_from_user_def {
  local __dmt_source=''

  if [ -f "$DMT_USER_DEF_FILE" ]; then
    dmt_def_reader __dmt_source "$DMT_USER_DEF_FILE" "dmtSource"
  fi

  eval "$1='$__dmt_source'"

  # return

  # local _gatewayMac=''
  # get_gateway_mac _gatewayMac

  # if [ "$_gatewayMac" == "$LOCAL_DMT_SOURCE_MAC" ]; then
  #   eval "$1='local'"
  # else
  #   eval "$1='global'"
  # fi
}

function stop_dmt_if_running {
  local dmt_proc_pid=''
  local dmt_fg_bg=''
  get_dmt_proc_pid dmt_proc_pid dmt_fg_bg

  if [ -n "$dmt_proc_pid" ]; then
    dmt stop
  fi
}

function dmt_nearby {
  $DMT_NODEJS_EXEC "$CLI_DIR/nearby.js" "$@"

  if [ "$1" == "update" ] || [ "$1" == "copy" ]; then
    local action="$1"

    shift

    local devices=()
    while read device
    do
      devices+=( "$device" )
    done < <( $DMT_NODEJS_EXEC "$CLI_DIR/nearby.js" --simple "$@" )

    #while read device
    for device in "${devices[@]}"; do
      echo

      local deviceInfo=(${device//;/ })
      local deviceName="${deviceInfo[0]}"
      local ipWithUser="${deviceInfo[1]}"

      printf "Updating device ${MAGENTA}${deviceName}${NC} ...\n"

      # todo: paralellize with screen as in update_all
      dmt "$action" "$ipWithUser" # dmt update | dmt copy
    done
    # this was not working anymore since we added ssh .. ~/.dmt/etc/scripts/dmt_via_git .. check in ./install
    # for some reason ... if we create array first then iterate over it, then it works in all cases !
    # done < <($DMT_NODEJS_EXEC "$CLI_DIR/nearby.js" --simple "$@")
  else
    echo
    printf "ðŸ’¡ ${MAGENTA}Update all nearby devices:${NC}\n"
    echo
    printf "${CYAN}â– ${NC} ${GREEN}dmt nearby update ${GRAY}Â· update all nearby devices (copy + restart ${UNDERLINE}dmt-proc${RESET}${GRAY})${NC}\n"
    echo
    #printf "${CYAN}â– ${NC} ${GRAY}dmt nearby copy ${GRAY}Â· copy ~/.dmt to all nearby devices without restarting ${UNDERLINE}dmt-proc${RESET} ${GRAY}on each device${NC}\n"
  fi
}

function dmt_next {
  # option 1: specify from where to fetch via an argument:
  # dmt next [dmtSource]
  # or from user.def ->
  # user:
  #  dmtSource: [dmtSource]

  local dry_run=false
  local save_zip=false
  local reflect_version=false

  ARGS=()
  while (( "$#" )); do
    case "$1" in
      --dry)
        dry_run=true
        shift 1
        ;;
      --save-dmt-zip)
        save_zip=true
        shift 1
        ;;
      --help)
        dmt_next_help
        return
        ;;
      -h)
        dmt_next_help
        return
        ;;
      --) # end argument parsing
        shift
        break
        ;;
      -*|--*=) # unsupported flags
        printf "${RED}Error: Unsupported flag ${YELLOW}$1${NC}\n"
        #echo ""
        return
        ;;
      *) # preserve positional arguments
        ARGS+=($1)
        shift
        ;;
    esac
  done

  # dmt next --dry
  # dmt next --dry url.com
  # if [ "$1" == "--dry" ]; then
  #   dry_run=true
  #   shift
  # fi

  # # dmt next url.com --dry
  # if [ "$2" == "--dry" ]; then
  #   dry_run=true
  # fi

  # 1) dmtSource from argument
  local arg=${ARGS[0]}

  # if [ "$arg" == "--help" ] || [  "$arg" == "-h" ]; then
  #   #dmt_next_help
  #   return
  # else
  #   printf "${GRAY}To read help for this command use: ${GREEN}dmt next -h${NC}\n"
  # fi

  # 2) dmtSource from user.def
  local dmt_source="$arg"

  if [ -n "$dmt_source" ]; then
    if $dry_run; then
      printf "${CYAN}1)${NC} ${MAGENTA}dmtSource${NC} provided as argument: ${MAGENTA}${dmt_source}${NC}\n"
    fi
  else
    if $dry_run; then
      printf "${CYAN}1)${NC} ${MAGENTA}dmtSource ${GRAY}not provided as argument to this command ${NC}...\n"
      printf "${CYAN}2)${NC} ${GRAY}Checking ~/.dmt/user/def/user.def for ${MAGENTA}dmtSource ${NC} ...\n"
    fi

    get_dmt_source_from_user_def dmt_source

    if [ -n "$dmt_source" ] && $dry_run; then
      printf "   ${GREEN}â—â—â— found it!${NC}\n"
    fi
  fi

  # aborting if couldn't determine dmtSource

  if [ -z "$dmt_source" ]; then
    if $dry_run; then echo; fi
    printf "${GRAY}Could not determine ${MAGENTA}dmtSource ${GRAY}... ${NC}"

    if [ -d "$DMT_PATH/.git" ]; then

      local cwd2="`pwd`"
      cd "$DMT_PATH"

      if $dry_run; then
        printf "${GRAY}Would fetch from the github origin:${NC}\n"
        #git remote show -n origin
        git remote get-url origin
      else
        local gitsource=`git remote get-url origin`

        if [[ "$gitsource" =~ uniqpath/dmt ]]; then
          echo
          printf "${GREEN}Found git origin âœ“\n"
          printf "${GRAY}Updating from ${CYAN}${gitsource} ${GRAY}...${NC}\n"

          git fetch origin
          git checkout master
          git reset --hard origin/master
          # yet to decide ... we do this with automatic updates on server but (for now) we don't clean everything on manual updates..
          # git clean -f -d
          # maybe do it in the future if it's concluded that some manual files can interfere

          printf "${GREEN}âœ“âœ“ Done fetching latest version via git.${NC}\n\n"
          printf "${CYAN}Please run ${GREEN}dmt restart${NC} ${CYAN}now${NC} ...\n\n"
          printf "Sometimes it is recommended to ${YELLOW}reload the terminal${NC} as well â†’ "
          printf "try ${GREEN}dmt reload${NC} command or logout and back in.\n"
        else
          printf "${RED}Aborting fetch from unknown git source.${NC}"
        fi
      fi
    else
      if ! $dry_run; then printf "${RED}aborting.${NC}"; fi
      echo
    fi

    cd "$cwd2"
    return
  fi

  printf "${MAGENTA}dmtSource: ${CYAN}${dmt_source}${NC}\n"
  echo

  # dry run
  if $dry_run; then
    echo
    printf "${GREEN}dmt next${NC} ${YELLOW}command would fetch the code from â†’ ${MAGENTA}${dmt_source}${NC}\n"
    return
  fi

  # FETCHING ONLY ------------

  if $save_zip; then
    local dir=~/.dmt/state

    if [ -d "$dir" ]; then
      local cwd="`pwd`"
      cd "$dir"

      local fetched_file="dmt_in_progress.zip"

      if [ -f $fetched_file ]; then
        printf "${YELLOW}REMOVING FIRST${NC}\n"
        rm $fetched_file
      fi

      printf "${GREEN}Fetching ${MAGENTA}dmt.zip${NC} from ${CYAN}${dmt_source}${NC} â†’ ${YELLOW}${dir}${NC} ... ${NC}\n"

      if curl -L --fail "${dmt_source}/dmt.zip" -o $fetched_file; then
        mv $fetched_file dmt.zip
        echo
        printf "${GREEN}âœ“ Fetched file ${YELLOW}${dir}/dmt.zip${NC}\n"
        printf "${GRAY}It will be served on ${dmt_source}/dmt.zip requests as long as it stays in this folder${NC}\n"
        printf "${GRAY}instead of process self-replication via streaming archiver.${NC}\n"
        echo
        printf "${GRAY}Saving corresponding version number of dmt.zip contents...${NC}\n"
        # a bit of duplication
        local remoteVersion=$(curl "$dmt_source"/version 2>/dev/null)

        if [[ "$remoteVersion" =~ "Â·" ]]; then # 1.1.2 Â· 2020-05-03
          echo "$remoteVersion" > dmt.zip.version.txt
        else
          printf "âš ï¸  ${YELLOW}Failed to fetch remote version ...${NC}\n"
        fi
      else
        echo
        printf "${RED}Failed to fetch ${YELLOW}${dir}/dmt.zip ${RED}âœ–${NC}\n"
      fi

      cd "$cwd"
    else
      printf "${RED}${dir} directory does not exist, aborting.${NC}\n"
    fi

    # end of fetch option
    return
  fi

  # Safeguard
  if [ -f ~/.dmt/.prevent_dmt_next ]; then
    printf "${RED}Prevented operation because ~/.dmt/.prevent_dmt_next file is present, please remove it to continue${NC}\n"
    return
  fi

  # ---------------------------

  if [[ "$dmt_source" =~ get-dmt.com$ ]]; then # get-dmt.com || alpha.get-dmt.com || ...

    # a bit of duplication
    local remoteVersion=$(curl http://${dmt_source}/version 2>/dev/null)

    if [[ ! "$remoteVersion" =~ "Â·" ]]; then # 1.1.2 Â· 2020-05-03
      printf "âš ï¸  ${MAGENTA}${dmt_source}${NC} ${RED}is currently not accessible...\n"
      printf "${YELLOW}Please try again later.${NC}\n"
      return
    fi

    local localVersion=$(cat ~/.dmt/.version)

    if [ "$localVersion" == "$remoteVersion" ]; then
      printf "${CYAN}Your version ${MAGENTA}${localVersion}${NC} ${CYAN}is current!${NC}\n"
      echo
      printf "${GREEN}No need to update ðŸ˜Š${NC}\n"
      return
    fi

    printf "Current version : ${GRAY}${localVersion}${NC}\n"
    printf "${MAGENTA}Next version${NC}    : ${MAGENTA}${remoteVersion}${NC}\n"

    echo

    printf "${YELLOW}Do you want to update?${NC} â€¦\n"
    read -r -p "[Y/n] " response
    if [[ $response =~ ^([nN])$ ]]
    then
      printf "${RED}Aborting ...${NC}\n"
      return
    fi

  fi

  # ------------

  stop_dmt_if_running

  local cwd="`pwd`"

  #printf "${MAGENTA}dmtSource${NC} = ${CYAN}${dmt_source}${NC}\n"

  curl -L "${dmt_source}" | bash

  # ~/.dmt directory will get replaced under us ...
  # we move to it again ....
  cd "$cwd"

  mkdir -p ~/.dmt/state
  touch ~/.dmt/state/gui_reload.txt

  dmt start

  printf "${GREEN}Done.${NC}\n"
  echo
}

function dmt_next_help {
  printf "${YELLOW}Usage:${NC}\n"
  printf "${GREEN}dmt next ${GRAY}read ${MAGENTA}dmtSource ${GRAY}from user.def, dmtSource is just an url from where to fetch the entire ${CYAN}dmt-proc ${GRAY}code${NC}\n"
  printf "${GREEN}dmt next [dmtSource] ${GRAY}specify manually (has precedence over user.def, careful!)${NC}\n"

  printf "${GREEN}dmt next --dry ${GRAY}does not do anything except showing you what would be the determined ${MAGENTA}dmtSource ${GRAY}value${NC}\n"

  # echo
  # printf "${MAGENTA}Supported formats for ${CYAN}dmtSource${NC}:\n"

  # printf "Regular url: ${CYAN}dmt-system.com/urlpath${NC} (attaches /getdmt to the end if urlpath is missing - example: just 'dmt-system.com' becomes 'dmt-system.com/getdmt')\n"
  # printf "${YELLOW}this options gets the bash script from the endpoint and executes it${NC}\n"

  # printf "Github url: ${CYAN}github.com/uniqpath/dmt${NC}\n"

  # printf "Local network: ${CYAN}192.168.0.50${NC} (attaches :1111 port if there is no port specified - example: just '192.168.0.70' becomes '192.168.0.70:1111')\n"
  # printf "Regular url or ip apart from 192.168.* with port specified: ${CYAN}somedomain.com:2222${NC}\n"

  # OPTION A -  dmt next dmt-system.com
  # dmt next github.com/uniqpath/dmt
  # OPTION C - local network - dmt next 192.168.0.50
  # OPTION C2 - local network with port included - dmt next 192.168.0.50:1111
  # OPTION D - regular url with port included: dmt next dmt-system.com:1111
}

function dmt_update {
  # dmt update nearby == dmt nearby update
  if [ "$1" == "nearby" ]; then
    dmt nearby update
    return
  fi

  dmt_copy --restart "$@"
}

function dmt_copy {
  # dmt copy nearby == dmt nearby copy
  if [ "$1" == "nearby" ]; then
    dmt nearby copy
    return
  fi

  dmt_symlink_nodejs_deps

  if [ -z "$1" ]; then
    if dev_machine; then
      printf "${RED}Prevented on dev machine${NC}\n"
    fi
  else
    compile_gui_if_missing

    local cwd="`pwd`"
    cd "$DMT_PATH"
    . ./install "$@" # calling with . preserves the newly loaded env
    cd "$cwd"
  fi
}

function dmt_deactivate {
  if dev_machine; then
    printf "${RED}Prevented on dev machine${NC}\n"
    return
  fi

  local backup_file="$LOGNAME_HOME/.bash_aliases-backup-by-dmt"

  if [ -L "$LOGNAME_HOME/.bash_aliases" ] && [ "$(head -3 $LOGNAME_HOME/.bash_aliases | tail -1)" == "# DMT ALIASES" ]; then
    rm ~/.bash_aliases

    if [ -f "$backup_file" ]; then
      mv "$backup_file" ~/.bash_aliases
    fi

    printf "${MAGENTA}dmt${NC} ${CYAN}was unlinked${NC}, only the folder ${CYAN}~/.dmt${NC} remains and is not active in any way.\n"
    echo
    printf "${CYAN}To reinstall${NC}\n"
    printf "${GREEN}cd $LOGNAME_HOME/.dmt${NC}\n"
    printf "${GREEN}./install${NC}\n"
    echo
    printf "${CYAN}To remove the unused directory${NC}\n"
    printf "${GREEN}rm -rf $LOGNAME_HOME/.dmt${NC}\n"
    echo
    printf "${WHITE}If you want to confirm that dmt is uninstalled you have to first reload the shell.${NC}\n"
  else
    printf "${RED}dmt is not installed${NC}\n"
  fi
}

function dmt_cd {
  cd "$DMT_PATH"
}

function dmt_bin {
  declare -a opts=(
    "compile"
    "download"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "${opts[@]}"
    return
  fi

  local matching_opt=''
  dmt_opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "Use -h to see valid options\n\n"
    #matching_opt="aaa" # default
    return
  fi

  shift

  case "$matching_opt" in
    compile)
      if [ -d $DMT_RUST_CORE ]; then
        dmt_compile_bin
      else
        echo "rust core doesn't exists"
      fi
      ;;

    download)
      ;;
  esac
}

function dmt_compile_bin {
  local cwd="`pwd`"

  # todo: ... + generalize the process somehow....

  printf "${MAGENTA}$DMT_RUST_CORE/walkdir${NC}\n"
  if [ -d "$DMT_RUST_CORE/walkdir" ]; then
    cd "$DMT_RUST_CORE/walkdir"
    cargo build --release --example walkdir
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/examples/walkdir "${DMT_PLATFORM_BIN}/walkdir" >/dev/null 2>&1; then
        printf "${GREEN}âœ“ Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/examples/walkdir "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}âœ“ Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  echo

  printf "${MAGENTA}$DMT_RUST_CORE/walksearch${NC}\n"
  if [ -d "$DMT_RUST_CORE/walksearch" ]; then
    cd "$DMT_RUST_CORE/walksearch"
    cargo build --release
    if [ "$?" -eq 0 ]; then
      mkdir -p "${DMT_PLATFORM_BIN}"
      # https://stackoverflow.com/questions/8139885/shellscript-action-if-two-files-are-different
      if ! cmp target/release/walksearch "${DMT_PLATFORM_BIN}/walksearch" >/dev/null 2>&1; then
        printf "${GREEN}âœ“ Build successful, copying executable to ${DMT_PLATFORM_BIN}${NC}\n"
        cp target/release/walksearch "${DMT_PLATFORM_BIN}"
      else
        printf "${CYAN}âœ“ Build successful but executable in ${DMT_PLATFORM_BIN} is already the newest version${NC}\n"
      fi
    fi
  fi

  cd "$cwd"
}
