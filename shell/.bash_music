#!/bin/bash

function pl {
  play "$@"
}

function play {

  local audio_cmd="mpv --no-video --volume 60"

  # AUDIO
  if [ -z "$1" ] || [ "$1" == "mp3" ] || [ "$1" == "flac" ] || [ "$1" == "ogg" ]; then
    local ext="$1"

    if [ -z "$ext" ]; then
      local count=`ls -1 *.flac 2>/dev/null | wc -l`
      if [ $count -eq 0 ]; then
        count=`ls -1 *.ogg 2>/dev/null | wc -l`
        if [ $count -eq 0 ]; then
          ext="mp3"
        else
          ext="ogg"
        fi
      else
        ext="flac"
      fi
    fi

    eval "$audio_cmd *.$ext"
    return
  fi

  # MOSTLY VIDEO

  local matching_file=''
  get_matching_file matching_file "$1"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ -f "$matching_file" ]; then
    if [[ "$matching_file" =~ (mkv|avi|mp4|webm)$ ]]; then
      printf "${YELLOW}$matching_file${NC}\n"
      if is_rpi; then
        omxplayer --aspect-mode stretch -o alsa:hw:0,0 "$matching_file"
        #omxplayer --aspect-mode stretch -o alsa:hw:1,0 "$matching_file"
      else
        DISPLAY=:0 mpv --fullscreen "$matching_file"
      fi
    elif [[ "$matching_file" =~ (mp3|flac|ogg)$ ]]; then # ADUIO
      printf "${YELLOW}$matching_file${NC}\n"
      eval "$audio_cmd \"$matching_file\""
    fi
  else
    printf "${RED}No matching file${NC}\n"
    # if [[ "$1" =~ youtube ]]; then
    #   DISPLAY=:0 mpv --fullscreen "$1"
    # else
    #   DISPLAY=:0 mpv --fullscreen "https://www.youtube.com/watch?v=$1"
    # fi
  fi
}

function soundtest {
  if [ "$1" == "mp3" ]; then
    which mpv > /dev/null 2>&1

    if [ $? -eq 0 ]; then
      printf "${GREEN}Playing...${NC}\n"
    else
      printf "${MAGENTA}mpv is missing, installing...${NC}\n"
      sudo apt-get update
      sudo apt-get -y install mpv
      printf "\n${GREEN}Playing...${NC}\n"
    fi

    mpv --no-video "$DMT_PATH/etc/soundtest/soundtest.mp3"
  else
    aplay "$DMT_PATH/etc/soundtest/soundtest.wav"
  fi
}

# -------------------------------

function m {
  declare -a opts=(
    "search"
    "play"
    "pause"
    "volume"
  )

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "${opts[@]}"
    return
  fi

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "Use -h to see valid options\n\n"
    #matching_opt="aaa" # default
    return
  fi

  shift

  node "$DMT_NODE_CORE/dmt-controller/cli/music.js" "$matching_opt" "$@"
}

function m_old2 {
  if [ -z "$1" ] || [ "$1" == "help" ] || [ "$1" == "version" ]; then
    printf "${MAGENTA}     ∞ DMT MUSIC ∞${NC}\n"
    echo
    # printf "${CYAN}Liberate yourself.${NC}\n"
    # if [ "$1" != "version" ]; then
    #   printf "\n${GRAY}Remember your MS-DOS c:/util directory?\nWell .dmt is not like that.${NC}\n"
    #   printf "\n${GRAY}Don't remember anything? Even better!${NC}\n"
    #   echo
    # fi
  fi

  declare -a opts=(
    "help"
    "add"
    "play"
    "shuffle"
    "pause"
    "vol"
    "list"
    "status"
    "buffer"
    "select"
    "scan"
    "update"
    "only"
    "enable"
    "disable"
    "outputs"
    "calibrate"
    "next"
    "clear"
  )

  local host="localhost"
  local network_id=''

  if [ "$1" == "-h" ]; then
    host="$2"
    shift
    shift
  else
    local device_specified_host

    if [ -f "$DMT_DEVICE_FILE" ]; then
      local value=''
      def_reader value "$DMT_DEVICE_FILE" "mpdPlayer" "host"
      if [ -n "$value" ]; then
        device_specified_host="$value"

        local player_type=''
        def_reader player_type "$DMT_DEVICE_FILE" "mpdPlayer" "type"
      fi
    fi

    if [ "$1" == 'localhost' ]; then
      shift
    elif [ -n "$device_specified_host" ]; then
      printf "${GRAY}mpdPlayer host specified in device.def (=${device_specified_host}), using this...${NC}\n\n"
      host="$device_specified_host"
    else # read from networks.def based on our current location (router gateway mac)
      local host_result=''
      network_def_reader host_result network_id "host"
      if [ -n "$host_result" ]; then
        host="$host_result"

        local player_type=''
        network_def_reader player_type network_id "type"
      fi
    fi
  fi

  local outputsStr=''
  network_def_reader outputsStr network_id "outputs"
  IFS=', ' read -r -a outputs <<< "$outputsStr"

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    printf "${YELLOW}Use ${GREEN}help ${YELLOW}for more options${NC}\n\n"
    matching_opt="status" # default
  fi

  printf "${CYAN}Player at ${YELLOW}${host}:${NC}\n\n"

  shift

  local music_controller="$DMT_NODE_CORE/music-controller/cli"
  if [ ! -d "$music_controller" ]; then
    music_controller=""
  fi

  if [[ "$matching_opt" =~ ^enable|disable|status|outputs$ ]]; then
    local grep_cmd="grep"
    if macos; then
      grep_cmd="ggrep"
    fi
  fi

  # find matching songs
  if [[ "$matching_opt" =~ ^list|play|shuf|add$ ]]; then
    # get a list of all songs
    IFS=$'\n'
    local SONGS=( $(mpc -h $host listall | sort) )
    unset IFS

    local CATALOG_FILE="/tmp/catalog_${host}.txt"
    for song in "${SONGS[@]}"
    do
      :
      echo "$song" >> "$CATALOG_FILE"
    done

    # convert function arguments into array
    local terms
    IFS=' ' read -r -a terms <<< "$@"

    # iterate over each search term and filter the array each time, throwing away rows that don't match the current term
    shopt -s nocasematch # case insensitive regex
    for term in "${terms[@]}"
    do
      :
      # this is how to filter an array based on a condition
      # source: https://stackoverflow.com/a/40375567/458177
      for index in "${!SONGS[@]}" ; do [[ ! ${SONGS[$index]} =~ $term ]] && unset -v 'SONGS[$index]' ; done
      SONGS=("${SONGS[@]}")
    done
    shopt -u nocasematch

    local SONGS_FILE="$(mktemp)"
    #local SONGS_FILE="/tmp/catalog_${host}.txt"

    for song in "${SONGS[@]}"
    do
      :
      echo "$song" >> "$SONGS_FILE"
    done
  fi

  case "$matching_opt" in
    help)
      m_help
      printf "${GREEN}${opts[@]}${NC}\n"
      ;;

    status) # DEFAULT !
      mpc -h $host
      echo

      if [ -n "$music_controller" ] && [ "$player_type" == "forked-daapd" ]; then
        node "$music_controller/volume.js" --host "$host"
      else
        mpc -h $host outputs | $grep_cmd -z enabled --color
      fi
      ;;

    list) # warning update $opts upon change
      if [ -z "$1" ]; then
        mpc -h $host listall | sort
      else
        # previous simple version which only works with a single search term:
        #mpc -h $host listall | sort | grep -i "$@" --color

        # show results
        for song in "${SONGS[@]}"
        do
          :
          echo "$song"
          #printf "${YELLOW}${song}${NC}\n"
        done
      fi
      ;;

    play) # warning update $opts upon change
      if [ -z "$1" ]; then
        mpc -h $host play
      else
        mpc -h $host clear > /dev/null 2>&1
        cat "$SONGS_FILE" | mpc -h $host add
        mpc -h $host play
      fi
      ;;

    add)
      if [ -z "$1" ]; then
        printf "${RED}Missing parameter${NC}\n"
      else
        cat "$SONGS_FILE" | mpc -h $host add
        #mpc -h $host listall | sort | grep -i "$@" | mpc -h $host add
      fi
      ;;

    shuffle) # warning update $opts upon change
      if [ -z "$1" ]; then
        #mpc -h $host play
        echo "todo"
      else
        local shuf_cmd="shuf"
        if macos; then
          shuf_cmd="gshuf"
        fi

        mpc -h $host clear > /dev/null 2>&1
        cat "$SONGS_FILE" | $shuf_cmd | mpc -h $host add
        mpc -h $host play
        # mpc -h $host listall | grep -i "$@" | $shuf_cmd | mpc -h $host add
      fi
      ;;

    pause) # warning update $opts upon change
      mpc -h $host pause
      ;;

    next)
      mpc -h $host next
      ;;

    clear)
      mpc -h $host clear
      ;;

    vol) # warning update $opts upon change
      if [ -z "$1" ]; then
        printf "${YELLOW}Main:\n${NC}"
        mpc -h $host vol
        echo
      elif [[ "$1" =~ ^[0-9]+$ ]]; then
        mpc -h $host vol $1
        echo
        shift
      fi

      if [ -n "$music_controller" ] && [ "$player_type" == "forked-daapd" ]; then
        node "$music_controller/volume.js" --host "$host" "$@"
      fi
      ;;

    buffer) # warning update $opts upon change
      mpc -h $host playlist
      ;;

    update) # warning update $opts upon change
      mpc -h $host update
      ;;

    select)
      echo "select"
      ;;

    scan)
      echo "scan"
      ;;

    only)
      if [ -n "$music_controller" ] && [ "$player_type" == "forked-daapd" ]; then
        node "$music_controller/only.js" --host "$host" "$@"
      else
        printf "${RED}Missing music-controller mpd package or player type is wrong${NC}\n"
      fi
      ;;

    enable)
      # if we have opts matching data, we proceed, otherwise we just take the passed argument verbatim (this also happens if we tried to match but didn't succeed)
      local matching_output
      if [ -n "$outputs" ]; then
        matching_output=''
        opts_matcher matching_output "$1" "${outputs[@]}"
      fi
      if [ -z "$matching_output" ]; then
        matching_output="$1"
      fi
      # -------

      # todo: if player-type is forked-daapd, use api....
      mpc -h $host enable $matching_output | $grep_cmd -z "enabled" --color

      if [ -n "$music_controller" ] && [ "$player_type" == "forked-daapd" ]; then
        echo
        node "$music_controller/volume.js" --host "$host"
      #else
      #  mpc -h $host outputs | $grep_cmd -z enabled --color
      fi
      ;;

    disable)
      # if we have opts matching data, we proceed, otherwise we just take the passed argument verbatim (this also happens if we tried to match but didn't succeed)
      local matching_output
      if [ -n "$outputs" ]; then
        matching_output=''
        opts_matcher matching_output "$1" "${outputs[@]}"
      fi
      if [ -z "$matching_output" ]; then
        matching_output="$1"
      fi
      # -------

      # todo: if player-type is forked-daapd, use api....
      mpc -h $host disable $matching_output | $grep_cmd -z enabled --color

      if [ -n "$music_controller" ] && [ "$player_type" == "forked-daapd" ]; then
        echo
        node "$music_controller/volume.js" --host "$host"
      #else
      #  mpc -h $host outputs | $grep_cmd -z enabled --color
      fi
      ;;

    outputs)
      mpc -h $host outputs | $grep_cmd -z "enabled" --color
      ;;

  esac

  if [ -n "$SONGS_FILE" ] && [ -f "$SONGS_FILE" ]; then
    rm "$SONGS_FILE"
  fi
}

function m_old_brisi {

  local host="-h solar.local"
  if [ "$1" == "-h" ]; then
    if [ -z "$2" ]; then
      echo "missing host"
      return
    fi
    host="-h ${2}"
    shift
    shift
  fi

  if [ -z "$1" ]; then
    mpc $host
    echo
    mpc $host outputs
  elif [ "$1" == "play" ] && [ -n "$2" ]; then
    mpc $host clear
    shift
    mpc $host insert "$@"
    mpc $host playlist
    mpc $host play
  elif [ "$1" == "toggle" ] && [ -n "$2" ]; then
    mpc $host toggleoutput "$2"
  else
    mpc $host "$@"
  fi
}

function ml {
  m "localhost" "$@"
}

function ou {
  echo "TODO -- command that takes an output, then what to do on it (for example vol. etc) -- it delegates a lot to m command ..."

  local outputsStr=''
  local network_id=''
  network_def_reader outputsStr network_id "outputs"
  #declare -a outputs
  IFS=', ' read -r -a outputs <<< "$outputsStr"

  if [ -n "$outputs" ]; then
    local matching_output=''
    opts_matcher matching_output "$1" "${outputs[@]}"
    if [ $? -eq 0 ]; then # error
      printf "Matched output: ${GREEN}${matching_output}${NC}\n"
    fi
  fi
  if [ -z "$matching_output" ]; then
    echo "no match in defined outputs"
  fi
  # -------
}

# function vol {
#   m vol "$@"
# }
