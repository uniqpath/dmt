#!/bin/bash

# -- DMT ALIASES --
# SAVES YOU TIME AND MONEY. FREE SOFTWARE.

# INSTALL INSTRUCTIONS FOR Linux / macOS
# (Windows not supported, it has different philosophy)

# TODO: UPDATE!!!!!!!!

# 1.
# put this file into ~/.bash_aliases
# curl -o ~/.bash_aliases https://elm-research.com/projects/bash_aliases.txt
#
# Make the shell load it:
# type:
# sudo nano /etc/profile
#
# add this to the end:
#
# # Alias definitions.
# if [ -f /Users/[your name]/.bash_aliases ]; then
#   . /Users/[your name]/.bash_aliases
# fi
#
# You could also add this to ~/.bash_profile but it's better in /etc/profile because then you will have access to things defined here even when you are root
#
# To update in the future:
# update
#
# You can also check the changelog before each update:
# update_diff

# 2.
# place to put non-shareable stuff: /etc/.bash_aliases_custom

# YOU CAN add your custom aliases or changes here please...
# don't add them in this file for now, rather ask me (the author - davidhq) to update it, this is the only way to keep this file in sync for easy updates

# 3.
# ------------ TEST YOUR SETUP: ---------------
# Open a new terminal tab and type:
# l [enter]
# or
# count [enter]

# You can always terminate commands that are running too long (shouldn't happen often and almost always by your own fault - for example running count on a big folder!)
# with: CTRL+C

# If you make some changes to ~/.bash_aliases_custom, you can type: rel [enter] to reload the environment without closing the tab and opening a new one

# Learn about two useful metacommands for start: "rel" and "al"

# -------------------------------------------------------

# OPTIONAL:
#
# 4. DEPENDENCIES

# Install some other dependencies that some functions use:
# - Install "homebrew" awesome package manager for macOS based on the archaic Ruby language
#
# --- SSHRC
# brew install sshrc
#
# This turbocharges this file even more because now you'll take it with you to whatever linux server you ssh into!
# This file speeds up your command line in both, MacOS and Linux in the same exact way: it smoothes out the differences, vas majority of commands work the same on both
# types of systems.
#
# Step 2 - create symlink to this file:
# cd [this moves to home directory]
# ln -s

# -- coreutils (macOS)
# brew install coreutils
# provides gsort (used in "usage" for example) and other commands
# also provides "gshuf"
#
# --- GNU GREP
# brew install grep (gnu grep: install the command "ggrep")
#
# --- CLOC
# npm install -g cloc (code analysis in addition to "loc" which .dmt provides)
#
# --- ACK
# brew install ack
#
# Create ~/.ackrc with this contents:
#
# --type-add
# ruby=.builder,.feature
# --type-set
# rackup=.ru
# --type-set
# elm=.elm
# --type-set
# livescript=.ls
# --type-set
# haml=.haml
# --type-add
# php=.phtml
# --type-set
# jsx=.jsx
# --type-set
# vue=.vue
# --type-set
# markdown=.markdown,.md,.mdown
# --type-set=cache=.cache
# --ignore-dir=.idea
# --ignore-dir=tmp
# --ignore-dir=photos
# --ignore-dir=node_modules
# --ignore-dir=bower_components
# --ignore-dir=dist
# --ignore-dir=.git
# --ignore-dir=log
# --ignore-dir=Godeps
# --ignore-dir=elm-stuff
# --ignore-dir=deps
# --ignore-dir=build
# --ignore-dir=_build
# --ignore-dir=dist
# --ignore-dir=Deps
# --ignore-dir=vendor
# --nocache
#
# --- HIGHLIGHT: highlight code in terminal (when using "t" command instead of "cat")
# brew install highlight
#
# --- jq: parse .json in terminal
# brew install jq
#
# --- latest version of RSYNC (only needed for macOS Sierra+, linux already has the latest version)
# brew install rsync
# needed because of --protect-args (https://unix.stackexchange.com/a/137285/135062) - used in dirsync function
# if you want to rsync *to* macOS (rsync server is used), make sure to add /usr/local/bin to $PATH in ~/.bashrc so that it's loaded on ssh / rsync
#
# --- TREE: show directory and file structure
# brew install tree
#
# --- COLORDIFF: colors in diffs (example: update_diff command that shows what would be updated with "update")
# brew install colordiff
#
# --- GITSTATS
# Todo: automatic install - detect os, ask for confirmation and install!!!
# command: stats

# 5. SYNCBOX
#
# mkdir ~/Syncbox
# echo "pi@lab.local" > ~/.syncbox
#
# Commands:
# push
# pull

# ----------------======---------------

# + LOAD DMT DEPS

# LOGNAME=$(logname 2>/dev/null)

# # Returns error in two known occasions:
# # 1) after "dmt update [device]" which calls "./install" *via ssh -e*
# # 2) on linux machines when executing "se" (command in background screen)
# if [ $? -ne 0 ]; then # error
#   LOGNAME_HOME="$HOME"
# else
#   if macos; then
#     #LOGNAME_HOME="/Users/$(whoami)"
#     LOGNAME_HOME="$HOME"
#   else
#     LOGNAME_HOME="/home/$(logname)" # MAYBE IMPROVE??
#   fi
# fi

# LOGNAME_HOME="$HOME"
# DMT_PATH="$LOGNAME_HOME/.dmt"

# syncbox="pi@dmt.local"

# if [ -f ~/.syncbox ]; then
#   syncbox=`cat ~/.syncbox`
# fi

# cp with progress and speed of the transfer
alias cpp="rsync -ah --progress"

function compile {
  local cwd="`pwd`"
  cd "$DMT_PATH/shell"
  ./compile
  cd "$cwd"
}

function symlink_if_unlinked {
  local script="$DMT_NODE_CORE/.scripts/symlink_dmt_deps"

  if [ -f "$script" ]; then

    if [ ! -L "$DMT_NODE_CORE/dmt-bridge/node_modules" ]; then
      local cwd="`pwd`"
      cd "$DMT_NODE_CORE/.scripts"
      ./symlink_dmt_deps
      cd "$cwd"
    fi
  fi
}

function compile_gui_if_missing {
  if [ ! -f "$DMT_NODE_CORE/dmt-gui/gui-frontend-core/app/public/bundle.js" ]; then
    gui build
  fi
}

# Reload the environment
function rel {
  if [ -f "$DMT_PATH/shell/compile" ]; then
    compile
  fi

  if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
  fi
  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
  if [ -f ~/.bash_profile ]; then
    . ~/.bash_profile
  fi
}

function loop {
  while true; do "$@"; sleep 2; done
}

function latest {
  local num=5
  if [ -n "$1" ]; then
    num="$1"
  fi

  ls -tp | grep -v /$ | head -"$num"
}

function newscript {
  if [ -n "$1" ]; then
    if [ -f "$1" ]; then
      printf "${RED}File already exists${NC}\n"
    else
      echo "#!/usr/bin/env node" > "$1"
      echo '"use strict"' >> "$1"
      ux "$1"
    fi
  else
    echo "Usage: newscript [file]"
  fi
}

function os {
  cat /etc/os-release
}

# ---------------------------

function srv {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"

    printf "${GREEN}srv [service]${NC} ${GRAY}show status${NC}\n"
    printf "${GREEN}srv [service] [command]${NC} ${GRAY}run command, ex.: start|stop|reload|restart|enable|disable${NC}\n"
    printf "${GREEN}srv [service] cat${NC} ${GRAY}show service specification${NC}\n"
    printf "${GREEN}srv [service] edit${NC} ${GRAY}edit service specification${NC}\n"
    printf "${GREEN}srv [service] log${NC} ${GRAY}see service log${NC}\n"
    echo
    printf "${GREEN}srv ls${NC} ${GRAY}show services in /etc/systemd/system${NC}\n"
    printf "${GREEN}srv cd${NC} ${GRAY}move to /etc/systemd/system${NC}\n"
    printf "${GREEN}srv cd2${NC} ${GRAY}move to /lib/systemd/system${NC}\n"

    #printf "${GREEN}${NC} ${GRAY}${NC}\n"

    echo

    printf "Dir: ${MAGENTA}/etc/systemd/system${NC}\n"
    printf "Dir (system): ${MAGENTA}/lib/systemd/system${NC}\n"

    return
  fi

  if [ -z "$2" ]; then
    if [ "$1" == "ls" ]; then
      ls -la /etc/systemd/system/*.service
    elif [ "$1" == "cd" ]; then
      cd /etc/systemd/system
    elif [ "$1" == "cd2" ]; then
      cd /lib/systemd/system
    else
      sudo systemctl status "$1"
    fi
  elif [ "$2" == "cat" ]; then
    local loc1="/etc/systemd/system/${1}.service"
    local loc2="/lib/systemd/system/${1}.service"

    if [ -f "$loc1" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc1${NC}\n\n"
      cat "$loc1"
    elif [ -f "$loc2" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc2${NC}\n\n"
      cat "$loc2"
    else
      printf "${RED}unknown service $1${NC}\n"
    fi
  elif [ "$2" == "edit" ]; then
    local loc1="/etc/systemd/system/${1}.service"
    local loc2="/lib/systemd/system/${1}.service"

    if [ -f "$loc1" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc1${NC}\n\n"
      sudo nano "$loc1"
      sudo systemctl daemon-reload
    elif [ -f "$loc2" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc2${NC}\n\n"
      sudo nano "$loc2"
      sudo systemctl daemon-reload
    else
      printf "${RED}unknown service $1${NC}\n"
    fi
  elif [ "$2" == "log" ]; then
    journalctl -u "${1}.service"
  else
    sudo systemctl "$2" "$1"
  fi
}

###### Arduino

alias esp8266="cd ~/Library/Arduino15/packages/esp8266/hardware/esp8266"

function arduino {
  awesome_cd ~/Documents/Arduino/libraries "$1"
}

###### Deps management

function query {
  if [ -z "$1" ]; then
    for d in `ls -1 ~/Install/npm/` ; do
      do_query "$d"
    done
    # this is faster (done in parallel), but:
    # - we would need to move query out to ~/bin/query because xargs cannot work with functions
    # - results would be in random order
    #ls -1 ~/Install/npm | xargs -n 1 -P 10 query
  else
    local matching_folder=''
    get_matching_folder matching_folder ~/Install/npm "$1"
    matching_folder=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_folder")

    if [ -n "$matching_folder" ]; then
      do_query "$matching_folder"
    else
      printf "${RED}$1 doesn't match any package in ~/Install/npm${NC}\n"
    fi
  fi
}

function do_query {
  local matches=$(ls -l /usr/local/lib/node_modules | grep "$1" | wc -l)
  if [ ! $matches -eq 0 ]; then
    version=$(version "/usr/local/lib/node_modules/${1}")
    matches=$(ls -l /usr/local/lib/node_modules | grep "Install/npm" | grep "$1" | wc -l)

    if [ $matches == 0 ]; then
      printf "${YELLOW}${1} ${version} (unstable)${NC}\n"
    else
      printf "${GREEN}${1} ${version} (stable)${NC}\n"
    fi
  else
    printf "${RED}${1} (not linked)${NC}\n"
  fi
}



######

function message {
  if [ -z "$1" ]; then
    echo "Usage: message msg [title]"
  else
    local title=""
    if [ -n "$2" ]; then
      title="$2"
    fi
    osascript -e "display notification \"$1\" with title \"$title\""
  fi
}

function ctrl_c_trap() {
  CTRL_C=true # crap, still doesn't get called in time!!!
  echo "** Trapped CTRL-C in ~/.bash_aliases"
}

# warning: STAYS FOREVER INSIDE TERMINAL CONSOLE after first set
function set_ctrl_c_trap {
  CTRL_C=false
  trap ctrl_c_trap INT
}

function convert_to_seconds {
  local time_input="$5"
  local _seconds=0
  local _val=0
  local _desc=""
  local _denom=""

  # default is minutes!
  if [[ "$time_input" =~ [0-9]+$ ]] ; then
    #_seconds=$time_input
    _seconds=$time_input
    _val=$time_input
    _desc="${_seconds}s"
    _denom="s"
  else
    local number=${time_input:0:${#time_input}-1}
    if [[ "$time_input" =~ s$ ]] ; then
      _seconds=$number
      _val=$number
      _desc="${_seconds}s"
      _denom="s"
    elif [[ "$time_input" =~ m$ ]] ; then
      _seconds=$(( $number*60 ))
      _val=$number
      _desc="${number}m"
      _denom="m"
    elif [[ "$time_input" =~ h$ ]] ; then
      _seconds=$(( $number*3600 ))
      _val=$number
      _desc="${number}h"
      _denom="h"
    elif [[ "$time_input" =~ d$ ]] ; then
      _seconds=$(( $number*3600*24 ))
      _val=$number
      _desc="${number}d"
      _denom="d"
    fi
  fi

  eval "$1='$_seconds'"
  eval "$2='$_val'"
  eval "$3='$_desc'"
  eval "$4='$_denom'"
}

function timer {
  if [ -z "$1" ]; then
    echo "Usage: timer [1|1s|5min|2h|3d] [message]"
  else

    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"

    if [ -n "$desc" ]; then
      printf "${YELLOW}Waiting for ${desc} ...${NC}\n"

      case $denom in
        "s" )
          sleep $seconds
          # for (( i=$val; i>0; i-- ))
          # do
          #   printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
          #   sleep 1
          # done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "m" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 60
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "h" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 3600
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "d" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 86400
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
      esac

      # following check won't matter because CTRL_C is not actually set to TRUE yet even if trap function ctrl_c_trap was supposedly called first (?)
      #if [ -z ${CTRL_C+x} ] || [ $CTRL_C] ; then
      #  echo $CTRL_C
      if macos; then
        shift
        local msg="$@"
        if [ -n "$msg" ]; then
          message "$msg" "${desc} is up"
        else
          message "${desc} is up" "Time's up"
        fi
      fi
    else
      printf "${RED}Error in argument${NC}\n"
    fi
  fi
}

function sleepmin {
  if [ -z "$1" ]; then
    echo "Usage:"
    echo "sleepmin [min]"
  else
    sleep $(( $1*60 ))
  fi
}


function find_recent() {
  find . -type f -mmin -$1 -not -name .DS_Store -exec ls -lh {} \; | sed 's/\.\///' | awk '{print $5, substr($0,index($0,$9))}'
  #| cut -d' ' -f6-
}

alias min="find_recent 2"
alias hour="find_recent 60"
alias day="find_recent 1440"

alias mk="mkdir"
alias mkp="mkdir -p"
k () { mkdir -p "$@" && cd "$_"; }

# sum column of numbers...
# 1 lala
# 234 aaavdfv
# 54 sdfdsf
function total {
  cat $1 | awk '{s+=$1} END {printf "Sum: %.0f\n", s}'
}

# iterm2
alias normal='echo -e "\033]50;SetProfile=Default\a"'
alias large='echo -e "\033]50;SetProfile=LargeFont\a"'

#brew install highlight
#alias pcat="pygmentize -f terminal256 -O style=monokai -g"
function hcat {
  highlight -O xterm256 -s darkbone "$@"
}

# utility function
function current_usage {
  local output=$(du -sh | awk '{ print $1 }')
  printf "${YELLOW}${output}${NC}\n"
}

function freespace {
  printf "Free:\t ${GREEN}`df -h . | tail -1 | awk '{ print $4 }'`${NC}\n"
}

function space {
  local dir="`pwd`"
  if [ -n "$1" ]; then
    if [ -d "$1" ]; then
      dir="$1"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  if [ ! "$dir" == $HOME ] && [ ! "$dir" == '/' ]; then
    if [ "$dir" == "`pwd`" ]; then
      printf "Current: "
      current_usage
    else
      printf "${dir}: "
      local cwd="`pwd`"
      cd "$dir"
      current_usage
      cd "$cwd"
    fi
  fi
  freespace
}

# utility function
function usage_for {
  printf "${1} "
  if [ -d "${1}" ]; then
    cd "$1"
    current_usage
  else
    printf "${RED}No such directory${NC}\n"
  fi
}

function usage {
  if macos; then
    find . -maxdepth 1 -type d -print0 | xargs -0 -I{} du -sh {} | gsort -hr # probably need: "brew install coreutils" for gsort
  else
    find . -maxdepth 1 -type d -print0 | xargs -0 -I{} du -sh {} | sort -hr
  fi
}

function count {

  local dir=""
  if [ -z "$1" ]; then
    dir="."
  else
    if [ -d "$1" ]; then
      dir="$1"
      printf "${YELLOW}${dir}:${NC}\n"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  printf "${CYAN}Directories: "
  find "$dir" -maxdepth 1 ! -path . ! -path "*/.git" -type d | wc -l | xargs
  printf "${GREEN}Files:       "
  find "$dir" -maxdepth 1 ! -path "*/.DS_Store" ! -path "*/.git" -type f | wc -l | xargs
  printf "${NC}"
}

function countr {

  count "$@"

  local dir=""
  if [ -z "$1" ]; then
    dir="."
  else
    if [ -d "$1" ]; then
      dir="$1"
      printf "${YELLOW}${dir}:${NC}\n"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  echo
  printf "${CYAN}Directories (Recursive): "
  find "$dir/" ! -path . ! -path "*/.git/*" -type d | wc -l | xargs # "/" is needed if we use "count ~/path/to/symlinked_directory", it's changed to: "count ~/path/to/symlinked_directory/"
  printf "${GREEN}Files: (Recursive):      "
  # If you have issues here: for example mismatch in number of files in two directories where one is a copy of another,
  # it's almost certainly symlinks issue, find out like this:
  # Directory A) find . -type f > ~/Desktop/a.txt
  # Directory B) find . -type f > ~/Desktop/b.txt
  # Compare: diff ~/Desktop/a.txt ~/Desktop/b.txt
  find "$dir/" ! -path "*/.DS_Store" ! -path "*/.git/*" -type f | wc -l | xargs
  printf "${NC}"
}

function lines {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}lines [file.txt] ${GRAY}counts the number of lines in the file${NC}\n"
  else
    cat "$1" | wc -l
  fi
}

function space2rem {
  if [ "$EUID" -ne 0 ]; then
    echo "please run under root - execute: root"
    return
  fi
  find /var/folders -name "*.iscachebmp" -type f -exec rm -v "{}" \;
  find /private/var/folders -name "*.iscachebmp" -type f -exec rm -v "{}" \;
}

# swap files or directories
function swap {
  if [ -n "$1" ] && [ -n "$2" ]; then
    swap_once "$1" "$2"
  elif [ -f "config.json.sample" ] && [ -f "config.json" ]; then
    swap_once "config.json.sample" "config.json"
  elif [ -f "david_wallet" ] && [ -f "default_wallet" ]; then
    swap_once "david_wallet" "default_wallet"
  fi
}

function swap_once {
  mv "$1" /tmp/switch_temp
  mv "$2" "$1"
  mv /tmp/switch_temp "$2"
}

function sleepin {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC} sleepin 10 (min)\n"
  else
    local delay=$(($1*60))
    sleep $delay && pmset sleepnow # with && - if you cancel with ctrl+c it works correctly (semicolon doesn't!)
  fi
}

# ping server (ex. server.com) or "resource" (http://server.com/file)
function pi {
  local target="1.0.0.1"
  if [ -n "$1" ]; then
    if [[ "$1" =~ \/ ]]; then
      if [[ $(curl -I --write-out %{http_code} --silent --output /dev/null "$@") == "200" ]]; then
        printf "${GREEN}✓ CurlPing OK, Returned status 200${NC}\n"
      else
        printf "${RED}✖ NOT FOUND${NC}\n"
      fi
    else
      printf "${GRAY}Pinging ${@} ...${NC}\n"
      if [[ $(ping -c 1 "$@" 2>&1) == *"0% packet loss"* ]]; then
        printf "${GREEN}✓ Ping OK${NC}\n"
      else
        printf "${RED}✖ NO CONN${NC}\n"
      fi
    fi
  else
    printf "${GRAY}Pinging ${target} ...${NC}\n"
    if [[ $(ping -c 1 "$target" 2>&1) == *"0% packet loss"* ]]; then
      printf "${GREEN}✓ Ping OK${NC}\n"
    else
      printf "${RED}✖ NO CONN${NC}\n"
    fi
  fi
}

function ux {
  matching_file=''
  get_matching_file matching_file "$1"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ -f "$matching_file" ]; then
    printf "chmod u+x ${YELLOW}$matching_file${NC}\n"
    chmod u+x "$matching_file"
  else
    printf "${RED}File not found${NC}\n"
  fi
}

function flash_usage {
  local sectors="$1"
  printf "${YELLOW}Usage:${NC}\n"
  printf "${GREEN}flash image.img 2${NC} ${GRAY}flash image.img to /dev/rdisk2${NC}\n"
  printf "${GREEN}flash read 2${NC} ${GRAY}read full image from /dev/rdisk2 to ./image.img${NC}\n"
  printf "${GREEN}flash read 2 16gb${NC} ${GRAY}read sectors 0..${sectors} from /dev/rdisk2 to ./image.img${NC}\n"
  #printf "${GREEN}flash read 2 default${NC} ${GRAY}read sectors 0..${sectors} from /dev/rdisk2 to ./image.img${NC}\n"
  printf "${GREEN}flash read 2 [nSectors]${NC} ${GRAY}read sectors 0..nSectors from /dev/rdisk2 to ./image.img${NC}\n"
}

function flash {
  local file_pattern="$1"
  local disk_n="$2"

  #local defaultSectors="20000768" # 9.5GB, divisible by 4096 for optimal sector alignment
  local sectors16gb="31116288" # 16GB


  if [ "$1" == "-h" ] || [ -z "$1" ]; then
    printf "${YELLOW}diskutil list:${NC}\n\n"
    diskutil list
    flash_usage "$sectors16gb"
    return
  fi

  if [ -z "$file_pattern" ]; then
    printf "${YELLOW}diskutil list:${NC}\n\n"
    diskutil list
    printf "${YELLOW}Usage:${NC}\n"
    echo "flash file.img diskN"
    return
  fi

  if [ "$1" == "read" ]; then
    if [ -z "$disk_n" ]; then
      printf "${YELLOW}diskutil list:${NC}\n\n"
      diskutil list

      printf "${MAGENTA}You have to specify the disk number from where to create the image${NC}\n"
      echo

      flash_usage "$sectors16gb"
    else
      local image="image.img"

      if [ -f "$image" ]; then
        printf "${RED}image.img already exists${NC}\n"
        return
      fi

      if [ -z "$3" ]; then
        printf "${GREEN}Copying full image to ${YELLOW}${image}${NC}\n"
        time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=64k
      else
        local sectors

        if [ "$3" == "16gb" ] || [ "$3" == "16GB" ]; then
          printf "${GREEN}Reading first 16gb from sd card ... ${NC}\n"
          sectors="$sectors16gb"
        else
          sectors="$3"
        fi

        printf "${GREEN}Copying sectors${NC} 0..${sectors} to ${YELLOW}${image}${NC}\n"

        # Usually the number of sectors will be a multiple of some power of 2, and you can increase the copying speed
        # by increasing the block size and decreasing the count, keeping the product constant.
        if ! (( $sectors % 64 )) ; then
          printf "${MAGENTA}Optimal speed: number of sectors divisible by 64 - reading 128 sectors (64K) at a time${NC}\n"
          # for default 20000000 sectors it takes around 150s to copy data from sd card
          # 1 sector = 512b
          # 64K seems to be quite optimal, no difference with 1M, but faster than 32K or less
          time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=64k count="$((sectors/128))"
        elif ! (( $sectors % 32 )) ; then
          printf "${MAGENTA}Almost optimal speed: number of sectors divisible by 32 - reading 64 sectors (32K) at a time${NC}\n"
          time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=32k count="$((sectors/64))"
        else
          time sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=512 count="${sectors}"
        fi
      fi

      if [ -f "image.img" ]; then
        sudo chown $(whoami) image.img
        if macos; then
          sudo chgrp staff image.img
        fi
      fi
    fi

    return
  fi

  matching_file=''
  get_matching_file matching_file "$file_pattern"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    printf "${RED}No such file: ${file_pattern}${NC}\n"
  else
    if [ -z "$disk_n" ]; then
      printf "${YELLOW}diskutil list:${NC}\n\n"
      diskutil list

      printf "${MAGENTA}You have to specify the disk number where to flash ${GREEN}${matching_file}${NC}\n"
      echo

      flash_usage "$sectors"
    else
      printf "Flashing ${YELLOW}${matching_file}${NC} to ${RED}rdisk${disk_n}${NC}...\n"
      read -r -p "Sure????? (you will be asked for sudo password) [Y/n] " response
      if [[ ! $response =~ ^([nN])$ ]]
      then
        printf "${YELLOW}Flashing after password...${NC} Press Ctrl+T to see progress\n"
        diskutil unmountDisk "/dev/disk${disk_n}"
        time sudo dd if="$matching_file" of="/dev/rdisk${disk_n}" bs=64m # changed from: 1m
        diskutil eject "/dev/disk${disk_n}"
        printf "${GREEN}done.${NC} ${YELLOW}You can take the SD card out now.${NC}\n"
      fi
    fi
  fi
}

function md {
  if [ -f "$1" ] || [ -d "$1" ]; then
    mv "$1" ~/Desktop
    if [ $? -eq 0 ]; then
      printf "${YELLOW}Moved ${1} to ~/Desktop\n"
    fi
  else
    printf "${RED}No such file or directory${NC}\n"
  fi
}

alias vlc="open -n /Applications/VLC.app"

# Requirement for static server: npm install -g http-server
# Other: elixir, mina, jekyll, node, npm
function serve {
  if [ -f ./server ]; then
    printf "${YELLOW}./server $1${NC}\n"
    ./server $1
  elif [ -f ./mix.exs ]; then
    printf "${YELLOW}mix phoenix.server${NC}\n"
    mix phoenix.server
    # or: iex -S mix phoenix.server
  elif [ -f ./server.js ]; then
    printf "${YELLOW}node server.js${NC}\n"
    node server.js
  elif [ -f ./package.json ] && [ $(ls-scripts | grep 'serve' | wc -l) -gt 0 ]; then
    npm run serve
  # npm install -g npm-ls-scripts
  elif [ -f ./package.json ] && [ $(ls-scripts | grep '^start' | wc -l) = 1 ]; then
    printf "${YELLOW}npm run start${NC}\n"
    npm run start
  elif [ -f ./truffle.js ]; then
    printf "${YELLOW}testrpc --port 8700${NC}\n"
    testrpc --port 8700
  elif [ -f ./index.js ]; then
    local args=$@
    printf "${YELLOW}nodemon index.js ${args}${NC}\n"
    nodemon index.js $args
  elif [ -f ./elm-package.json ]; then
    printf "${YELLOW}elm reactor${NC}\n"
    elm reactor
    #elm-reactor
  elif [ -d _site ]; then
    printf "${YELLOW}jekyll serve${NC}\n"
    jekyll serve
  else
    printf "${YELLOW}http-server -p 3000${NC}\n"
    http-server -p 3000
  fi
}

# https://gist.github.com/davidhq/9883d43146d1fb2c2c00

# function source_code {
#   local matching_files=$(find . -name "*.${2}" -not -path "*/.git/*" -not -path "*/node_modules/*" -not -path "*/Godeps/*" -not -path "*/elm-stuff/*" -not -path "*/deps/*" -not -path "*/_build/*" -not -path "*/target/*" -not -path "*/dist/*" -not -path "*/bower_components/*" -not -path "*/tmp/*")
#   eval "$1='${matching_files}'"
# }

# npm install -g cloc
function cloc {
  command cloc . --exclude-dir=.git,log,node_modules,Godeps,elm-stuff,deps,_build,target,dist,vendor,bower_components,tmp,deploy,distroot,Deps --exclude-lang=XML
}

function loc {
  if [ -z "$1" ] || [ "$1" == "all" ]; then
    loc js "$2"
    loc ls "$2"
    loc coffee "$2"
    loc c "$2"
    loc cpp "$2"
    loc cs "$2"
    loc cc "$2"
    loc java "$2"
    loc scala "$2"
    loc jsx "$2"
    loc sh "$2"
    loc sol "$2"
    loc ex "$2"
    loc exs "$2"
    loc erl "$2"
    loc go "$2"
    loc rs "$2"
    loc hs "$2"
    loc elm "$2"
    loc rb "$2"
    loc py "$2"
    loc html "$2"
    loc md "$2"
    loc css "$2"
    #loc xml "$2"
    loc json "$2"
  else
    IFS=$'\n'

    local files=$(find . -name "*.${1}" -not -path "*/.git/*" -not -path "*/log/*" -not -path "*/node_modules/*" -not -path "*/assets/*" -not -path "*/Godeps/*" -not -path "*/elm-stuff/*" -not -path "*/deps/*" -not -path "*/_build/*" -not -path "*/target/*" -not -path "*/dist/*" -not -path "*/vendor/*" -not -path "*/bower_components/*" -not -path "*/tmp/*" -not -path "*/deploy/*" -not -path "*/distroot/*" -not -path "*/Deps/*")
    # local files=''
    # source_code files "$1"

    if [ -n "$files" ]; then
      printf "${GREEN}${1}${NC}\n"
      if [ "$2" == "total" ]; then
        local total=$(wc -l $files | grep "total")
        if [ -n "$total" ]; then
          echo $total
        else
          wc -l $files
        fi
      else
        wc -l $files
      fi
      echo
    fi

    unset IFS
  fi
}

function stats {
  local tempdir=$(mktemp -d)
  if [ -d ".git" ]; then
    gitstats . "$tempdir"
    open "$tempdir/authors.html"
  else
    printf "${RED}Not a git repo...${NC}\n"
  fi
}

function loct {
  loc "all" "total"
}

# alias deb="DEBUG=true"

# function diag {
#   echo "DIAGNOSTICS for the project: to implement"
# }

function a {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "a [term] [context_lines]"
    echo "a --[lang] [term] [context_lines]"
  else
    clear && printf '\e[3J' # completely clear the terminal

    if [ -n "$2" ] && [[ $1 == *--* ]]; then
      if [ -n "$3" ]; then
        command ack "$1" -i -Q -C "$3" -- "$2"
      else
        command ack "$1" -i -Q -- "$2"
      fi
    # if [[ $@ == *--* ]]; then
    #   # ack --ruby something
    #   command ack -i -Q "$@"
    else
      # -k flag to say "Only search the files that ack recognizes the types for"
      if [ -n "$2" ]; then
        command ack -i -k -Q -C "$2" -- "$1"
      else
        command ack -i -k -Q -- "$@"
      fi
      #command ack -i -k -Q -- $@
      # there were problems with -- $Q with: ack "Refresh to" -C 3
      # look below
    fi
  fi
}

function compare {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}compare dir1 dir2${NC}\n"
    printf "${GREEN}compare --size-only dir1 dir2${NC}\n"
  else
    local sizeonly=""
    if [ "$1" == "--size-only" ]; then
      sizeonly="--size-only"
      printf "${YELLOW}Sizeonly...${NC}\n"
      shift
    fi

    local params="-n -rli --delete $sizeonly"
    # -n = dry run
    #-rlptgoD
    rsync $params --exclude="._*" "$1"/ "$2"/
  fi
}
