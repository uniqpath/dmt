#!/bin/bash

# -- DMT ALIASES --
# SAVES YOU TIME AND MONEY. FREE SOFTWARE.

# INSTALL INSTRUCTIONS FOR Linux / macOS
# (Windows not supported, it has different philosophy)

# TODO: UPDATE!!!!!!!!

# 1.
# put this file into ~/.bash_aliases
# curl -o ~/.bash_aliases https://elm-research.com/projects/bash_aliases.txt
#
# Make the shell load it:
# type:
# sudo nano /etc/profile
#
# add this to the end:
#
# # Alias definitions.
# if [ -f /Users/[your name]/.bash_aliases ]; then
#   . /Users/[your name]/.bash_aliases
# fi
#
# You could also add this to ~/.bash_profile but it's better in /etc/profile because then you will have access to things defined here even when you are root
#
# To update in the future:
# update
#
# You can also check the changelog before each update:
# update_diff

# 2.
# place to put non-shareable stuff: /etc/.bash_aliases_custom

# YOU CAN add your custom aliases or changes here please...
# don't add them in this file for now, rather ask me (the author - davidhq) to update it, this is the only way to keep this file in sync for easy updates

# 3.
# ------------ TEST YOUR SETUP: ---------------
# Open a new terminal tab and type:
# l [enter]
# or
# count [enter]

# You can always terminate commands that are running too long (shouldn't happen often and almost always by your own fault - for example running count on a big folder!)
# with: CTRL+C

# If you make some changes to ~/.bash_aliases_custom, you can type: rel [enter] to reload the environment without closing the tab and opening a new one

# Learn about two useful metacommands for start: "rel" and "al"

# -------------------------------------------------------

# OPTIONAL:
#
# 4. DEPENDENCIES

# Install some other dependencies that some functions use:
# - Install "homebrew" awesome package manager for macOS based on the archaic Ruby language
#
# --- SSHRC
# brew install sshrc
#
# This turbocharges this file even more because now you'll take it with you to whatever linux server you ssh into!
# This file speeds up your command line in both, MacOS and Linux in the same exact way: it smoothes out the differences, vas majority of commands work the same on both
# types of systems.
#
# Step 2 - create symlink to this file:
# cd [this moves to home directory]
# ln -s

# -- coreutils (macOS)
# brew install coreutils
# provides gsort (used in "usage" for example) and other commands
# also provides "gshuf"
#
# --- GNU GREP
# brew install grep (gnu grep: install the command "ggrep")
#
# --- CLOC
# npm install -g cloc (code analysis in addition to "loc" which .dmt provides)
#
# --- ACK
# brew install ack
#
# Create ~/.ackrc with this contents:
#
# --type-add
# ruby=.builder,.feature
# --type-set
# rackup=.ru
# --type-set
# elm=.elm
# --type-set
# livescript=.ls
# --type-set
# haml=.haml
# --type-add
# php=.phtml
# --type-set
# jsx=.jsx
# --type-set
# vue=.vue
# --type-set
# markdown=.markdown,.md,.mdown
# --type-set=cache=.cache
# --ignore-dir=.idea
# --ignore-dir=tmp
# --ignore-dir=photos
# --ignore-dir=node_modules
# --ignore-dir=bower_components
# --ignore-dir=dist
# --ignore-dir=.git
# --ignore-dir=log
# --ignore-dir=Godeps
# --ignore-dir=elm-stuff
# --ignore-dir=deps
# --ignore-dir=build
# --ignore-dir=_build
# --ignore-dir=dist
# --ignore-dir=Deps
# --ignore-dir=vendor
# --nocache
#
# --- HIGHLIGHT: highlight code in terminal (when using "t" command instead of "cat")
# brew install highlight
#
# --- jq: parse .json in terminal
# brew install jq
#
# --- latest version of RSYNC (only needed for macOS Sierra+, linux already has the latest version)
# brew install rsync
# needed because of --protect-args (https://unix.stackexchange.com/a/137285/135062) - used in dirsync function
# if you want to rsync *to* macOS (rsync server is used), make sure to add /usr/local/bin to $PATH in ~/.bashrc so that it's loaded on ssh / rsync
#
# --- TREE: show directory and file structure
# brew install tree
#
# --- COLORDIFF: colors in diffs (example: update_diff command that shows what would be updated with "update")
# brew install colordiff
#
# --- GITSTATS
# Todo: automatic install - detect os, ask for confirmation and install!!!
# command: stats

# 5. SYNCBOX
#
# mkdir ~/Syncbox
# echo "pi@lab.local" > ~/.syncbox
#
# Commands:
# push
# pull

# ----------------======---------------

# + LOAD DMT DEPS

# LOGNAME=$(logname 2>/dev/null)

# # Returns error in two known occasions:
# # 1) after "dmt update [device]" which calls "./install" *via ssh -e*
# # 2) on linux machines when executing "se" (command in background screen)
# if [ $? -ne 0 ]; then # error
#   LOGNAME_HOME="$HOME"
# else
#   if macos; then
#     #LOGNAME_HOME="/Users/$(whoami)"
#     LOGNAME_HOME="$HOME"
#   else
#     LOGNAME_HOME="/home/$(logname)" # MAYBE IMPROVE??
#   fi
# fi

LOGNAME_HOME="$HOME"

DMT_PATH="$LOGNAME_HOME/.dmt"

DMT_USER_PATH="$LOGNAME_HOME/.dmt/user"
DMT_THIS_DEVICE="$LOGNAME_HOME/.dmt/user/devices/this"

DMT_DEVICE_FILE="$DMT_THIS_DEVICE/def/device.def"

DMT_STATE="$DMT_PATH/state"

DMT_CORE="$LOGNAME_HOME/.dmt/core"
DMT_NODE_CORE="$DMT_CORE/node"
DMT_RUST_CORE="$DMT_CORE/rust"

DMT_RUNTIMES=(node rust)

# for runtime in "${DMT_RUNTIMES[@]}"
# do
#   if [ ! -f "$DMT_CORE/${runtime}" ]; then
#     mkdir -p "$DMT_CORE/${runtime}"
#   fi
# done

# if [ ! -f "$DMT_CORE/static" ]; then
#   mkdir -p "$DMT_CORE/static"
# fi

DMT_SCRIPTS="$DMT_PATH/etc/scripts"

DMT_PLATFORM=""
if macos; then
  DMT_PLATFORM="darwin"
elif [ "$OSTYPE" == "linux-gnu" ]; then
  DMT_PLATFORM="linux-x64"
elif [ "$OSTYPE" == "linux-gnueabihf" ]; then
  DMT_PLATFORM="linux-arm"
fi

DMT_PLATFORM_BIN="${DMT_PATH}/bin/${DMT_PLATFORM}"
DMT_USER_PLATFORM_BIN="${DMT_USER_PATH}/bin/${DMT_PLATFORM}"
DMT_DEVICE_PLATFORM_BIN="${DMT_THIS_DEVICE}/bin/${DMT_PLATFORM}"
DMT_AP_DEFAULT_HOST="pi@192.168.1.1"

# syncbox="pi@dmt.local"

# if [ -f ~/.syncbox ]; then
#   syncbox=`cat ~/.syncbox`
# fi

# cp with progress and speed of the transfer
alias cpp="rsync -ah --progress"

function compile {
  local cwd="`pwd`"
  cd "$DMT_PATH/shell"
  ./compile
  cd "$cwd"
}

# Reload the environment
function rel {

  if [ -f "$DMT_PATH/shell/compile" ]; then
    compile
  fi

  if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
  fi
  if [ -f ~/.bashrc ]; then
    . ~/.bashrc
  fi
  if [ -f ~/.bash_profile ]; then
    . ~/.bash_profile
  fi
}

# Usage:
# "al [enter]" - opens Sublime editor on the ~/.dmt
# or "al [any function name]" to see the source for the function directly in terminal without having to open source files
function al {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}al [function]${NC} ${GRAY}show bash function source${NC}\n"
    return
  fi

  which highlight > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    type "$1" | highlight -O xterm256 -s darkbone --syntax bash
  else
    type "$1"
  fi
}

function loop {
  while true; do "$@"; sleep 5; done
}

function newscript {
  if [ -n "$1" ]; then
    if [ -f "$1" ]; then
      printf "${RED}File already exists${NC}\n"
    else
      echo "#!/usr/bin/env node" > "$1"
      echo '"use strict"' >> "$1"
      ux "$1"
    fi
  else
    echo "Usage: newscript [file]"
  fi
}

function os {
  cat /etc/os-release
}

# ---------------------------

function gr {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "gr search_term [where]"
    return
  fi

  local pattern="$1"
  local where="."

  if [ -n "$2" ]; then
    where="$2"
  fi
  # http://www.computerhope.com/unix/ugrep.htm

  grep -rI --exclude-dir="\.svn" --exclude-dir="\.git" "$pattern" "$where" --color -n
}

function mac {
  system_profiler SPNetworkDataType | grep Wi-Fi -A10
  ifconfig en0
}

########### ESP8226 ###########

function esp {
  local ftdi1="/dev/tty.SLAB_USBtoUART"
  local ftdi2="/dev/tty.wchusbserial1420"

  local ftdi=$ftdi1

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "esp [command] [arguments]"
    echo
    printf "${YELLOW}Commands:${NC}\n"
    printf "${GREEN}mac${NC}\n"
    printf "${GREEN}erase${NC}\n"
    printf "${GREEN}flash${NC} ${GRAY}[file.bin] [slow|fast] (default=slow)${NC}\n"
    printf "${GREEN}upload${NC} ${GRAY}[file.bin] [ip]${NC}\n"
  else

    declare -a opts=(
      "mac"
      "flash"
      "erase"
      "upload"
    )

    local matching_opt=''
    opts_matcher matching_opt "$1" "${opts[@]}"
    if [ $? -ne 0 ]; then # error
      return
    fi

    shift

    # https://github.com/espressif/esptool
    # pip install esptool
    local esp_tool_path="esptool.py"

    case "$matching_opt" in
      mac)
          printf "esp tool : ${MAGENTA}$esp_tool_path${NC}\n"
          printf "ftdi: ${MAGENTA}$ftdi${NC}\n"
          "$esp_tool_path" -p "$ftdi" read_mac
          ;;

      erase)
          printf "esp tool : ${MAGENTA}$esp_tool_path${NC}\n"
          printf "ftdi: ${MAGENTA}$ftdi${NC}\n"
          "$esp_tool_path" -p "$ftdi" erase_flash
          ;;

      flash)
          if [ -z "$1" ]; then
            printf "${RED}Please specify firmware file${NC}\n"
            return
          fi
          if [ ! -f "$1" ]; then
            printf "${RED}Firmware file doesn't exist${NC}\n"
            return
          fi
          local baudrate=57600
          if [ "$3" == "fast" ]; then
            baudrate=115200
            echo "FAST"
          fi
          printf "esp tool : ${MAGENTA}$esp_tool_path${NC}\n"
          printf "ftdi: ${MAGENTA}$ftdi${NC}\n"
          printf "baudrate: ${MAGENTA}$baudrate${NC}\n"
          "$esp_tool_path" -p "$ftdi" -b "$baudrate" write_flash 0x0 "$1"
          ;;

      upload)
          local esp_path="$HOME/Library/Arduino15/packages/esp8266/hardware/esp8266"
          local exec_count=$(find "$esp_path" -type f -name "espota.py" | wc -l)

          if [ $exec_count == 1 ]; then
            local esp_ota_path=$(find "$esp_path" -type f -name "espota.py")
          elif [ $exec_count == 0 ]; then
            printf "${RED}Missing espota.py under $esp_path${NC}\n"
            return
          else
            printf "${RED}Multiple espota.py:${NC}\n"
            find "$esp_path" -type f -name "espota.py"
            printf "${YELLOW}Which one is correct?${NC}\n"
            return
          fi

          if [ -z "$1" ]; then
            printf "${RED}Please specify firmware file and ip address${NC}\n"
            return
          fi
          # if [ ! -f "$2" ]; then
          #   printf "${RED}Firmware file doesn't exist${NC}\n"
          #   return
          # fi
          if [ -z "$2" ]; then
            printf "${RED}Please specify an ip address${NC}\n"
            return
          fi
          local file="$1"
          local ip="$2"

          local matching_file=''
          get_matching_file matching_file "$file"
          matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

          if [ ! -f "$matching_file" ]; then
            printf "${RED}Firmware file not found based on $file${NC}\n"
            return
          fi

          printf "esp ota : ${MAGENTA}$esp_ota_path${NC}\n"
          printf "file    : ${MAGENTA}$matching_file${NC}\n"
          printf "ip      : ${MAGENTA}$ip${NC}\n"

          python "$esp_ota_path" -d -i $ip -p 8266 --auth= -f "$matching_file"

          # if [ -f "$HOME/Install/esp8266/tools/espota.py" ]; then
          #   printf "ip: ${MAGENTA}$ip${NC}\n"
          #   printf "file: ${MAGENTA}$file${NC}\n"
          #   $HOME/Install/esp8266/tools/espota.py -d -i "$ip" -p 8266 --auth= -f "$file"
          # else
          #   printf "$HOME/Install/esp8266/tools/espota.py ${RED}not found${NC}\n"
          # fi
          ;;

      esac

    fi
}

# dep for reload:
# sudo apt-get install -y xdotool
function kiosk {
  if macos; then
    printf "${RED}Cannot run on macOS${NC}\n"
    return
  fi

  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo

    printf "${GREEN}edit: ${GRAY}edit kiosk configuration file${NC}\n"
    printf "${GREEN}reload: ${GRAY}reload currently set url in kiosk browser${NC}\n"
    printf "${GREEN}restart: ${GRAY}restart kiosk browser (for example on configuration change)${NC}\n"

    if [ -f ~/.config/lxsession/LXDE-pi/autostart ]; then
      printf "\n${MAGENTA}Current kiosk setup:${NC}\n"
      cat ~/.config/lxsession/LXDE-pi/autostart | grep ^@/usr/bin/chromium-browser
    fi

    return
  fi

  case "$1" in

    edit)

      local loc1="/var/lib/dietpi/dietpi-software/installed/chromium-autostart.sh"
      local loc2=~/.config/lxsession/LXDE-pi/autostart

      if [ -f "$loc1" ]; then
        sudo nano "$loc1"
      elif [ -f "$loc2" ]; then
        nano "$loc2"
      fi

      ;;

    reload)

      if [ ! -f ~/.config/lxsession/LXDE-pi/autostart ]; then
        printf "${YELLOW}Kiosk configuration missing...${NC}\n"
        return
      fi

      printf "${GREEN}Reloaded...${NC}\n"

      #printf "${MAGENTA}Note: this only reloads the currently open url, if you changed it, you have to call [kiosk restart]${NC}\n"

      which xdotool > /dev/null 2>&1

      if [ $? -eq 0 ]; then
        export DISPLAY=":0"
        WID=$(xdotool search --onlyvisible --class chromium|head -1)
        xdotool windowactivate ${WID}
        xdotool key ctrl+F5
      else
        printf "${RED}xdotool missing, please install with: ${GRAY}sudo apt-get -y install xdotool${NC}\n"
      fi

      ;;

    restart)

      if [ ! -f ~/.config/lxsession/LXDE-pi/autostart ]; then
        printf "${YELLOW}Kiosk configuration missing...${NC}\n"
        return
      fi

      sudo killall chromium-browser
      printf "${MAGENTA}Please copy and execute this command:${NC}\n"
      echo "export DISPLAY=\":0\"; $(cat ~/.config/lxsession/LXDE-pi/autostart | grep ^@/usr/bin/chromium-browser | sed 's/^@//') &"

      ;;

    *)
      printf "${RED}Unknown request${NC}\n"
      ;;

  esac
}


#### systemd

function shut {

  if ! macos && [ -f "/etc/fstab" ] ; then
    which lsblk > /dev/null 2>&1

    # lsblk exists
    if [ $? -eq 0 ]; then
      local labels=()

      # read all present labels via lsblk
      while read label do
      do
        if [ -n "$label" ] && [ "$label" != "LABEL" ]; then
          labels+=("$label")
        fi
      done < <(lsblk -o LABEL)

      # read /etc/fstab
      while read line
      do
        local label=$(echo "$line" | awk '{print $1}' | sed 's/LABEL=//')
        local path=$(echo "$line" | awk '{print $2}')

        array_contains_element "$label" "${labels[@]}"

        if [ $? -eq 0 ]; then
          if [ ! -d "$path" ]; then
            printf "${YELLOW}/etc/fstab:${NC} ${CYAN}Directory ${path} ${RED}not found, system wouldn't boot, aborting ...${NC}\n"
            return
          fi
        else
          printf "${YELLOW}/etc/fstab:${NC} ${CYAN}Label ${label} ${RED}not found on the system with lsblk, system wouldn't boot, aborting ...${NC}\n"
          return
        fi
      done < <(cat /etc/fstab | grep '^LABEL')
    else
      printf "${YELLOW}lsblk missing${NC}, no additional safety checks performed on /etc/fstab ...\n"
      printf "${MAGENTA}Install lsblk${NC}\n"
    fi
  fi

  if [ "$1" == 'reboot' ] || [ "$1" == 'r' ]; then
    printf "${MAGENTA}Rebooting...${NC}\n"
    sudo reboot
  else
    read -r -p "Are you sure you want to shut the device down (instead of rebooting)? [Y/n] " response
    if [[ ! $response =~ ^([nN])$ ]]
    then
      printf "${RED}Shutting down...${NC}\n"
      if macos; then
        off
      else
        sudo shutdown -h now
      fi
    fi
  fi
}

function res {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}res [service] ${GRAY}= sudo systemctl restart [service]${NC}\n"
  else
    sudo systemctl restart "$@"
    printf "${GREEN}Done.${NC}\n"
  fi
}

function reb {
  printf "${MAGENTA}Rebooting...${NC}\n"
  shut reboot
}

function srv {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"

    printf "${GREEN}srv [service]${NC} ${GRAY}show status${NC}\n"
    printf "${GREEN}srv [service] [command]${NC} ${GRAY}run command, ex.: start|stop|reload|restart${NC}\n"
    printf "${GREEN}srv [service] cat${NC} ${GRAY}show service specification${NC}\n"
    printf "${GREEN}srv [service] edit${NC} ${GRAY}edit service specification${NC}\n"
    printf "${GREEN}srv [service] log${NC} ${GRAY}see service log${NC}\n"
    echo
    printf "${GREEN}srv ls${NC} ${GRAY}show services in /etc/systemd/system${NC}\n"
    printf "${GREEN}srv cd${NC} ${GRAY}move to /etc/systemd/system${NC}\n"
    printf "${GREEN}srv cd2${NC} ${GRAY}move to /lib/systemd/system${NC}\n"

    #printf "${GREEN}${NC} ${GRAY}${NC}\n"

    echo

    printf "Dir: ${MAGENTA}/etc/systemd/system${NC}\n"
    printf "Dir (system): ${MAGENTA}/lib/systemd/system${NC}\n"

    return
  fi

  if [ -z "$2" ]; then
    if [ "$1" == "ls" ]; then
      ls -la /etc/systemd/system/*.service
    elif [ "$1" == "cd" ]; then
      cd /etc/systemd/system
    elif [ "$1" == "cd2" ]; then
      cd /lib/systemd/system
    else
      sudo systemctl status "$1"
    fi
  elif [ "$2" == "cat" ]; then
    local loc1="/etc/systemd/system/${1}.service"
    local loc2="/lib/systemd/system/${1}.service"

    if [ -f "$loc1" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc1${NC}\n\n"
      cat "$loc1"
    elif [ -f "$loc2" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc2${NC}\n\n"
      cat "$loc2"
    else
      printf "${RED}unknown service $1${NC}\n"
    fi
  elif [ "$2" == "edit" ]; then
    local loc1="/etc/systemd/system/${1}.service"
    local loc2="/lib/systemd/system/${1}.service"

    if [ -f "$loc1" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc1${NC}\n\n"
      sudo nano "$loc1"
      sudo systemctl daemon-reload
    elif [ -f "$loc2" ]; then
      printf "${YELLOW}Found${NC} ${GREEN}$loc2${NC}\n\n"
      sudo nano "$loc2"
      sudo systemctl daemon-reload
    else
      printf "${RED}unknown service $1${NC}\n"
    fi
  elif [ "$2" == "log" ]; then
    journalctl -u "${1}.service"
  else
    sudo systemctl "$2" "$1"
  fi
}

function d {
  local desk="$HOME/Desktop"
  # if [ ! -d $desk ]; then
  #   #printf "~/Desktop not found, using ${YELLOW}/tmp${NC}\n"
  #   #desk="/tmp"
  #   docker_cmd "$@"
  #   return
  # fi
  # if [ -z "$1" ]; then
  if [ -d "$desk" ]; then
    cd "$desk"
    local dir="`pwd`"
    AWESOME_SILENCE=true awesome_cd . "$1"
    if [ "`pwd`" == "$dir" ] && [ -n "$1" ]; then
      printf "Created ${YELLOW}~/Desktop/$1${NC}\n"
      mkdir "$1"
      cd "$1"
    fi
  else
    printf "${RED}${desk} not found${NC}\n"
  fi

  # "$1" is not present at this point, but we keep this code for possible change in the future
  # else
  #   dmt "$@"
  # fi
}

# moves file to desktop
function dm {
  local desk="$HOME/Desktop"

  local matching_file=''
  get_matching_file matching_file "$1"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    printf "${RED}No file matches the pattern ${YELLOW}$1${NC}\n"
  else # found file
    local target="$desk/$matching_file"
    if [ -f "$target" ]; then
      printf "Trying to move ${YELLOW}$matching_file${NC} to ${CYAN}~/Desktop${NC} ...\n"
      printf "${RED}Problem: ${YELLOW}~/Desktop/$matching_file ${NC}already exists - not overwriting${NC}\n"
      return
    else
      mv "$matching_file" "$target"
      printf "${GREEN}Moved ${YELLOW}$matching_file ${GREEN}to ${CYAN}~/Desktop${NC}\n"
    fi
  fi
}

###### Arduino

alias esp8266="cd ~/Library/Arduino15/packages/esp8266/hardware/esp8266"

function arduino {
  awesome_cd ~/Documents/Arduino/libraries "$1"
}

###### Deps management

function query {
  if [ -z "$1" ]; then
    for d in `ls -1 ~/Install/npm/` ; do
      do_query "$d"
    done
    # this is faster (done in parallel), but:
    # - we would need to move query out to ~/bin/query because xargs cannot work with functions
    # - results would be in random order
    #ls -1 ~/Install/npm | xargs -n 1 -P 10 query
  else
    local matching_folder=''
    get_matching_folder matching_folder ~/Install/npm "$1"
    matching_folder=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_folder")

    if [ -n "$matching_folder" ]; then
      do_query "$matching_folder"
    else
      printf "${RED}$1 doesn't match any package in ~/Install/npm${NC}\n"
    fi
  fi
}

function do_query {
  local matches=$(ls -l /usr/local/lib/node_modules | grep "$1" | wc -l)
  if [ ! $matches -eq 0 ]; then
    version=$(version "/usr/local/lib/node_modules/${1}")
    matches=$(ls -l /usr/local/lib/node_modules | grep "Install/npm" | grep "$1" | wc -l)

    if [ $matches == 0 ]; then
      printf "${YELLOW}${1} ${version} (unstable)${NC}\n"
    else
      printf "${GREEN}${1} ${version} (stable)${NC}\n"
    fi
  else
    printf "${RED}${1} (not linked)${NC}\n"
  fi
}



######

function message {
  if [ -z "$1" ]; then
    echo "Usage: message msg [title]"
  else
    local title=""
    if [ -n "$2" ]; then
      title="$2"
    fi
    osascript -e "display notification \"$1\" with title \"$title\""
  fi
}

function ctrl_c_trap() {
  CTRL_C=true # crap, still doesn't get called in time!!!
  echo "** Trapped CTRL-C in ~/.bash_aliases"
}

# warning: STAYS FOREVER INSIDE TERMINAL CONSOLE after first set
function set_ctrl_c_trap {
  CTRL_C=false
  trap ctrl_c_trap INT
}

function convert_to_seconds {
  local time_input="$5"
  local _seconds=0
  local _val=0
  local _desc=""
  local _denom=""

  # default is minutes!
  if [[ "$time_input" =~ [0-9]+$ ]] ; then
    #_seconds=$time_input
    _seconds=$time_input
    _val=$time_input
    _desc="${_seconds}s"
    _denom="s"
  else
    local number=${time_input:0:${#time_input}-1}
    if [[ "$time_input" =~ s$ ]] ; then
      _seconds=$number
      _val=$number
      _desc="${_seconds}s"
      _denom="s"
    elif [[ "$time_input" =~ m$ ]] ; then
      _seconds=$(( $number*60 ))
      _val=$number
      _desc="${number}m"
      _denom="m"
    elif [[ "$time_input" =~ h$ ]] ; then
      _seconds=$(( $number*3600 ))
      _val=$number
      _desc="${number}h"
      _denom="h"
    elif [[ "$time_input" =~ d$ ]] ; then
      _seconds=$(( $number*3600*24 ))
      _val=$number
      _desc="${number}d"
      _denom="d"
    fi
  fi

  eval "$1='$_seconds'"
  eval "$2='$_val'"
  eval "$3='$_desc'"
  eval "$4='$_denom'"
}

function timer {
  if [ -z "$1" ]; then
    echo "Usage: timer [1|1s|5min|2h|3d] [message]"
  else

    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"

    if [ -n "$desc" ]; then
      printf "${YELLOW}Waiting for ${desc} ...${NC}\n"

      case $denom in
        "s" )
          sleep $seconds
          # for (( i=$val; i>0; i-- ))
          # do
          #   printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
          #   sleep 1
          # done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "m" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 60
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "h" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 3600
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
        "d" )
          for (( i=$val; i>0; i-- ))
          do
            printf "${GRAY}$(date +"%H:%M") ${MAGENTA}$i ${denom} to go ...${NC}\n"
            sleep 86400
          done
          printf "${GREEN}Time's up!${NC}\n"
          ;;
      esac

      # following check won't matter because CTRL_C is not actually set to TRUE yet even if trap function ctrl_c_trap was supposedly called first (?)
      #if [ -z ${CTRL_C+x} ] || [ $CTRL_C] ; then
      #  echo $CTRL_C
      if macos; then
        shift
        local msg="$@"
        if [ -n "$msg" ]; then
          message "$msg" "${desc} is up"
        else
          message "${desc} is up" "Time's up"
        fi
      fi
    else
      printf "${RED}Error in argument${NC}\n"
    fi
  fi
}

function sleepmin {
  if [ -z "$1" ]; then
    echo "Usage:"
    echo "sleepmin [min]"
  else
    sleep $(( $1*60 ))
  fi
}

########

function repl {
  if [ -f "repl.js" ]; then
    printf "${YELLOW}Using local ./repl.js${NC}\n"
    node --use_strict ./repl.js
  else
    node --use_strict ~/Projects/scripts/repl.js
  fi
}

function get_npm_version() {
  npm --no-git-tag-version version patch
}

function npm_patch {
  local ver=$(get_npm_version)
  printf "Updated package.json to ${YELLOW}${ver}${NC}\n"
}

function publish_npm {
  local version=$(get_npm_version)
  printf "Updated package.json to ${YELLOW}${version}${NC}\n"

  git add package.json
  git commit --amend
  printf "\n${RED}Ammended to:${NC}\n"
  git log -n 1

  git tag $version
  printf "\n${BLUE}Tagged git repo with ${version}${NC}\n\n"

  npm publish
  printf "\n${MAGENTA}Published ${version}${NC}\n"
}

function tag {
  #get highest tag number
  VERSION=`git describe --abbrev=0 --tags`

  #replace . with space so can split into an array
  VERSION_BITS=(${VERSION//./ })

  #get number parts and increase last one by 1
  VNUM1=${VERSION_BITS[0]}
  VNUM2=${VERSION_BITS[1]}
  VNUM3=${VERSION_BITS[2]}
  VNUM3=$((VNUM3+1))

  #create new tag
  NEW_TAG="$VNUM1.$VNUM2.$VNUM3"

  echo "Updating $VERSION to $NEW_TAG"

  #get current hash and see if it already has a tag
  GIT_COMMIT=`git rev-parse HEAD`
  NEEDS_TAG=`git describe --contains $GIT_COMMIT`

  #only tag if no tag already (would be better if the git describe command above could have a silent option)
  if [ -z "$NEEDS_TAG" ]; then
      echo "Tagged with $NEW_TAG (Ignoring fatal:cannot describe - this means commit is untagged) "
      git tag $NEW_TAG
      git push --tags
  else
      echo "Already a tag on this commit"
  fi
}

# repl
# function re {
#   if [ -f ./mix.exs ]; then
#     printf "${YELLOW}mix console?${NC}\n"
#   elif [ -f ./package.json ]; then
#     printf "${YELLOW}node${NC}\n"
#     node
#   else
#     node
#   fi
# }

alias preety="prettier --write --print-width 160 --single-quote *.js"

function nd {
  run_on_file "$1" "node debug" '*.js'
}

# tip: install from github: npm install --save user/repo
function ni {
  if [ "`pwd`" == "/Users/${USER}/Projects/node" ]; then
    printf "${RED}Ups, get out of this directory${NC}\n"
    return
  fi

  if [ -z "$1" ]; then
    #echo "Usage: ni [npm_module]"
    if [ -f "package.json" ]; then
      npm install
    else
      node_init
    fi
  else
    if [ ! -f "package.json" ]; then
      node_init
    fi
    npm install "$@" --save
  fi
}

function node_init {
  if [ -f "package.json" ]; then
    printf "${RED}package.json already exists${NC}\n"
  else
    local name="$1"
    if [ -z "$name" ]; then
      name=$(basename "`pwd`")
    fi
    sed -e "s/<name>/${name}/g" "$DMT_PATH/etc/templates/node/package.json" > package.json
    if [ ! -f ".gitignore" ]; then
      #echo "node_modules" > .gitignore
      ignore_node
    fi
    printf "${YELLOW}package.json${NC} created with name ${CYAN}${name}${NC}\n"
  fi
}

function ignore_node {
  cp "$DMT_PATH/etc/templates/node/gitignore" .gitignore
}

function setup_linter {
  if [ ! -f "package.json" ]; then
    printf "${RED}Not in a npm project${NC}\n"
  else
    echo "Installing deps..."

    (
      export PKG=eslint-config-airbnb;
      npm info "$PKG@latest" peerDependencies --json | command sed 's/[\{\},]//g ; s/: /@/g' | xargs npm install --save-dev "$PKG@latest"
    )
    # source: https://www.npmjs.com/package/eslint-config-airbnb

    # had issues with eslint-plugin-jsx-a11y errors
    # npm install eslint-plugin-jsx-a11y --save-dev
    # npm install eslint --save-dev
    # npm install eslint-plugin-import --save-dev
    # npm install eslint-plugin-react --save-dev
    # npm install eslint-config-airbnb --save-dev

    echo
    update_linter
  fi
}

function update_linter {
  local conf="$DMT_PATH/etc/templates/node/.eslintrc.json"
  if [ -f "$conf" ]; then
    printf "${YELLOW}Copying ${conf} ...${NC}\n"
    cp "$conf" .
    printf "${GREEN}done${NC}\n"
  else
    printf "${RED}Cannot complete (or update) linter because file ${conf} is missing...${NC}\n"
  fi
}

function lint {
  if [ ! -f ./node_modules/.bin/eslint ] || [ ! -f ./.eslintrc.json ]; then
    printf "${YELLOW}Linting not setup, setting up linting first...${NC}\n"
    setup_linter
  fi
  if [ -n "$1" ]; then
    ./node_modules/.bin/eslint "$1"
  else
    printf "${YELLOW}Usage:${NC}\n"
    echo "lint [file]"
  fi
}

function restart_airplay {
  sudo systemctl restart shairport-sync
}
alias airplay_restart="restart_airplay"

function nid {
  if [ -z "$1" ]; then
    echo "Usage: nid [npm_module]"
  else
    npm install "$1" --save-dev
  fi
}

function dn {
  doc npm "$@"
}

function linked {
  #ls -l $HOME/n/lib/node_modules | grep ^l
  find /usr/local/lib/node_modules -type l -d 1 -exec ls -lah {} \;
  #RECURSIVE and SLOWER: find $HOME/n/lib/node_modules -type l -exec ls -lah {} \;

  #find ~/Dropbox -type l -exec ls -lah {} \;

  #Recursive: ls -lR $HOME/n/lib/node_modules | grep ^l
  #find "$HOME/n/lib/node_modules" -type l -name '.git' -prune -o -print | uniq | grep "$1" -i
}

function global {
  #printf "${YELLOW}/usr/local/bin/n${NC}\n"
  #echo
  local n_direct_install=~/n/lib/node_modules
  local n_homebrew_install=/usr/local/lib/node_modules

  local global_node_modules

  if [ -d $n_direct_install ]; then # installed n directly
    global_node_modules=$n_direct_install
  elif [ -d $n_homebrew_install ]; then # installed via homebrew
    global_node_modules=$n_homebrew_install
  else
    printf "${RED}n installation not found...${NC}\n"
    return
  fi


  if [ -z "$1" ]; then
    ls -la $global_node_modules
    printf "${YELLOW}${global_node_modules}${NC}\n"
    if [ -d ~/n/lib/node_modules ]; then # installed n directly
      printf "${YELLOW}n installed directly...${NC}\n"
      global_node_modules=~/n/lib/node_modules
    elif [ -d /usr/local/lib/node_modules ]; then # installed via homebrew
      printf "${YELLOW}n installed via homebrew...${NC}\n"
      global_node_modules=/usr/local/lib/node_modules
    fi
  else
    awesome_cd $global_node_modules "$1"
  fi
}

############### NODE.JS -- END

function getip {

  if [ -z "$1" ]; then
    if macos; then
      ifconfig en0 | grep broadcast

    else
      ip addr show eth0 | grep scope | grep -P 'inet \d+.\d+\.\d+\.\d+'
      ip addr show wlan0 | grep scope | grep -P 'inet \d+.\d+\.\d+\.\d+'
    fi
  else
    local resolverPath
    getDMTDeviceResolverPath resolverPath

    local line=$(node "$resolverPath" "$1" | grep "ip:")
    local arr=(${line/\:/ })
    local _ip=${arr[1]}

    if [ -n "$_ip" ]; then
      echo "$_ip"
      pi "$_ip"
    else
      local lastScanResolverPath
      getLastScanSearchScriptPath lastScanResolverPath

      printf "${CYAN}Trying most recent network scan information ...${NC}\n"
      local line=$(node "$lastScanResolverPath" "$1" | grep "ip:")
      local arr=(${line/\:/ })
      local _ip=${arr[1]}

      if [ -n "$_ip" ]; then
        echo "$_ip"
        printf "${GREEN}Found ip, trying ping...${NC}\n"
        pi "$_ip"
      else
        printf "${RED}Cannot find ip for ${CYAN}${1}${NC}\n"
      fi
    fi
  fi
}

alias psq="sudo -u postgres psql"

# fix permissions
function fixperm() {
  local dir="$1"
  if [ -z "$dir" ]; then
    dir="."
  fi
  chmod -R uog+r "$dir"
}

# fix permissions
function fixperm2() {
  local dir="$1"
  if [ -z "$dir" ]; then
    dir="."
  fi
  sudo chown -R 1000:1000 "$dir"
  chmod -R 644 "$dir"
}

function find_recent() {
  find . -type f -mmin -$1 -not -name .DS_Store -exec ls -lh {} \; | sed 's/\.\///' | awk '{print $5, substr($0,index($0,$9))}'
  #| cut -d' ' -f6-
}

alias min="find_recent 2"
alias hour="find_recent 60"
alias day="find_recent 1440"

alias mk="mkdir"
alias mkp="mkdir -p"
k () { mkdir -p "$@" && cd "$_"; }

# sum column of numbers...
# 1 lala
# 234 aaavdfv
# 54 sdfdsf
function total {
  cat $1 | awk '{s+=$1} END {printf "Sum: %.0f\n", s}'
}

alias aria="aria2c" # http://aria2.sourceforge.net/ - The next generation download utility.

function wh {

  if [[ "$1" =~ \.com$ ]]; then
    local match=$(whois "$1" | grep "No match for domain" | wc -l)
    if [ ! $match -eq 0 ]; then
      printf "${GREEN}${1} is available${NC}\n"
    else
      printf "${RED}${1} not available${NC}\n"
    fi
  elif [[ "$1" =~ \.io$ ]]; then
    local match=$(whois "$1" | grep "NOT FOUND" | wc -l)
    if [ ! $match -eq 0 ]; then
      printf "${GREEN}${1} is available${NC}\n"
    else
      printf "${RED}${1} not available${NC}\n"
    fi
  elif [[ "$1" =~ \.eu$ ]]; then
    local match=$(whois "$1" | grep "Status: AVAILABLE" | wc -l)
    if [ ! $match -eq 0 ]; then
      printf "${GREEN}${1} is available${NC}\n"
    else
      printf "${RED}${1} not available${NC}\n"
    fi
  else
    whois "$1"
  fi
}

function root {
  if macos; then
    sudo bash -l # makes process substitution (<) work: https://unix.stackexchange.com/questions/42973/bash-process-substitution-does-not-work-as-root-on-os-x
  else
    sudo -i
  fi
}

alias pb=pbcopy

alias fd="sudo fdisk -l"

# iterm2
alias normal='echo -e "\033]50;SetProfile=Default\a"'
alias large='echo -e "\033]50;SetProfile=LargeFont\a"'

#brew install highlight
#alias pcat="pygmentize -f terminal256 -O style=monokai -g"
function hcat {
  highlight -O xterm256 -s darkbone "$@"
}

# Save temporary command in ~/Desktop
#
function temp_cmd {
  local cmd=~/Desktop/temp_cmd

  if [ "$1" == "remove" ] && [ -f "$cmd" ]; then
    rm $cmd
    printf "${YELLOW}~/temp_cmd deleted${NC}\n"
    return
  fi

  if [ -f "$cmd" ]; then
    chmod u+x $cmd
    local contents=`cat $cmd`
    printf "${YELLOW}${contents}${NC}\n"
    $cmd
  else
    nano "$cmd"
    if [ -f "$cmd" ]; then
      chmod u+x $cmd
      local contents=`cat $cmd`
      printf "Command saved: ${YELLOW}${contents}${NC}\n\n"
      printf "You can run it with: ${MAGENTA}temp_cmd${NC}\n"
    fi
  fi
}

# themes: highlight -w
# in sublime there is SublimeHighlight plugin (use for Elixir since there is no Elixir syntax in highlight)
function code {
  if [ -z "$1" ]; then
    echo "Copies code in rtf format for slides"
    echo
    echo "code example.js"
    echo "code themes"
    echo "code example.js dark"
    echo "code example.js [theme]"
  else
    local theme="bright"
    if [ -n "$2" ]; then
      if [ "$2" == 'dark' ]; then
        theme="darkbone"
      else
        theme="$2"
      fi
    fi

    if [ "$1" == 'themes' ]; then
      highlight -w
    else
      highlight -O rtf -s $theme $1 | pb
    fi
    # moe, acid
  fi
}

function snip {
  snippet "$@"
}

function snippet {

  local sublime_snippets_folder="/Users/${USER}/Library/Application Support/Sublime Text 3/Packages/User/"

  if [ -z "$1" ] || [ "$1" == "-h" ]; then
    #printf "${YELLOW}Usage:${NC}\n"
    #echo "${opts[@]}"
    ls "$sublime_snippets_folder" | grep "snippet$"
    echo
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}snippet edit [keyword]${NC} ${GRAY}edit${NC}\n"
    printf "${GREEN}snippet create [keyword]${NC} ${GRAY}create and edit (ext is added automatically)${NC}\n"
    printf "${GREEN}snippet cd${NC} ${GRAY}move to directory with snippets${NC}\n"
    return
  fi

  declare -a opts=(
    "edit"
    "create"
    "cd"
  )

  local matching_opt=''
  opts_matcher matching_opt "$1" "${opts[@]}"
  if [ $? -ne 0 ]; then # error
    matching_opt="[DEFAULT]" # default ... will trigger *) case below
  fi

  shift

  case "$matching_opt" in
    edit)
       local dir="`pwd`"
       cd "$sublime_snippets_folder"
       run_on_file "$1" "subl" '*.sublime-snippet'
       cd "$dir"
      ;;

    create)
        local dir="`pwd`"
        cd "$sublime_snippets_folder"
        local snippet_file="${1}.sublime-snippet"
        cat > "${snippet_file}" <<EOF
<snippet>
  <content><![CDATA[
const \${1} = require('\${1}');
]]></content>
  <!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
  <tabTrigger>require</tabTrigger>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <scope>source.js</scope>
</snippet>
EOF
        subl "${snippet_file}"
        cd "$dir"
      ;;

    cd)
      cd "$sublime_snippets_folder"
      ;;

    *)
      ls -1 "$sublime_snippets_folder" | grep "snippet$" | grep "$@"
      ;;
  esac
}

# utility function
function current_usage {
  local output=$(du -sh | awk '{ print $1 }')
  printf "${YELLOW}${output}${NC}\n"
}

function freespace {
  printf "Free:\t ${GREEN}`df -h . | tail -1 | awk '{ print $4 }'`${NC}\n"
}

function space {
  local dir="`pwd`"
  if [ -n "$1" ]; then
    if [ -d "$1" ]; then
      dir="$1"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  if [ ! "$dir" == $HOME ] && [ ! "$dir" == '/' ]; then
    if [ "$dir" == "`pwd`" ]; then
      printf "Current: "
      current_usage
    else
      printf "${dir}: "
      local cwd="`pwd`"
      cd "$dir"
      current_usage
      cd "$cwd"
    fi
  fi
  freespace
}

# utility function
function usage_for {
  printf "${1} "
  if [ -d "${1}" ]; then
    cd "$1"
    current_usage
  else
    printf "${RED}No such directory${NC}\n"
  fi
}

function usage {
  if macos; then
    #ls -1d -- */ | xargs -I{} du -sh -- {} | gsort -hr # probably need: "brew install coreutils" for gsort
    find . -maxdepth 1 -type d -print0 | xargs -0 -I{} du -sh {} | gsort -hr # probably need: "brew install coreutils" for gsort
  else
    find . -maxdepth 1 -type d -print0 | xargs -0 -I{} du -sh {} | sort -hr
    #ls -1d */ | xargs -I{} du -sh {} | sort -hr
  fi
  #ls -1d */ | xargs -I{} du -sh {} && du -sh | sort -r
}

function count {

  local dir=""
  if [ -z "$1" ]; then
    dir="."
  else
    if [ -d "$1" ]; then
      dir="$1"
      printf "${YELLOW}${dir}:${NC}\n"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  printf "${CYAN}Directories: "
  find "$dir" -maxdepth 1 ! -path . ! -path "*/.git" -type d | wc -l | xargs
  printf "${GREEN}Files:       "
  find "$dir" -maxdepth 1 ! -path "*/.DS_Store" ! -path "*/.git" -type f | wc -l | xargs
  printf "${NC}"

  # echo
  # printf "${CYAN}Directories (Recursive): "
  # find "$dir/" ! -path . ! -path "*/.git/*" -type d | wc -l | xargs # "/" is needed if we use "count ~/path/to/symlinked_directory", it's changed to: "count ~/path/to/symlinked_directory/"
  # printf "${GREEN}Files: (Recursive):      "
  # find "$dir/" ! -path "*/.DS_Store" ! -path "*/.git/*" -type f | wc -l | xargs
  # printf "${NC}"
}

function countr {

  count "$@"

  local dir=""
  if [ -z "$1" ]; then
    dir="."
  else
    if [ -d "$1" ]; then
      dir="$1"
      printf "${YELLOW}${dir}:${NC}\n"
    else
      printf "${RED}No such directory${NC}\n"
      return
    fi
  fi

  echo
  printf "${CYAN}Directories (Recursive): "
  find "$dir/" ! -path . ! -path "*/.git/*" -type d | wc -l | xargs # "/" is needed if we use "count ~/path/to/symlinked_directory", it's changed to: "count ~/path/to/symlinked_directory/"
  printf "${GREEN}Files: (Recursive):      "
  find "$dir/" ! -path "*/.DS_Store" ! -path "*/.git/*" -type f | wc -l | xargs
  printf "${NC}"
}

function lines {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}lines [file.txt] ${GRAY}counts the number of lines in the file${NC}\n"
  else
    cat "$1" | wc -l
  fi
}

function space2rem {
  if [ "$EUID" -ne 0 ]; then
    echo "please run under root - execute: root"
    return
  fi
  find /var/folders -name "*.iscachebmp" -type f -exec rm -v "{}" \;
  find /private/var/folders -name "*.iscachebmp" -type f -exec rm -v "{}" \;
}

# swap files or directories
function swap {
  if [ -n "$1" ] && [ -n "$2" ]; then
    swap_once "$1" "$2"
  elif [ -f "config.json.sample" ] && [ -f "config.json" ]; then
    swap_once "config.json.sample" "config.json"
  elif [ -f "david_wallet" ] && [ -f "default_wallet" ]; then
    swap_once "david_wallet" "default_wallet"
  fi
}

function swap_once {
  mv "$1" /tmp/switch_temp
  mv "$2" "$1"
  mv /tmp/switch_temp "$2"
}

# rename file or directory by adding _ at the end
# or if _ is present, remove it
function ren {
  local subject
  if [[ "$1" == */ ]]; then
    subject=$(echo "$1" | sed 's/.$//')
  else
    subject="$1"
  fi

  local new
  if [[ "$subject" == *_ ]]; then
    new=$(echo "$subject" | sed 's/.$//')
  else
    new="${subject}_"
  fi

  mv "$subject" "$new"
}

# Example:
#
# $ find . | grep core_ext
# ./config/initializers/core_ext.rb
# ./spec/lib/core_ext_spec.rb
#
# $ grab 2
# ./spec/lib/core_ext_spec.rb ===> (also copied on clipboard)
#
# Without arguments the default is to grab the first line
grab() {
  local num=1
  if [ -n "$1" ]; then
    num=$1
  fi
  local line=`$(history | tail -2 | head -1 | cut -d" " -f4-) | sed "${num}q;d" | sed 's/commit //'`
  echo $line | tr -d "\n" | pbcopy
  echo $line
}

function chrome {
  "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --disable-new-avatar-menu &
}

function sleepin {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC} sleepin 10 (min)\n"
  else
    local delay=$(($1*60))
    sleep $delay && pmset sleepnow # with && - if you cancel with ctrl+c it works correctly (semicolon doesn't!)
  fi
}

alias pumar="kill -SIGUSR2 `ps aux | grep tcp://0.0.0.0:$port | grep puma | awk '{ print $2 }'`"
alias updatedb="sudo /usr/libexec/locate.updatedb"

alias blackie="cd /Volumes/BLACKIE/Backups.backupdb/eclipse/Latest/Macintosh\ HD$HOME"
alias sublime="cd '$HOME/Library/Application Support/Sublime Text 3/Packages/User'"

# ping server (ex. server.com) or "resource" (http://server.com/file)
function pi {
  local target="1.0.0.1"
  if [ -n "$1" ]; then
    if [[ "$1" =~ \/ ]]; then
      if [[ $(curl -I --write-out %{http_code} --silent --output /dev/null "$@") == "200" ]]; then
        printf "${GREEN}OK${NC}\n"
      else
        printf "${RED}NOT FOUND${NC}\n"
      fi
    else
      if [[ $(ping -c 1 "$@" 2>&1) == *"0% packet loss"* ]]; then
        printf "${GREEN}Ping OK${NC}\n"
      else
        printf "${RED}NO CONN${NC}\n"
      fi
    fi
  else
    if [[ $(ping -c 1 "$target" 2>&1) == *"0% packet loss"* ]]; then
      printf "${GREEN}Ping OK${NC}\n"
    else
      printf "${RED}NO CONN${NC}\n"
    fi
  fi
}

function ux {
  matching_file=''
  get_matching_file matching_file "$1"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ -f "$matching_file" ]; then
    printf "chmod u+x ${YELLOW}$matching_file${NC}\n"
    chmod u+x "$matching_file"
  else
    printf "${RED}File not found${NC}\n"
  fi
}

function archive {
  if [ -n "$1" ]; then
    mv $1 ~/Misc/Archive/
  else
    cd ~/Misc/Archive/
  fi
}

function archive_short {
  if [ -n "$1" ]; then
    mv $1 ~/Misc/Archive/Short\ Term/
  else
    cd ~/Misc/Archive/Short\ Term/
  fi
}

function ap {
  local script="$DMT_SCRIPTS/setup_ap"
  if [ -f "$script" ]; then
    sudo "$script" "$@"
  else
    printf "${RED}missing ${script}${NC}\n"
  fi
}

function part {
  local script="$DMT_SCRIPTS/part"
  if [ -f "$script" ]; then
    sudo "$script" "$@"
  else
    printf "${RED}missing ${script}${NC}\n"
  fi
}

function glog {
  if [ -d ".git" ]; then
    clear
    if [ -z "$1" ]; then
      git log -3
    else
      git log -"$1"
    fi
  else
    printf "${RED}Not a git repository${NC}\n"
  fi
}

function getlog {
  remote -h "$1" "cat /var/log/syslog | grep shairpo > /tmp/log.txt"
  scp "${1}:/tmp/log.txt" .
}

function remove_ds_store {
  find . -name ".DS_Store" -depth -exec rm {} \;
}

function remove_ds_global {
  sudo find / -name ".DS_Store" -depth -exec rm {} \;
}

function nuke {
  local dir="`pwd`"
  local user=`whoami`
  local dir_levels=$(grep -o "/" <<< "$dir" | wc -l)

  local homedir="/home/${user}"
  if macos; then
    homedir="/Users/${user}"
  fi

  if [ "$user" != "root" ] && [[ $dir == $homedir* ]] && [ $dir_levels -gt 3 ]; then
    if macos; then
      cd ..
      (~/Projects/backups/nuke.rb "$dir" &)
      printf "${GREEN}Moved to ~/Misc/Archive/Nuked${NC}\n"
      #~/Projects/backups/nuke.rb "$dir"
      # read -r -p "Nuke ${dir}? [Y/n] " response
      # if [[ ! $response =~ ^([nN])$ ]]
      # then
      #   cd ..
      #   rm -rf $dir
      # fi
    else
      cd ..
      local tempdir=$(mktemp -d)
      mv "$dir" "$tempdir"
      printf "${GREEN}Moved to $tempdir${NC}\n"
    fi
  else
    printf "${RED}Refused!${NC} Has to be at least two levels into HOME dir and cannot be root.\n"
  fi
}

# *** nginx on server ***

alias ci="curl -I"

function nginx_executable() {
  local executable2
  if [ -f "/usr/sbin/nginx" ]; then
    executable2="/usr/sbin/nginx"
  elif [ -f "/opt/nginx/sbin/nginx" ]; then
    executable2="/opt/nginx/sbin/nginx"
  elif [ -f "/usr/local/bin/nginx" ]; then
    executable2="/usr/local/bin/nginx"
  else
    executable2=""
  fi
  eval "$1=${executable2}"
}

function nr {
  # lighttpd
  if [ -f /etc/lighttpd/lighttpd.conf ]; then
    printf "${YELLOW}Found lighttpd, reloading configuration...${NC}\n"

    if macos; then

      # if pid file is found,
      # - there is no process with this pid, try to start lighttpd
      # - if there is a process with this pid, send it a kill signal (reloads the configuration)
      if [ -f /var/run/lighttpd.pid ]; then
        local pid=$(cat /var/run/lighttpd.pid)

        local procs=$(ps -p $pid -o comm=) # find process executable by process id

        if [ "$procs" == "" ]; then # lighttpd is not there
          printf "${RED}lighttpd is not running (stale .pid file, possible configuration error!!)...${NC}\n"
          printf "${YELLOW}trying to start it...${NC}\n"
          sudo /usr/local/bin/lighttpd -f/etc/lighttpd/lighttpd.conf -D
        else
          sudo kill -9 $pid
        fi
      else
        printf "${YELLOW}lighttpd is not running...${NC}\n"
        printf "${YELLOW}trying to start it...${NC}\n"
        sudo /usr/local/bin/lighttpd -f/etc/lighttpd/lighttpd.conf -D
        return
      fi
    else
      sudo service lighttpd force-reload
    fi
    #printf "${GREEN}ok.${NC}\n"
    return
  fi

  # nginx
  if hash service 2>/dev/null; then
    service nginx reload
  else
    local executable=''
    nginx_executable executable

    if [ -n "$executable" ]; then
      local output
      if macos; then
        output=$($executable -s reload 2>&1)
      else
        output=$(sudo $executable -s reload 2>&1)
      fi
      if [ -z "$output" ]; then
        printf "${GREEN}OK${NC}\n"
      else
        printf "${RED}${output}${NC}\n"
      fi
    else
      if [ -f "/etc/init.d/nginx" ]; then
        sudo /etc/init.d/nginx restart
      else
        printf "${RED}Can't find nginx${NC}\n"
      fi
    fi
  fi
}

alias nr2="sudo service nginx restart"

function nt {
  # lighttpd
  if [ -f /etc/lighttpd/lighttpd.conf ]; then
    #printf "${YELLOW}Found lighttpd, reloading configuration...${NC}\n"
    local cmd="lighttpd"
    if [ -f /usr/sbin/lighttpd ]; then # on debian it wasn't in path after install
      cmd="/usr/sbin/lighttpd"
    fi
    $cmd -t -f /etc/lighttpd/lighttpd.conf
    printf "${YELLOW}Warning: even if syntax is ok, lighttpd might fail to run for semantic reasons${NC}\n"
    printf "${YELLOW}when using nr for restating, run twice to be sure!${NC}\n"
    return
  fi

  # nginx
  if [ -d /opt/nginx ]; then
    printf "Folder: ${YELLOW}/opt/nginx${NC}\n"
  elif [ -d /etc/nginx ]; then
    printf "Folder: ${YELLOW}/etc/nginx${NC}\n"
  fi

  local executable=''
  nginx_executable executable

  if [ -z "$executable" ]; then
    printf "${RED}Can't find nginx executable${NC}\n"
  fi

  if [ -n "$executable" ]; then
    printf "Executable: ${YELLOW}${executable}${NC}\n"
    local output
    if macos; then
      output=$($executable -t 2>&1)
    else
      output=$(sudo $executable -t 2>&1)
    fi
    if [[ $output == *"test is successful"* ]]; then
      printf "${GREEN}${output}${NC}\n"
    else
      printf "${RED}${output}${NC}\n"
    fi
  fi
}

function ne {
  if macos; then
    tail -f /var/log/nginx/error.log
  else
    sudo tail -f /var/log/nginx/error.log
    #printf "${RED}Not on the server${NC}\n"
  fi
}

function sites {
  if macos; then
    #cd ~/Sites
    cd /usr/local/etc/nginx/servers
  else
    if [ -d /opt/nginx/conf/sites/ ]; then
      cd /opt/nginx/conf/sites/
    elif [ -d /etc/nginx/sites ]; then
      cd /etc/nginx/sites
    elif [ -d /etc/nginx/sites-available ]; then
      cd /etc/nginx/sites-available
    elif [ -d /etc/apache2/sites-available ]; then
      cd /etc/apache2/sites-available
    else
      printf "${RED}Can't find nginx sites folder${NC}\n"
    fi
  fi

  if [ -n "$1" ]; then
    if [ "$1" == "ports" ]; then
      grep -r "localhost" .
    else
      grep -r "localhost" . | grep "$1"
    fi
  fi
}

function hosts {
  if [ -f /private/etc/hosts ]; then
    sudo nano /private/etc/hosts
  elif [ -f /etc/hosts ]; then
    sudo nano /etc/hosts
  else
    printf "${RED}Cannot find hosts file${NC}\n"
  fi
}

# ******

alias list="ls -la | grep"

function ta {
  tail -n 25 "$@"
}

function ta50 {
  tail -n 50 "$@"
}

function ta100 {
  tail -n 100 "$@"
}

# function v() {
#   if [[ "$1" == *".js" ]]; then
#     echo '"use strict"' > $1
#   else
#     touch "$1"
#   fi
# }

# function copp {
#   pwd | sed 's/\/Users\/david/~/' | tr -d '\n' | pbcopy
# }

# MacOS niceties

function lock {
  if [ -n "$1" ]; then
    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"
    sleep $seconds
  fi

  /System/Library/CoreServices/ScreenSaverEngine.app/Contents/MacOS/ScreenSaverEngine
}

function lock2 {
  if [ -n "$1" ]; then
    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"
    sleep $seconds
  fi

  /System/Library/CoreServices/"Menu Extras"/User.menu/Contents/Resources/CGSession -suspend
}

function off {
  #trap 'return' INT

  if [ -n "$1" ]; then
    local seconds=0
    local val=0
    local desc=""
    local denom=""

    convert_to_seconds seconds val desc denom "$1"
    sleep $seconds
  fi

  #alarm light off # crap dependecy!!! what if network or target device is unreachable, it could hang here

  pmset sleepnow
}

function suck {
     #--recursive \
     #--html-extension \
     #--no-parent
     #--wait=9 \
     # -U mozilla \
     #--exclude-domains quantserve.com
     #--domains filepi.com
     #--limit-rate=20K \

  # mirror ? -m

  domain=`ruby -ruri -e "puts URI.parse('$1').host"`

  mkdir -p "$domain"
  cd "$domain"

  wget \
     --page-requisites \
     --convert-links \
     --adjust-extension \
     --html-extension \
     --random-wait \
     --domains $domain \
     --no-check-certificate \
     --span-hosts \
     -e robots=off \
     -U "Mozilla/5.0 (X11; U; Linux; en-US; rv:1.9.1.16) Gecko/20110929 Firefox/3.5.16" \
       $1

  printf "\n${YELLOW}Got all resources from $domain. To get all of them, remove --domains flag and run again${NC}\n"
}

alias suckjs="phantomjs ~/Projects/scripts/save_page.js"

# miha's solution: https://gist.github.com/mrfoto/c6072e4fede3a6fe0f6b
function ssh {
  if [ -f /usr/local/bin/sshrc ]; then
    printf "\033]6;1;bg;red;brightness;162\a\033]6;1;bg;green;brightness;209\a\033]6;1;bg;blue;brightness;147\a"
    #https://www.iterm2.com/documentation-escape-codes.html
    #echo -e "\033]6;1;bg;green;brightness;0\a"
    command sshrc "$@"
    # caused problems ....
    # now we still have a problem when trying to log into OpenWRT (dropbear) powered ssh for example...)
    # if [ ! $? -eq 0 ]; then
    #   printf "${MAGENTA}Failed ssh via sshrc, trying /usr/bin/ssh${NC}\n"
    #   /usr/bin/ssh "$@"
    # fi
    echo -e "\033]6;1;bg;*;default\a"
  else
    command ssh "$@"
  fi
}

function ssh2 {
  command ssh "$@"
}

# iperf2
function speed {
  local host=''
  if [ -n "$1" ]; then
    host="$1"
  else
    local network_id=''
    network_def_reader host network_id "iperf"
  fi

  if [ -z "$host" ]; then
    printf "${RED}Host not specified either as a first argument or in networks.def (iperf: [ip]])${NC}\n"
    return
  fi

  which iperf > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    printf "${GREEN}Measuring...${NC}\n"
  else
    printf "${MAGENTA}iperf is missing, installing...${NC}\n"
    sudo apt-get -y install iperf
    printf "\n${GREEN}Testing...${NC}\n"
  fi

  iperf -c "$host"
}

function speed3 {
  local host=''
  if [ -n "$1" ]; then
    host="$1"
  else
    local network_id=''
    network_def_reader host network_id "iperf"
  fi

  if [ -z "$host" ]; then
    printf "${RED}Host not specified either as a first argument or in networks.def (iperf: [ip]])${NC}\n"
    return
  fi

  if [ "$1" == "-h" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}speed${NC} ${GRAY}measures sending to default host${NC}\n"
    printf "${GREEN}speed [host]${NC} ${GRAY}specify another host${NC}\n"
    printf "${GREEN}speed [host] -R${NC} ${GRAY}reverse mode - server is sending${NC}\n"
    printf "${GREEN}speed [host] -u${NC} ${GRAY}udp test${NC}\n"
    return
  fi

  if [ -n "$1" ] && [[ "$1" != "-"* ]]; then
    host="$1"
    shift
  fi

  which iperf3 > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    printf "${GREEN}Measuring...${NC}\n"
  else
    printf "${MAGENTA}iperf3 is missing, installing...${NC}\n"
    sudo apt-get -y install iperf3
    printf "\n${GREEN}Testing...${NC}\n"
  fi

  iperf3 $@ -c $host
}

function reset_npm {
  rm -rf node_modules
  npm cache clean
  npm install
}

alias np="npm publish"

function json {
  curl -s "$1" | jq .
}

# post_json data.json localhost:3000/api/readings
function post_json {
  curl -H "Content-Type: application/json" -d @"$1" "$2"
}

function ee {
  if macos; then
    awesome_cd ~/Misc/Electronics "$1"
  fi
}

# function play {
#   run_on_file "$1" "afplay" '*'
# }

function flash_usage {
  local sectors="$1"
  printf "${YELLOW}Usage:${NC}\n"
  printf "${GREEN}flash image.img 2${NC} ${GRAY}flash image.img to /dev/rdisk2${NC}\n"
  printf "${GREEN}flash read 2${NC} ${GRAY}read full image from /dev/rdisk2 to ./image.img${NC}\n"
  printf "${GREEN}flash read 2 16gb${NC} ${GRAY}read sectors 0..${sectors} from /dev/rdisk2 to ./image.img${NC}\n"
  #printf "${GREEN}flash read 2 default${NC} ${GRAY}read sectors 0..${sectors} from /dev/rdisk2 to ./image.img${NC}\n"
  printf "${GREEN}flash read 2 [nSectors]${NC} ${GRAY}read sectors 0..nSectors from /dev/rdisk2 to ./image.img${NC}\n"
}

function flash {
  local file_pattern="$1"
  local disk_n="$2"

  #local defaultSectors="20000768" # 9.5GB, divisible by 4096 for optimal sector alignment
  local sectors16gb="31116288" # 16GB


  if [ "$1" == "-h" ] || [ -z "$1" ]; then
    printf "${YELLOW}diskutil list:${NC}\n\n"
    diskutil list
    flash_usage "$sectors16gb"
    return
  fi

  if [ -z "$file_pattern" ]; then
    printf "${YELLOW}diskutil list:${NC}\n\n"
    diskutil list
    printf "${YELLOW}Usage:${NC}\n"
    echo "flash file.img diskN"
    return
  fi

  if [ "$1" == "read" ]; then
    if [ -z "$disk_n" ]; then
      printf "${YELLOW}diskutil list:${NC}\n\n"
      diskutil list

      printf "${MAGENTA}You have to specify the disk number from where to create the image${NC}\n"
      echo

      flash_usage "$sectors16gb"
    else
      local image="image.img"

      if [ -f "$image" ]; then
        printf "${RED}image.img already exists${NC}\n"
        return
      fi

      if [ -z "$3" ]; then
        printf "${GREEN}Copying full image to ${YELLOW}${image}${NC}\n"
        sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=64k
      else
        local sectors

        if [ "$3" == "16gb" ] || [ "$3" == "16GB" ]; then
          printf "${GREEN}Reading first 16gb from sd card ... ${NC}\n"
          sectors="$sectors16gb"
        else
          sectors="$3"
        fi

        printf "${GREEN}Copying sectors${NC} 0..${sectors} to ${YELLOW}${image}${NC}\n"

        # Usually the number of sectors will be a multiple of some power of 2, and you can increase the copying speed
        # by increasing the block size and decreasing the count, keeping the product constant.
        if ! (( $sectors % 64 )) ; then
          printf "${MAGENTA}Optimal speed: number of sectors divisible by 64 - reading 128 sectors (64K) at a time${NC}\n"
          # for default 20000000 sectors it takes around 150s to copy data from sd card
          # 1 sector = 512b
          # 64K seems to be quite optimal, no difference with 1M, but faster than 32K or less
          sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=64k count="$((sectors/128))"
        elif ! (( $sectors % 32 )) ; then
          printf "${MAGENTA}Almost optimal speed: number of sectors divisible by 32 - reading 64 sectors (32K) at a time${NC}\n"
          sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=32k count="$((sectors/64))"
        else
          sudo dd if="/dev/rdisk${disk_n}" of="${image}" bs=512 count="${sectors}"
        fi
      fi

      if [ -f "image.img" ]; then
        sudo chown $(whoami) image.img
        if macos; then
          sudo chgrp staff image.img
        fi
      fi
    fi

    return
  fi

  matching_file=''
  get_matching_file matching_file "$file_pattern"
  matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

  if [ ! -f "$matching_file" ]; then
    printf "${RED}No such file: ${file_pattern}${NC}\n"
  else
    if [ -z "$disk_n" ]; then
      printf "${YELLOW}diskutil list:${NC}\n\n"
      diskutil list

      printf "${MAGENTA}You have to specify the disk number where to flash ${GREEN}${matching_file}${NC}\n"
      echo

      flash_usage "$sectors"
    else
      printf "Flashing ${YELLOW}${matching_file}${NC} to ${RED}rdisk${disk_n}${NC}...\n"
      read -r -p "Sure????? (you will be asked for sudo password) [Y/n] " response
      if [[ ! $response =~ ^([nN])$ ]]
      then
        printf "${YELLOW}Flashing after password...${NC} Press Ctrl+T to see progress\n"
        diskutil unmountDisk "/dev/disk${disk_n}"
        sudo dd if="$matching_file" of="/dev/rdisk${disk_n}" bs=1m
        diskutil eject "/dev/disk${disk_n}"
        printf "${GREEN}done.${NC} ${YELLOW}You can take the SD card out now.${NC}\n"
      fi
    fi
  fi
}

function vol2 {
  local origin="`pwd`"
  local IFS=$'\n' # default is " " and then array is not correctly constructed when there is spaces in filenames
  cd `find /Volumes -maxdepth 1 -type d ! -path . | grep -v "/Volumes$" | grep -v "Macintosh HD" | grep -v "WINDOWS" | grep -v "volume2"`
  if [ -n "$1" ]; then
    awesome_cd . "$1"
    if [ $? -eq 1 ]; then
      cd "$origin"
    fi
  fi
}

function cpd {
  cp $1 ~/Desktop/
}

function md {
  if [ -f "$1" ] || [ -d "$1" ]; then
    mv "$1" ~/Desktop
    if [ $? -eq 0 ]; then
      printf "${YELLOW}Moved ${1} to ~/Desktop\n"
    fi
  else
    printf "${RED}No such file or directory${NC}\n"
  fi
}

function yd {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}yd [id]${NC} - ${GRAY}download a video${NC}\n"
    printf "${GREEN}yd [id1] [id2] [id3]${NC} - ${GRAY}download multiple videos${NC}\n"
    printf "${GREEN}yd [playlistId]${NC} - ${GRAY}download a playlist${NC}\n"
    printf "${GREEN}yd --autonumber [playlistId]${NC} - ${GRAY}download a playlist, autonumbered${NC}\n"
    return
  fi

  if [ "$1" == "--autonumber" ]; then
    shift
    ydpl "$@"
    return
  fi

  if [ -z "$2" ]; then
    youtube-dl -- "$1"
  else
    for var in "$@"
    do
      yd "$var"
    done
  fi
}

function ydpl {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}ydpl [playlistId]${NC} ${GRAY}downloads autonumbered playlist${NC}\n"
    return
  else
    youtube-dl -i -o "%(playlist_index)s %(title)s - %(id)s.%(ext)s" -- "$1"
    #youtube-dl -o "%(playlist_index)s-%(title)s - %(id)s.%(ext)s" -- "$1"
  fi
}

function mp3_helper {
  # duplicate
  ffmpeg -i "$1" -acodec libmp3lame -aq 2 "$1".mp3
}

function mp3 {

  if [ "$1" == "." ]; then
    find *.m4a -type f | xargs -I@ bash -c "$(declare -f mp3_helper) ; mp3_helper \"@\" "
    return
  fi

  if [ -z "$2" ]; then
    if [ -f "$1" ]; then
      ffmpeg -i "$1" -acodec libmp3lame -aq 2 "$1".mp3
      # batch --
      # for foo in *.m4a; do ffmpeg -i "$foo" -acodec libmp3lame -aq 2 "${foo%.m4a}.mp3"; done
    else
      youtube-dl -x --audio-format mp3 -- "$1"
    fi
  else
    for var in "$@"
    do
      mp3 "$var"
    done
  fi
}


function mp4 {
  if [ -n "$1" ]; then
    for file in "$@"
    do
      if [ -f "$file" ]; then
        # http://www.bugcodemaster.com/article/convert-videos-mp4-format-using-ffmpeg
        ffmpeg -i "$file" "$file".mp4 -preset veryfast
      else
        echo "File $file doesn't exist"
      fi
    done
  else
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}mp4 file1 file2 file3 ...${NC} ${GRAY}convert different video formats to mp4${NC}\n"
  fi
}


alias vlc="open -n /Applications/VLC.app"

# Requirement for static server: npm install -g http-server
# Other: elixir, mina, jekyll, node, npm
function serve {
  if [ -f ./server ]; then
    printf "${YELLOW}./server $1${NC}\n"
    ./server $1
  elif [ -f ./mix.exs ]; then
    printf "${YELLOW}mix phoenix.server${NC}\n"
    mix phoenix.server
    # or: iex -S mix phoenix.server
  elif [ -f ./server.js ]; then
    printf "${YELLOW}node server.js${NC}\n"
    node server.js
  elif [ -f ./package.json ] && [ $(ls-scripts | grep 'vue-cli' | wc -l) -gt 0 ]; then
    npm run serve
  # npm install -g npm-ls-scripts
  elif [ -f ./package.json ] && [ $(ls-scripts | grep '^start' | wc -l) = 1 ]; then
    printf "${YELLOW}npm run start${NC}\n"
    npm run start
  elif [ -f ./truffle.js ]; then
    printf "${YELLOW}testrpc --port 8700${NC}\n"
    testrpc --port 8700
  elif [ -f ./index.js ]; then
    local args=$@
    printf "${YELLOW}nodemon index.js ${args}${NC}\n"
    nodemon index.js $args
  elif [ -f ./elm-package.json ]; then
    printf "${YELLOW}elm reactor${NC}\n"
    elm reactor
    #elm-reactor
  elif [ -d _site ]; then
    printf "${YELLOW}jekyll serve${NC}\n"
    jekyll serve
  else
    printf "${YELLOW}http-server -p 3000${NC}\n"
    http-server -p 3000
  fi
}

alias ra="touch index.js"

function tests {

  # test single file
  if [ -n "$1" ] && [ -d "tests" ]; then

    local pattern="$1"
    shift

    local matching_file=''
    get_matching_file matching_file "tests/$pattern" "*.js"
    matching_file=$(sed "s/111SINGLE___QUOTE111/'/g" <<< "$matching_file")

    if [ ! -f "$matching_file" ]; then
      return
    fi

    printf "${YELLOW}tape ${matching_file} | tap-spec${NC}\n"

    tape "$matching_file" | tap-spec
  else

    if [ -f ./test ]; then
      printf "${YELLOW}./test ${1}${NC}\n"
      ./test "$1"
    fi

    #if grep -Fq '"test":' package.json
    if [ -f 'package.json' ] && [ -d "tests" ]; then

      which tape > /dev/null 2>&1

      if [ $? -ne 0 ]; then
          printf "${RED}missing 'tape' command${NC}\n"
          printf "${YELLOW}npm install -g tape${NC}\n"
          return
      fi

      which tap-spec > /dev/null 2>&1

      if [ $? -ne 0 ]; then
          printf "${RED}missing 'tap-spec' command${NC}\n"
          printf "${YELLOW}npm install -g tap-spec${NC}\n"
          return
      fi

      if grep -Fq '"tape"' package.json
      then

        printf "${YELLOW}tape 'tests/**/*.js'${NC}\n"
        tape 'tests/**/*.js' | tap-spec

        # printf "${YELLOW}npm run test${NC}\n"
        # npm run test

        # if grep -Fxq "import test from 'ava'" test.js
        # then
        #   ava
        # else
        #   printf "${YELLOW}NODE_ENV=test node test.js${NC}\n"
        #   NODE_ENV=test node test.js
        # fi
      # elif [ -d "tests" ]; then
      #   printf "${YELLOW}tape 'tests/**/*.js' | tap-spec${NC}\n"
      #   tape 'tests/**/*.js' | tap-spec
      else
        if [ -f "package.json" ]; then
          if grep -Fq '"test":' package.json
          then
            printf "${YELLOW}npm run test${NC}\n"
            npm run test
            #printf "${RED}Tests not defined${NC}\n"
          fi
        fi
      fi
    fi
  fi
}

function makedocs {
  documentation build "$@" -f html -o docs --shallow
}

function doc {
  node ~/Projects/node/docs/doc.js "$@"
}

# https://gist.github.com/davidhq/9883d43146d1fb2c2c00

# function source_code {
#   local matching_files=$(find . -name "*.${2}" -not -path "*/.git/*" -not -path "*/node_modules/*" -not -path "*/Godeps/*" -not -path "*/elm-stuff/*" -not -path "*/deps/*" -not -path "*/_build/*" -not -path "*/target/*" -not -path "*/dist/*" -not -path "*/bower_components/*" -not -path "*/tmp/*")
#   eval "$1='${matching_files}'"
# }

# npm install -g cloc
function cloc {
  command cloc . --exclude-dir=.git,log,node_modules,Godeps,elm-stuff,deps,_build,target,dist,vendor,bower_components,tmp,deploy,distroot,Deps --exclude-lang=XML
}

function loc {
  if [ -z "$1" ] || [ "$1" == "all" ]; then
    loc js "$2"
    loc ls "$2"
    loc coffee "$2"
    loc c "$2"
    loc cpp "$2"
    loc cs "$2"
    loc cc "$2"
    loc java "$2"
    loc scala "$2"
    loc jsx "$2"
    loc sh "$2"
    loc sol "$2"
    loc ex "$2"
    loc exs "$2"
    loc erl "$2"
    loc go "$2"
    loc rs "$2"
    loc hs "$2"
    loc elm "$2"
    loc rb "$2"
    loc py "$2"
    loc html "$2"
    loc md "$2"
    loc css "$2"
    #loc xml "$2"
    loc json "$2"
  else
    IFS=$'\n'

    local files=$(find . -name "*.${1}" -not -path "*/.git/*" -not -path "*/log/*" -not -path "*/node_modules/*" -not -path "*/assets/*" -not -path "*/Godeps/*" -not -path "*/elm-stuff/*" -not -path "*/deps/*" -not -path "*/_build/*" -not -path "*/target/*" -not -path "*/dist/*" -not -path "*/vendor/*" -not -path "*/bower_components/*" -not -path "*/tmp/*" -not -path "*/deploy/*" -not -path "*/distroot/*" -not -path "*/Deps/*")
    # local files=''
    # source_code files "$1"

    if [ -n "$files" ]; then
      printf "${GREEN}${1}${NC}\n"
      if [ "$2" == "total" ]; then
        local total=$(wc -l $files | grep "total")
        if [ -n "$total" ]; then
          echo $total
        else
          wc -l $files
        fi
      else
        wc -l $files
      fi
      echo
    fi

    unset IFS
  fi
}

function stats {
  local tempdir=$(mktemp -d)
  if [ -d ".git" ]; then
    gitstats . "$tempdir"
    open "$tempdir/authors.html"
  else
    printf "${RED}Not a git repo...${NC}\n"
  fi
}

function loct {
  loc "all" "total"
}

# alias deb="DEBUG=true"

# function diag {
#   echo "DIAGNOSTICS for the project: to implement"
# }

function replace {
  if [[ -z "$1" || -z "$2" || -z "$3" ]]; then
    printf "${YELLOW}Usage:${NC} replace file.txt original replacement\n"
  elif [ ! -f "$1" ]; then
    printf "${YELLOW}No such file${NC}\n"
  elif [ ! -w "$1" ]; then
    if macos; then
      printf "${YELLOW}Copy this:${NC} sudo sed -i '' \"s/${2}/${3}/g\" \"$1\"\n"
    else
      printf "${YELLOW}Copy this:${NC} sudo sed -i \"s/${2}/${3}/g\" \"$1\"\n"
    fi
  else
    if macos; then
      sed -i '' "s/${2}/${3}/g" "$1"
    else
      sed -i "s/${2}/${3}/g" "$1"
    fi
  fi
}

alias di="find . -type d"

function php {
  if [ -z "$1" ]; then
    # Interactive shell
    command php -a
  elif [ -f "$1" ]; then
    # Execute file
    command php "$1"
    echo
  elif [ -n "$1" ]; then
    # params
    command php $@
  #else
  #  echo "No such file: $1"
  fi
}

function a {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    echo "a [term] [context_lines]"
    echo "a --[lang] [term] [context_lines]"
  else
    clear && printf '\e[3J' # completely clear the terminal

    if [ -n "$2" ] && [[ $1 == *--* ]]; then
      if [ -n "$3" ]; then
        command ack "$1" -i -Q -C "$3" -- "$2"
      else
        command ack "$1" -i -Q -- "$2"
      fi
    # if [[ $@ == *--* ]]; then
    #   # ack --ruby something
    #   command ack -i -Q "$@"
    else
      # -k flag to say "Only search the files that ack recognizes the types for"
      if [ -n "$2" ]; then
        command ack -i -k -Q -C "$2" -- "$1"
      else
        command ack -i -k -Q -- "$@"
      fi
      #command ack -i -k -Q -- $@
      # there were problems with -- $Q with: ack "Refresh to" -C 3
      # look below
    fi
  fi
}

function j {
  if [ -z "$@" ]; then
    calc
  else
    awk "BEGIN{print $*}"
  fi
}

function = {
  echo "$@" | bc -l
}

# also: calc (brew install calc)

alias kk='nano ~/k.txt'

function tun {
  local config=~/.ngrok-config.yml
  if [ -z "$1" ]; then
    printf "${YELLOW}cat ${config}${NC}\n\n"
    cat "$config"
  else
    ~/Install/ngrok/bin/ngrok -config="$config" start "$1"
  fi
}

function readable {
  if [ -z "$1" ]; then
    echo "usage: readable [server]"
    echo "usage: readable ."
  elif [ "$1" == "." ]; then
    chmod -R ugo+r .
  else
    ssh "$1" "chmod -R ugo+r /var/www"
    echo "ssh"
  fi
}

function compare {
  if [ -z "$1" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "${GREEN}compare dir1 dir2${NC}\n"
    printf "${GREEN}compare --size-only dir1 dir2${NC}\n"
  else
    local sizeonly=""
    if [ "$1" == "--size-only" ]; then
      sizeonly="--size-only"
      printf "${YELLOW}Sizeonly...${NC}\n"
      shift
    fi

    local params="-n -rli --delete $sizeonly"
    # -n = dry run
    #-rlptgoD
    rsync $params --exclude="._*" "$1"/ "$2"/
  fi
}

# stable project - using a git worktree feature:
# https://git-scm.com/docs/git-worktree
# so projects under ~/Projects/stable are actually a stable checkouts of projects elsewhere
function stable {
  if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
    printf "${YELLOW}Usage:${NC}\n"
    printf "stable . ${GRAY}checkout stable version of the project in ~/Projects/stable${NC}\n"
    printf "stable [project] ${GRAY}move to stable project${NC}\n"
  elif [ "$1" == "." ]; then
    local project="${PWD##*/}"
    local target="$HOME/Projects/stable/$project"

    if [ -d "$target" ]; then

      if [ -f ~/Projects/backups/nuke.rb ]; then
        printf "${YELLOW}${target} already exists...${NC}\n"
        #~/Projects/backups/nuke.rb "$target"
        rm -rf "$target"
      else
        printf "${RED}${target} already exists...${NC}\n"
        printf "Please execute: ${RED}rm -rf ${target}${NC} manually\n"
        return
      fi
    fi

    git worktree prune

    if git rev-parse --quiet --verify stable > /dev/null; then
      git branch -d stable
    fi

    git worktree add -b stable "$target" master

    printf "${GREEN}\nNow copying some things over (copy more manually if needed):${NC}\n"

    if [ -d data ]; then
      printf "${YELLOW}data...${NC}\n"
      cp -r data "$target/"
      printf "${GREEN}ok${NC}\n"
    fi

    if [ -d node_modules ]; then
      printf "${YELLOW}node_modules...${NC}\n"
      cp -r node_modules "$target/"
      printf "${GREEN}ok${NC}\n"
    fi

    echo
    printf "${MAGENTA}Project stabilified in ${target}${NC}\n"

  else
    awesome_cd ~/Projects/stable "$1"
  fi
}

# function ss {
#   local dir="`pwd`"
#   p "$1"
#   if [ ! "$dir" == "`pwd`" ]; then
#     subl -n .
#   fi
# }

function sn {
  local dir="`pwd`"
  n "$1"
  if [ ! "$dir" == "`pwd`" ]; then
    subl -n .
  fi
}

function pog {
  p "$1"
  og
}
