"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var net_1 = require("net");
function tcpPing(options) {
    var _options = {
        attempts: options && options.attempts ? options.attempts : 5,
        host: options && options.host ? options.host : 'localhost',
        port: options && options.port ? options.port : 80,
        timeout: options && options.timeout ? options.timeout : 5000
    };
    return new Promise(function (resolve, reject) {
        var results = [];
        countDown(_options.host, _options.port, _options.timeout, _options.attempts, function (error, done, ellapsedTime) {
            if (error !== null && error.code !== 'ECONNREFUSED')
                reject(error);
            else if (error !== null && error.code === 'ECONNREFUSED')
                results.push({ ping: null, error: 'Connection timed out' });
            else if (error === null && ellapsedTime)
                results.push({ ping: ellapsedTime });
            if (done)
                resolve(results);
        });
    });
}
exports.tcpPing = tcpPing;
function countDown(host, port, timeout, remainingCallsCount, callback) {
    --remainingCallsCount;
    connect(host, port, timeout, function (error, ping) {
        callback(error, remainingCallsCount === 0, ping);
        if (remainingCallsCount !== 0)
            countDown(host, port, timeout, remainingCallsCount, callback);
    });
}
function connect(host, port, timeout, callback) {
    var socket = new net_1.Socket();
    var start = process.hrtime();
    socket.setTimeout(timeout, function () {
        socket.destroy();
        callback(null, timeout + 1);
    });
    socket.connect(port, host, function () {
        var ellapsedTime = process.hrtime(start);
        socket.destroy();
        callback(null, ((ellapsedTime[0] * 1e9 + ellapsedTime[1]) / 1e6));
    });
    socket.on('error', function (error) {
        socket.destroy();
        callback(error);
    });
}
//# sourceMappingURL=index.js.map