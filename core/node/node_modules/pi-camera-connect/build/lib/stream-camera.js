"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const stream = require("stream");
const events_1 = require("events");
const child_process_1 = require("child_process");
const __1 = require("..");
var Codec;
(function (Codec) {
    Codec["H264"] = "H264";
    Codec["MJPEG"] = "MJPEG";
})(Codec = exports.Codec || (exports.Codec = {}));
var SensorMode;
(function (SensorMode) {
    SensorMode[SensorMode["AutoSelect"] = 0] = "AutoSelect";
    SensorMode[SensorMode["Mode1"] = 1] = "Mode1";
    SensorMode[SensorMode["Mode2"] = 2] = "Mode2";
    SensorMode[SensorMode["Mode3"] = 3] = "Mode3";
    SensorMode[SensorMode["Mode4"] = 4] = "Mode4";
    SensorMode[SensorMode["Mode5"] = 5] = "Mode5";
    SensorMode[SensorMode["Mode6"] = 6] = "Mode6";
    SensorMode[SensorMode["Mode7"] = 7] = "Mode7";
})(SensorMode = exports.SensorMode || (exports.SensorMode = {}));
class StreamCamera extends events_1.EventEmitter {
    constructor(options = {}) {
        super();
        this.streams = [];
        this.options = Object.assign({ rotation: __1.Rotation.Rotate0, flip: __1.Flip.None, bitRate: 17000000, fps: 30, codec: Codec.H264, sensorMode: SensorMode.AutoSelect }, options);
    }
    startCapture() {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const args = [
                /**
                 * Width
                 */
                ...(this.options.width ? ["--width", this.options.width.toString()] : []),
                /**
                 * Height
                 */
                ...(this.options.height ? ["--height", this.options.height.toString()] : []),
                /**
                 * Rotation
                 */
                ...(this.options.rotation ? ["--rotation", this.options.rotation.toString()] : []),
                /**
                 * Horizontal flip
                 */
                ...(this.options.flip && (this.options.flip === __1.Flip.Horizontal || this.options.flip === __1.Flip.Both) ?
                    ["--hflip"] : []),
                /**
                 * Vertical flip
                 */
                ...(this.options.flip && (this.options.flip === __1.Flip.Vertical || this.options.flip === __1.Flip.Both) ?
                    ["--vflip"] : []),
                /**
                 * Bit rate
                 */
                ...(this.options.bitRate ? ["--bitrate", this.options.bitRate.toString()] : []),
                /**
                 * Frame rate
                 */
                ...(this.options.fps ? ["--framerate", this.options.fps.toString()] : []),
                /**
                 * Codec
                 *
                 * H264 or MJPEG
                 *
                 */
                ...(this.options.codec ? ["--codec", this.options.codec.toString()] : []),
                /**
                 * Sensor mode
                 *
                 * Camera version 1.x (OV5647):
                 *
                 * | Mode |        Size         | Aspect Ratio | Frame rates |   FOV   |    Binning    |
                 * |------|---------------------|--------------|-------------|---------|---------------|
                 * |    0 | automatic selection |              |             |         |               |
                 * |    1 | 1920x1080           | 16:9         | 1-30fps     | Partial | None          |
                 * |    2 | 2592x1944           | 4:3          | 1-15fps     | Full    | None          |
                 * |    3 | 2592x1944           | 4:3          | 0.1666-1fps | Full    | None          |
                 * |    4 | 1296x972            | 4:3          | 1-42fps     | Full    | 2x2           |
                 * |    5 | 1296x730            | 16:9         | 1-49fps     | Full    | 2x2           |
                 * |    6 | 640x480             | 4:3          | 42.1-60fps  | Full    | 2x2 plus skip |
                 * |    7 | 640x480             | 4:3          | 60.1-90fps  | Full    | 2x2 plus skip |
                 *
                 *
                 * Camera version 2.x (IMX219):
                 *
                 * | Mode |        Size         | Aspect Ratio | Frame rates |   FOV   | Binning |
                 * |------|---------------------|--------------|-------------|---------|---------|
                 * |    0 | automatic selection |              |             |         |         |
                 * |    1 | 1920x1080           | 16:9         | 0.1-30fps   | Partial | None    |
                 * |    2 | 3280x2464           | 4:3          | 0.1-15fps   | Full    | None    |
                 * |    3 | 3280x2464           | 4:3          | 0.1-15fps   | Full    | None    |
                 * |    4 | 1640x1232           | 4:3          | 0.1-40fps   | Full    | 2x2     |
                 * |    5 | 1640x922            | 16:9         | 0.1-40fps   | Full    | 2x2     |
                 * |    6 | 1280x720            | 16:9         | 40-90fps    | Partial | 2x2     |
                 * |    7 | 640x480             | 4:3          | 40-90fps    | Partial | 2x2     |
                 *
                 */
                ...(this.options.sensorMode ? ["--mode", this.options.sensorMode.toString()] : []),
                /**
                 * Capture time (ms)
                 *
                 * Zero = forever
                 *
                 */
                "--timeout", (0).toString(),
                /**
                 * Do not display preview overlay on screen
                 */
                "--nopreview",
                /**
                 * Output to stdout
                 */
                "--output", "-"
            ];
            // Spawn child process
            this.childProcess = child_process_1.spawn("raspivid", args);
            // Listen for error event to reject promise
            this.childProcess.once("error", err => reject(new Error("Could not start capture with StreamCamera. Are you running on a Raspberry Pi with 'raspivid' installed?")));
            // Wait for first data event to resolve promise
            this.childProcess.stdout.once("data", () => resolve());
            let stdoutBuffer = Buffer.alloc(0);
            // Listen for image data events and parse MJPEG frames if codec is MJPEG
            this.childProcess.stdout.on("data", (data) => {
                this.streams.forEach(stream => stream.push(data));
                if (this.options.codec !== Codec.MJPEG)
                    return;
                stdoutBuffer = Buffer.concat([stdoutBuffer, data]);
                // Extract all image frames from the current buffer
                while (true) {
                    const signatureIndex = stdoutBuffer.indexOf(StreamCamera.jpegSignature, 0);
                    if (signatureIndex === -1)
                        break;
                    // Make sure the signature starts at the beginning of the buffer
                    if (signatureIndex > 0)
                        stdoutBuffer = stdoutBuffer.slice(signatureIndex);
                    const nextSignatureIndex = stdoutBuffer.indexOf(StreamCamera.jpegSignature, StreamCamera.jpegSignature.length);
                    if (nextSignatureIndex === -1)
                        break;
                    this.emit("frame", stdoutBuffer.slice(0, nextSignatureIndex));
                    stdoutBuffer = stdoutBuffer.slice(nextSignatureIndex);
                }
            });
            // Listen for error events
            this.childProcess.stdout.on("error", err => this.emit("error", err));
            this.childProcess.stderr.on("data", data => this.emit("error", new Error(data.toString())));
            this.childProcess.stderr.on("error", err => this.emit("error", err));
            // Listen for close events
            this.childProcess.stdout.on("close", () => this.emit("close"));
        }));
    }
    stopCapture() {
        return __awaiter(this, void 0, void 0, function* () {
            this.childProcess && this.childProcess.kill();
            // Push null to each stream to indicate EOF
            // tslint:disable-next-line no-null-keyword
            this.streams.forEach(stream => stream.push(null));
            this.streams = [];
        });
    }
    createStream() {
        const newStream = new stream.Readable({
            read: () => { }
        });
        this.streams.push(newStream);
        return newStream;
    }
    takeImage() {
        if (this.options.codec !== Codec.MJPEG)
            throw new Error("Codec must be 'MJPEG' to take image");
        return new Promise(resolve => this.once("frame", data => resolve(data)));
    }
}
StreamCamera.jpegSignature = Buffer.from([0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00]);
exports.default = StreamCamera;
