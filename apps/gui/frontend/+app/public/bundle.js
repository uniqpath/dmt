var app = (function (crypto) {
	'use strict';

	crypto = crypto && crypto.hasOwnProperty('default') ? crypto['default'] : crypto;

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function assignTrue(tar, src) {
		for (var k in src) tar[k] = 1;
		return tar;
	}

	function callAfter(fn, i) {
		if (i === 0) fn();
		return () => {
			if (!--i) fn();
		};
	}

	function addLoc(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		fn();
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function detachBetween(before, after) {
		while (before.nextSibling && before.nextSibling !== after) {
			before.parentNode.removeChild(before.nextSibling);
		}
	}

	function reinsertBetween(before, after, target) {
		while (before.nextSibling && before.nextSibling !== after) {
			target.appendChild(before.parentNode.removeChild(before.nextSibling));
		}
	}

	function reinsertChildren(parent, target) {
		while (parent.firstChild) target.appendChild(parent.firstChild);
	}

	function reinsertAfter(before, target) {
		while (before.nextSibling) target.appendChild(before.nextSibling);
	}

	function destroyEach(iterations, detach) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detach);
		}
	}

	function createFragment() {
		return document.createDocumentFragment();
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createSvgElement(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function addListener(node, event, handler, options) {
		node.addEventListener(event, handler, options);
	}

	function removeListener(node, event, handler, options) {
		node.removeEventListener(event, handler, options);
	}

	function setAttribute(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else node.setAttribute(attribute, value);
	}

	function setData(text, data) {
		text.data = '' + data;
	}

	function setStyle(node, key, value) {
		node.style.setProperty(key, value);
	}

	function toggleClass(element, name, toggle) {
		element.classList[toggle ? 'add' : 'remove'](name);
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function destroyDev(detach) {
		destroy.call(this, detach);
		this.destroy = function() {
			console.warn('Component was already destroyed');
		};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function _differsImmutable(a, b) {
		return a != a ? b == b : a !== b;
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		flush(this.root);
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function setDev(newState) {
		if (typeof newState !== 'object') {
			throw new Error(
				this._debugName + '.set was called without an object of data key-values to update.'
			);
		}

		this._checkReadOnly(newState);
		set.call(this, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	function removeFromStore() {
		this.store._remove(this);
	}

	var protoDev = {
		destroy: destroyDev,
		get,
		fire,
		on,
		set: setDev,
		_recompute: noop,
		_set,
		_stage,
		_mount,
		_differs
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/ConnectionIndicator.html generated by Svelte v2.16.1 */

	var methods = {
	  escape() {
	    console.log("ESCAPE");
	    if(this.get().atRPi) {
	      // visual notification (especially important on touch) that command was given
	      this.set({ touchPressed: 'escape' });
	      setTimeout(() => { this.fire('escape'); this.set({ touchPressed: undefined }); }, 0); // so that thread has actual time to show the effect
	    } else {
	      this.fire('escape');
	    }
	  }
	};

	const file = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/ConnectionIndicator.html";

	function create_main_fragment(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$connected == false) && create_if_block(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$connected == false) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $connected == false}
	function create_if_block(component, ctx) {
		var div0, span, text1, text2, div2, div1;

		var if_block = (ctx.$device) && create_if_block_1(component, ctx);

		return {
			c: function create() {
				div0 = createElement("div");
				span = createElement("span");
				span.textContent = "✖";
				text1 = createText("\n    ");
				if (if_block) if_block.c();
				text2 = createText("\n\n  ");
				div2 = createElement("div");
				div1 = createElement("div");
				div1.textContent = "✖";
				span.className = "error svelte-ybcte6";
				addLoc(span, file, 2, 4, 50);
				div0.id = "device";
				div0.className = "svelte-ybcte6";
				addLoc(div0, file, 1, 2, 28);
				div1.id = "broken_connection";
				div1.className = "svelte-ybcte6";
				addLoc(div1, file, 9, 4, 199);
				div2.id = "top_icons";
				addLoc(div2, file, 8, 2, 174);
			},

			m: function mount(target, anchor) {
				insert(target, div0, anchor);
				append(div0, span);
				append(div0, text1);
				if (if_block) if_block.m(div0, null);
				insert(target, text2, anchor);
				insert(target, div2, anchor);
				append(div2, div1);
			},

			p: function update(changed, ctx) {
				if (ctx.$device) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1(component, ctx);
						if_block.c();
						if_block.m(div0, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div0);
				}

				if (if_block) if_block.d();
				if (detach) {
					detachNode(text2);
					detachNode(div2);
				}
			}
		};
	}

	// (4:4) {#if $device}
	function create_if_block_1(component, ctx) {
		var h3, text_value = (ctx.$device.deviceName) || '', text;

		return {
			c: function create() {
				h3 = createElement("h3");
				text = createText(text_value);
				h3.id = "title";
				h3.className = "svelte-ybcte6";
				addLoc(h3, file, 4, 6, 103);
			},

			m: function mount(target, anchor) {
				insert(target, h3, anchor);
				append(h3, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$device) && text_value !== (text_value = (ctx.$device.deviceName) || '')) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(h3);
				}
			}
		};
	}

	function ConnectionIndicator(options) {
		this._debugName = '<ConnectionIndicator>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<ConnectionIndicator> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","device"]), options.data);
		this.store._add(this, ["connected","device"]);
		if (!('$connected' in this._state)) console.warn("<ConnectionIndicator> was created without expected data property '$connected'");
		if (!('$device' in this._state)) console.warn("<ConnectionIndicator> was created without expected data property '$device'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}

		this._intro = true;
	}

	assign(ConnectionIndicator.prototype, protoDev);
	assign(ConnectionIndicator.prototype, methods);

	ConnectionIndicator.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	const img = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAADAEAAAwBAGZkNF0AAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAwBQTFRF////HR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0bHR0b9nXxIQAAAP90Uk5TAAECAwQF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';

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/ApWifiCredentials.html generated by Svelte v2.16.1 */

	function oncreate() {
	  this.set({ wifiIconInline: img });
	}
	const file$1 = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/ApWifiCredentials.html";

	function create_main_fragment$1(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$device && ctx.$device.apMode && ctx.$device.apInfo) && create_if_block$1(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$device && ctx.$device.apMode && ctx.$device.apInfo) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$1(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $device && $device.apMode && $device.apInfo}
	function create_if_block$1(component, ctx) {
		var div2, img, text0, div0, b0, text2, text3_value = ctx.$device.apInfo.ssid, text3, text4, div1, b1, text6, text7_value = ctx.$device.apInfo.password, text7;

		return {
			c: function create() {
				div2 = createElement("div");
				img = createElement("img");
				text0 = createText("\n    ");
				div0 = createElement("div");
				b0 = createElement("b");
				b0.textContent = "SSID:";
				text2 = createText(" ");
				text3 = createText(text3_value);
				text4 = createText("\n    ");
				div1 = createElement("div");
				b1 = createElement("b");
				b1.textContent = "Pass:";
				text6 = createText(" ");
				text7 = createText(text7_value);
				img.src = ctx.wifiIconInline;
				img.className = "wifi_icon svelte-1v5x43o";
				img.alt = "wifi icon";
				addLoc(img, file$1, 2, 4, 83);
				addLoc(b0, file$1, 3, 9, 155);
				addLoc(div0, file$1, 3, 4, 150);
				addLoc(b1, file$1, 4, 9, 205);
				addLoc(div1, file$1, 4, 4, 200);
				div2.className = "ap_wifi_info svelte-1v5x43o";
				addLoc(div2, file$1, 1, 2, 52);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, img);
				append(div2, text0);
				append(div2, div0);
				append(div0, b0);
				append(div0, text2);
				append(div0, text3);
				append(div2, text4);
				append(div2, div1);
				append(div1, b1);
				append(div1, text6);
				append(div1, text7);
			},

			p: function update(changed, ctx) {
				if (changed.wifiIconInline) {
					img.src = ctx.wifiIconInline;
				}

				if ((changed.$device) && text3_value !== (text3_value = ctx.$device.apInfo.ssid)) {
					setData(text3, text3_value);
				}

				if ((changed.$device) && text7_value !== (text7_value = ctx.$device.apInfo.password)) {
					setData(text7, text7_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}
			}
		};
	}

	function ApWifiCredentials(options) {
		this._debugName = '<ApWifiCredentials>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<ApWifiCredentials> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["device"]), options.data);
		this.store._add(this, ["device"]);
		if (!('$device' in this._state)) console.warn("<ApWifiCredentials> was created without expected data property '$device'");
		if (!('wifiIconInline' in this._state)) console.warn("<ApWifiCredentials> was created without expected data property 'wifiIconInline'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$1(this, this._state);

		this.root._oncreate.push(() => {
			oncreate.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(ApWifiCredentials.prototype, protoDev);

	ApWifiCredentials.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/NearbyHandyLinks.html generated by Svelte v2.16.1 */

	function getDevice(_deviceName, nearbyDevices) {
	  //const nearbyDevices = this.get();
	  return nearbyDevices.find(({deviceName}) => deviceName == _deviceName)
	}
	var methods$1 = {
	  switchToDevice(device) {
	    device.port = device.guiPort;
	    this.store.switch(device);
	  },
	  switchToThisDevice() {
	    this.store.switch();
	  }
	};

	function oncreate$1() {
	  this.store.entangle(this);
	}
	const file$2 = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/NearbyHandyLinks.html";

	function click_handler(event) {
		const { component, ctx } = this._svelte;

		component.switchToDevice(ctx.device);
	}

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.device = list[i];
		return child_ctx;
	}

	function create_main_fragment$2(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.loaded) && create_if_block$2(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$2(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if loaded}
	function create_if_block$2(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.$connected && ctx.$device) && create_if_block_1$1(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.$connected && ctx.$device) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$1(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (3:2) {#if $connected && $device}
	function create_if_block_1$1(component, ctx) {
		var div, text0, text1;

		var if_block0 = (ctx.thisDeviceName != ctx.selectedDeviceName) && create_if_block_7(component, ctx);

		var if_block1 = (!ctx.homebase && ctx.homebaseName && ctx.$nearbyDevices && getDevice(ctx.homebaseName, ctx.$nearbyDevices)) && create_if_block_5(component, ctx);

		var if_block2 = (!ctx.disableDeviceSelector && ctx.$nearbyDevices && ctx.$nearbyDevices.length > 0) && create_if_block_2(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText("\n\n      ");
				if (if_block1) if_block1.c();
				text1 = createText("\n\n      ");
				if (if_block2) if_block2.c();
				div.className = "nearby_handy_links svelte-zncg7e";
				toggleClass(div, "nonRPi", !ctx.atRPi);
				addLoc(div, file$2, 4, 4, 49);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, text0);
				if (if_block1) if_block1.m(div, null);
				append(div, text1);
				if (if_block2) if_block2.m(div, null);
			},

			p: function update(changed, ctx) {
				if (ctx.thisDeviceName != ctx.selectedDeviceName) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_7(component, ctx);
						if_block0.c();
						if_block0.m(div, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (!ctx.homebase && ctx.homebaseName && ctx.$nearbyDevices && getDevice(ctx.homebaseName, ctx.$nearbyDevices)) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_5(component, ctx);
						if_block1.c();
						if_block1.m(div, text1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (!ctx.disableDeviceSelector && ctx.$nearbyDevices && ctx.$nearbyDevices.length > 0) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_2(component, ctx);
						if_block2.c();
						if_block2.m(div, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (changed.atRPi) {
					toggleClass(div, "nonRPi", !ctx.atRPi);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (7:6) {#if thisDeviceName != selectedDeviceName}
	function create_if_block_7(component, ctx) {
		var div, button, text0, text1;

		var if_block = (ctx.$nearbyDevices && getDevice(ctx.deviceName, ctx.$nearbyDevices) && getDevice(ctx.deviceName, ctx.$nearbyDevices).playing) && create_if_block_8(component, ctx);

		function click_handler(event) {
			component.switchToThisDevice();
		}

		return {
			c: function create() {
				div = createElement("div");
				button = createElement("button");
				if (if_block) if_block.c();
				text0 = createText("\n\n            ");
				text1 = createText(ctx.thisDeviceName);
				addListener(button, "click", click_handler);
				button.className = "home svelte-zncg7e";
				addLoc(button, file$2, 9, 10, 194);
				div.className = "device";
				addLoc(div, file$2, 8, 8, 163);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, button);
				if (if_block) if_block.m(button, null);
				append(button, text0);
				append(button, text1);
			},

			p: function update(changed, ctx) {
				if (ctx.$nearbyDevices && getDevice(ctx.deviceName, ctx.$nearbyDevices) && getDevice(ctx.deviceName, ctx.$nearbyDevices).playing) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_8(component, ctx);
						if_block.c();
						if_block.m(button, text0);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.thisDeviceName) {
					setData(text1, ctx.thisDeviceName);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
				removeListener(button, "click", click_handler);
			}
		};
	}

	// (13:12) {#if $nearbyDevices && getDevice(deviceName, $nearbyDevices) && getDevice(deviceName, $nearbyDevices).playing}
	function create_if_block_8(component, ctx) {
		var text_value = ctx.$nearbyDevices.find(({_deviceName}) => ctx.deviceName == _deviceName).mediaType == 'video' ? ' ▶' : ' ♫', text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$nearbyDevices || changed.deviceName) && text_value !== (text_value = ctx.$nearbyDevices.find(({_deviceName}) => ctx.deviceName == _deviceName).mediaType == 'video' ? ' ▶' : ' ♫')) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (23:6) {#if !homebase && homebaseName && $nearbyDevices && getDevice(homebaseName, $nearbyDevices)}
	function create_if_block_5(component, ctx) {
		var div, button, text0, text1;

		var if_block = (getDevice(ctx.homebaseName, ctx.$nearbyDevices).playing) && create_if_block_6(component, ctx);

		function click_handler(event) {
			component.switchToDevice(getDevice(ctx.homebaseName, ctx.$nearbyDevices));
		}

		return {
			c: function create() {
				div = createElement("div");
				button = createElement("button");
				if (if_block) if_block.c();
				text0 = createText("\n\n            ");
				text1 = createText(ctx.homebaseName);
				addListener(button, "click", click_handler);
				button.className = "svelte-zncg7e";
				addLoc(button, file$2, 25, 10, 799);
				div.className = "device";
				addLoc(div, file$2, 24, 8, 768);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, button);
				if (if_block) if_block.m(button, null);
				append(button, text0);
				append(button, text1);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (getDevice(ctx.homebaseName, ctx.$nearbyDevices).playing) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_6(component, ctx);
						if_block.c();
						if_block.m(button, text0);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.homebaseName) {
					setData(text1, ctx.homebaseName);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
				removeListener(button, "click", click_handler);
			}
		};
	}

	// (29:12) {#if getDevice(homebaseName, $nearbyDevices).playing}
	function create_if_block_6(component, ctx) {
		var text_value = getDevice(ctx.homebaseName, ctx.$nearbyDevices).mediaType == 'video' ? ' ▶' : ' ♫', text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.homebaseName || changed.$nearbyDevices) && text_value !== (text_value = getDevice(ctx.homebaseName, ctx.$nearbyDevices).mediaType == 'video' ? ' ▶' : ' ♫')) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (39:6) {#if !disableDeviceSelector && $nearbyDevices && $nearbyDevices.length > 0}
	function create_if_block_2(component, ctx) {
		var each_anchor;

		var each_value = ctx.$nearbyDevices.sort((a, b) => a.deviceName < b.deviceName ? -1 : (a.deviceName > b.deviceName ? 1 : 0));

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(component, get_each_context(ctx, each_value, i));
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insert(target, each_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.$nearbyDevices || changed.selectedDeviceName || changed.thisDeviceName || changed.homebaseName) {
					each_value = ctx.$nearbyDevices.sort((a, b) => a.deviceName < b.deviceName ? -1 : (a.deviceName > b.deviceName ? 1 : 0));

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d: function destroy(detach) {
				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	// (43:10) {#if device.deviceName != selectedDeviceName && device.deviceName != thisDeviceName && device.deviceName != homebaseName}
	function create_if_block_3(component, ctx) {
		var if_block_anchor;

		var if_block = (getDevice(ctx.device.deviceName, ctx.$nearbyDevices).playing && !getDevice(ctx.device.deviceName, ctx.$nearbyDevices).hiddenInGui) && create_if_block_4(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (getDevice(ctx.device.deviceName, ctx.$nearbyDevices).playing && !getDevice(ctx.device.deviceName, ctx.$nearbyDevices).hiddenInGui) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_4(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (45:12) {#if getDevice(device.deviceName, $nearbyDevices).playing && !getDevice(device.deviceName, $nearbyDevices).hiddenInGui}
	function create_if_block_4(component, ctx) {
		var div, button, text0_value = getDevice(ctx.device.deviceName, ctx.$nearbyDevices).mediaType == 'video' ? ' ▶' : ' ♫', text0, text1, text2_value = ctx.device.deviceName, text2, text3;

		return {
			c: function create() {
				div = createElement("div");
				button = createElement("button");
				text0 = createText(text0_value);
				text1 = createText(" ");
				text2 = createText(text2_value);
				text3 = createText("\n              ");
				button._svelte = { component, ctx };

				addListener(button, "click", click_handler);
				button.className = "svelte-zncg7e";
				addLoc(button, file$2, 47, 16, 1733);
				div.className = "device";
				addLoc(div, file$2, 46, 14, 1696);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, button);
				append(button, text0);
				append(button, text1);
				append(button, text2);
				append(div, text3);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if ((changed.$nearbyDevices) && text0_value !== (text0_value = getDevice(ctx.device.deviceName, ctx.$nearbyDevices).mediaType == 'video' ? ' ▶' : ' ♫')) {
					setData(text0, text0_value);
				}

				if ((changed.$nearbyDevices) && text2_value !== (text2_value = ctx.device.deviceName)) {
					setData(text2, text2_value);
				}

				button._svelte.ctx = ctx;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (41:8) {#each $nearbyDevices.sort((a, b) => a.deviceName < b.deviceName ? -1 : (a.deviceName > b.deviceName ? 1 : 0)) as device}
	function create_each_block(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.device.deviceName != ctx.selectedDeviceName && ctx.device.deviceName != ctx.thisDeviceName && ctx.device.deviceName != ctx.homebaseName) && create_if_block_3(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.device.deviceName != ctx.selectedDeviceName && ctx.device.deviceName != ctx.thisDeviceName && ctx.device.deviceName != ctx.homebaseName) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_3(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	function NearbyHandyLinks(options) {
		this._debugName = '<NearbyHandyLinks>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<NearbyHandyLinks> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","device","nearbyDevices"]), options.data);
		this.store._add(this, ["connected","device","nearbyDevices"]);
		if (!('loaded' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property 'loaded'");
		if (!('$connected' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property '$connected'");
		if (!('$device' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property '$device'");
		if (!('atRPi' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property 'atRPi'");
		if (!('thisDeviceName' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property 'thisDeviceName'");
		if (!('selectedDeviceName' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property 'selectedDeviceName'");
		if (!('$nearbyDevices' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property '$nearbyDevices'");
		if (!('deviceName' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property 'deviceName'");
		if (!('homebase' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property 'homebase'");
		if (!('homebaseName' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property 'homebaseName'");
		if (!('disableDeviceSelector' in this._state)) console.warn("<NearbyHandyLinks> was created without expected data property 'disableDeviceSelector'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$2(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$1.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(NearbyHandyLinks.prototype, protoDev);
	assign(NearbyHandyLinks.prototype, methods$1);

	NearbyHandyLinks.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/TileBar.html generated by Svelte v2.16.1 */



	var methods$2 = {
	  select(view) {
	    if(this.get().atRPi) {
	      // visual notification (especially important on touch) that command was given
	      this.set({ touchPressed: view });
	      setTimeout(() => this.fire('select', { view }), 0); // so that thread has actual time to show the effect
	    } else {
	      this.fire('select', { view });
	    }
	  }
	};

	function oncreate$2() {
	  // keep a few dmt-related variables (timeDate, environment, thisDeviceName, selectedDeviceName, homebase) synced with the backend of THIS device
	  // other more fluid variables will be available in global store! for example $player .... always connected to either local device player
	  // or remote device player backend
	  this.store.entangle(this);
	}
	const file$3 = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/TileBar.html";

	function create_main_fragment$3(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.loaded) && create_if_block$3(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$3(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if loaded}
	function create_if_block$3(component, ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block_1$2,
			create_else_block_2
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.$connected && ctx.$device) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block.c();
					}
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (91:2) {:else}
	function create_else_block_2(component, ctx) {
		var div, current;

		return {
			c: function create() {
				div = createElement("div");
				div.textContent = "✖";
				div.id = "broken_connection";
				div.className = "svelte-1lf904p";
				addLoc(div, file$3, 91, 4, 3581);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				current = true;
			},

			p: noop,

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (3:2) {#if $connected && $device}
	function create_if_block_1$2(component, ctx) {
		var div6, div2, div0, text1, div1, text3, text4, div4, text5, div3, text7, div5, text8, slot_content_default = component._slotted.default, slot_content_default_before, current;

		function click_handler(event) {
			component.select('player');
		}

		function click_handler_1(event) {
			component.select('clock');
		}

		var if_block0 = (ctx.isDevUser) && create_if_block_16(component, ctx);

		function select_block_type_1(ctx) {
			if (!ctx.atRPi) return create_if_block_15;
			return create_else_block_1;
		}

		var current_block_type = select_block_type_1(ctx);
		var if_block1 = current_block_type(component, ctx);

		function click_handler_2(event) {
			component.select('device');
		}

		var if_block2 = (ctx.selectedDeviceName) && create_if_block_2$1(component, ctx);

		return {
			c: function create() {
				div6 = createElement("div");
				div2 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "Player";
				text1 = createText("\n        ");
				div1 = createElement("div");
				div1.textContent = "Clock";
				text3 = createText("\n\n      ");
				if (if_block0) if_block0.c();
				text4 = createText("\n\n      ");
				div4 = createElement("div");
				if_block1.c();
				text5 = createText("\n        ");
				div3 = createElement("div");
				div3.textContent = "Device";
				text7 = createText("\n\n      ");
				div5 = createElement("div");
				if (if_block2) if_block2.c();
				text8 = createText("\n\n      ");
				addListener(div0, "click", click_handler);
				div0.className = "player svelte-1lf904p";
				toggleClass(div0, "touch_pressed", ctx.touchPressed == 'player');
				addLoc(div0, file$3, 6, 8, 130);
				addListener(div1, "click", click_handler_1);
				div1.className = "clock svelte-1lf904p";
				toggleClass(div1, "touch_pressed", ctx.touchPressed == 'clock');
				addLoc(div1, file$3, 7, 8, 246);
				div2.className = "options svelte-1lf904p";
				addLoc(div2, file$3, 5, 6, 100);
				addListener(div3, "click", click_handler_2);
				div3.className = "device svelte-1lf904p";
				toggleClass(div3, "touch_pressed", ctx.touchPressed == 'device');
				addLoc(div3, file$3, 22, 8, 877);
				div4.className = "options svelte-1lf904p";
				addLoc(div4, file$3, 16, 6, 576);
				div5.className = "deviceInfo svelte-1lf904p";
				addLoc(div5, file$3, 25, 6, 1005);
				div6.className = "selector svelte-1lf904p";
				toggleClass(div6, "nonRPi", !ctx.atRPi);
				addLoc(div6, file$3, 3, 4, 48);
			},

			m: function mount(target, anchor) {
				insert(target, div6, anchor);
				append(div6, div2);
				append(div2, div0);
				append(div2, text1);
				append(div2, div1);
				append(div6, text3);
				if (if_block0) if_block0.m(div6, null);
				append(div6, text4);
				append(div6, div4);
				if_block1.m(div4, null);
				append(div4, text5);
				append(div4, div3);
				append(div6, text7);
				append(div6, div5);
				if (if_block2) if_block2.m(div5, null);
				append(div6, text8);

				if (slot_content_default) {
					append(div6, slot_content_default_before || (slot_content_default_before = createComment()));
					append(div6, slot_content_default);
				}

				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.touchPressed) {
					toggleClass(div0, "touch_pressed", ctx.touchPressed == 'player');
					toggleClass(div1, "touch_pressed", ctx.touchPressed == 'clock');
				}

				if (ctx.isDevUser) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_16(component, ctx);
						if_block0.c();
						if_block0.m(div6, text4);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block1) {
					if_block1.p(changed, ctx);
				} else {
					if_block1.d(1);
					if_block1 = current_block_type(component, ctx);
					if_block1.c();
					if_block1.m(div4, text5);
				}

				if (changed.touchPressed) {
					toggleClass(div3, "touch_pressed", ctx.touchPressed == 'device');
				}

				if (ctx.selectedDeviceName) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_2$1(component, ctx);
						if (if_block2) if_block2.c();
					}

					if_block2.i(div5, null);
				} else if (if_block2) {
					if_block2.o(function() {
						if_block2.d(1);
						if_block2 = null;
					});
				}

				if (changed.atRPi) {
					toggleClass(div6, "nonRPi", !ctx.atRPi);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block2) if_block2.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div6);
				}

				removeListener(div0, "click", click_handler);
				removeListener(div1, "click", click_handler_1);
				if (if_block0) if_block0.d();
				if_block1.d();
				removeListener(div3, "click", click_handler_2);
				if (if_block2) if_block2.d();

				if (slot_content_default) {
					reinsertAfter(slot_content_default_before, slot_content_default);
				}
			}
		};
	}

	// (11:6) {#if isDevUser}
	function create_if_block_16(component, ctx) {
		var div1, div0;

		function click_handler(event) {
			component.select('ambience');
		}

		return {
			c: function create() {
				div1 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "Ambience";
				addListener(div0, "click", click_handler);
				div0.className = "ambience svelte-1lf904p";
				toggleClass(div0, "touch_pressed", ctx.touchPressed == 'ambience');
				addLoc(div0, file$3, 12, 10, 426);
				div1.className = "options svelte-1lf904p";
				addLoc(div1, file$3, 11, 8, 394);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
			},

			p: function update(changed, ctx) {
				if (changed.touchPressed) {
					toggleClass(div0, "touch_pressed", ctx.touchPressed == 'ambience');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				removeListener(div0, "click", click_handler);
			}
		};
	}

	// (20:8) {:else}
	function create_else_block_1(component, ctx) {
		var div;

		function click_handler(event) {
			component.select('help');
		}

		return {
			c: function create() {
				div = createElement("div");
				div.textContent = "Help";
				addListener(div, "click", click_handler);
				div.className = "help svelte-1lf904p";
				toggleClass(div, "touch_pressed", ctx.touchPressed == 'help');
				addLoc(div, file$3, 20, 10, 755);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.touchPressed) {
					toggleClass(div, "touch_pressed", ctx.touchPressed == 'help');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(div, "click", click_handler);
			}
		};
	}

	// (18:8) {#if !atRPi}
	function create_if_block_15(component, ctx) {
		var div;

		function click_handler(event) {
			component.select('apps');
		}

		return {
			c: function create() {
				div = createElement("div");
				div.textContent = "Apps";
				addListener(div, "click", click_handler);
				div.className = "apps svelte-1lf904p";
				toggleClass(div, "touch_pressed", ctx.touchPressed == 'apps');
				addLoc(div, file$3, 18, 10, 629);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.touchPressed) {
					toggleClass(div, "touch_pressed", ctx.touchPressed == 'apps');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(div, "click", click_handler);
			}
		};
	}

	// (27:8) {#if selectedDeviceName}
	function create_if_block_2$1(component, ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block_3$1,
			create_else_block
		];

		var if_blocks = [];

		function select_block_type_2(ctx) {
			if (ctx.$device.demoDevice) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block.c();
					}
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (31:10) {:else}
	function create_else_block(component, ctx) {
		var div, text0, text1, text2, span0, text3_value = ctx.$device.devPanel ? '[DΞV]' : '', text3, text4, span1, text5_value = ctx.$device.apMode ? '(AP)' : '', text5, text6, text7, text8, if_block3_anchor, current;

		var if_block0 = (ctx.$device.connectivityProblem || ctx.$device.localConnectivityProblem) && create_if_block_14();

		var if_block1 = (ctx.$device.localConnectivityProblem || ctx.$device.localConnectivityResumed) && create_if_block_11(component, ctx);

		var if_block2 = (ctx.$device.connectivityProblem || ctx.$device.connectivityResumed) && create_if_block_8$1(component, ctx);

		var if_block3 = (ctx.$device) && create_if_block_4$1(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText("\n\n              ");
				text1 = createText(ctx.selectedDeviceName);
				text2 = createText(" ");
				span0 = createElement("span");
				text3 = createText(text3_value);
				text4 = createText("\n\n              ");
				span1 = createElement("span");
				text5 = createText(text5_value);
				text6 = createText("\n\n            ");
				if (if_block1) if_block1.c();
				text7 = createText("\n\n            ");
				if (if_block2) if_block2.c();
				text8 = createText("\n\n            ");
				if (if_block3) if_block3.c();
				if_block3_anchor = createComment();
				span0.className = "dev svelte-1lf904p";
				addLoc(span0, file$3, 36, 35, 1600);
				span1.className = "ap_mode svelte-1lf904p";
				addLoc(span1, file$3, 38, 14, 1674);
				div.className = "deviceName svelte-1lf904p";
				toggleClass(div, "connectivity_problem", ctx.$device.connectivityProblem);
				toggleClass(div, "local_connectivity_problem", ctx.$device.localConnectivityProblem);
				toggleClass(div, "connectivity_resumed", ctx.$device.connectivityResumed);
				addLoc(div, file$3, 32, 12, 1266);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, text0);
				append(div, text1);
				append(div, text2);
				append(div, span0);
				append(span0, text3);
				append(div, text4);
				append(div, span1);
				append(span1, text5);
				insert(target, text6, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, text7, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, text8, anchor);
				if (if_block3) if_block3.m(target, anchor);
				insert(target, if_block3_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$device.connectivityProblem || ctx.$device.localConnectivityProblem) {
					if (!if_block0) {
						if_block0 = create_if_block_14();
						if_block0.c();
						if_block0.m(div, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (!current || changed.selectedDeviceName) {
					setData(text1, ctx.selectedDeviceName);
				}

				if ((!current || changed.$device) && text3_value !== (text3_value = ctx.$device.devPanel ? '[DΞV]' : '')) {
					setData(text3, text3_value);
				}

				if ((!current || changed.$device) && text5_value !== (text5_value = ctx.$device.apMode ? '(AP)' : '')) {
					setData(text5, text5_value);
				}

				if (changed.$device) {
					toggleClass(div, "connectivity_problem", ctx.$device.connectivityProblem);
					toggleClass(div, "local_connectivity_problem", ctx.$device.localConnectivityProblem);
					toggleClass(div, "connectivity_resumed", ctx.$device.connectivityResumed);
				}

				if (ctx.$device.localConnectivityProblem || ctx.$device.localConnectivityResumed) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_11(component, ctx);
						if_block1.c();
						if_block1.m(text7.parentNode, text7);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$device.connectivityProblem || ctx.$device.connectivityResumed) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_8$1(component, ctx);
						if_block2.c();
						if_block2.m(text8.parentNode, text8);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (ctx.$device) {
					if (if_block3) {
						if_block3.p(changed, ctx);
					} else {
						if_block3 = create_if_block_4$1(component, ctx);
						if (if_block3) if_block3.c();
					}

					if_block3.i(if_block3_anchor.parentNode, if_block3_anchor);
				} else if (if_block3) {
					if_block3.o(function() {
						if_block3.d(1);
						if_block3 = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block3) if_block3.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if (detach) {
					detachNode(text6);
				}

				if (if_block1) if_block1.d(detach);
				if (detach) {
					detachNode(text7);
				}

				if (if_block2) if_block2.d(detach);
				if (detach) {
					detachNode(text8);
				}

				if (if_block3) if_block3.d(detach);
				if (detach) {
					detachNode(if_block3_anchor);
				}
			}
		};
	}

	// (28:10) {#if $device.demoDevice}
	function create_if_block_3$1(component, ctx) {
		var div0, text0_value = ctx.$device.demoDevice.deviceName, text0, text1, div1, text2_value = ctx.$device.demoDevice.tagline, text2, current;

		return {
			c: function create() {
				div0 = createElement("div");
				text0 = createText(text0_value);
				text1 = createText("\n            ");
				div1 = createElement("div");
				text2 = createText(text2_value);
				div0.className = "deviceName svelte-1lf904p";
				addLoc(div0, file$3, 28, 12, 1110);
				div1.className = "ip svelte-1lf904p";
				addLoc(div1, file$3, 29, 12, 1184);
			},

			m: function mount(target, anchor) {
				insert(target, div0, anchor);
				append(div0, text0);
				insert(target, text1, anchor);
				insert(target, div1, anchor);
				append(div1, text2);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((changed.$device) && text0_value !== (text0_value = ctx.$device.demoDevice.deviceName)) {
					setData(text0, text0_value);
				}

				if ((changed.$device) && text2_value !== (text2_value = ctx.$device.demoDevice.tagline)) {
					setData(text2, text2_value);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div0);
					detachNode(text1);
					detachNode(div1);
				}
			}
		};
	}

	// (35:14) {#if $device.connectivityProblem || $device.localConnectivityProblem}
	function create_if_block_14(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("✖");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (42:12) {#if $device.localConnectivityProblem || $device.localConnectivityResumed}
	function create_if_block_11(component, ctx) {
		var div;

		function select_block_type_3(ctx) {
			if (ctx.$device.localConnectivityProblem) return create_if_block_12;
			if (ctx.$device.localConnectivityResumed) return create_if_block_13;
		}

		var current_block_type = select_block_type_3(ctx);
		var if_block = current_block_type && current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.className = "deviceConnectivityStatus svelte-1lf904p";
				toggleClass(div, "local_connectivity_problem", ctx.$device.localConnectivityProblem);
				toggleClass(div, "local_connectivity_resumed", ctx.$device.localConnectivityResumed);
				addLoc(div, file$3, 42, 14, 1855);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type !== (current_block_type = select_block_type_3(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(component, ctx);
					if (if_block) if_block.c();
					if (if_block) if_block.m(div, null);
				}

				if (changed.$device) {
					toggleClass(div, "local_connectivity_problem", ctx.$device.localConnectivityProblem);
					toggleClass(div, "local_connectivity_resumed", ctx.$device.localConnectivityResumed);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (47:58) 
	function create_if_block_13(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Router connection resumed");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (45:16) {#if $device.localConnectivityProblem}
	function create_if_block_12(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Router unreachable");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (53:12) {#if $device.connectivityProblem || $device.connectivityResumed}
	function create_if_block_8$1(component, ctx) {
		var div;

		function select_block_type_4(ctx) {
			if (ctx.$device.connectivityProblem) return create_if_block_9;
			if (ctx.$device.connectivityResumed) return create_if_block_10;
		}

		var current_block_type = select_block_type_4(ctx);
		var if_block = current_block_type && current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.className = "deviceConnectivityStatus svelte-1lf904p";
				toggleClass(div, "connectivity_problem", ctx.$device.connectivityProblem);
				toggleClass(div, "connectivity_resumed", ctx.$device.connectivityResumed);
				addLoc(div, file$3, 53, 14, 2407);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type !== (current_block_type = select_block_type_4(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(component, ctx);
					if (if_block) if_block.c();
					if (if_block) if_block.m(div, null);
				}

				if (changed.$device) {
					toggleClass(div, "connectivity_problem", ctx.$device.connectivityProblem);
					toggleClass(div, "connectivity_resumed", ctx.$device.connectivityResumed);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (58:53) 
	function create_if_block_10(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Internet connection resumed");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (56:16) {#if $device.connectivityProblem}
	function create_if_block_9(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Internet unreachable");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (64:12) {#if $device}
	function create_if_block_4$1(component, ctx) {
		var div, text0, text1, text2, if_block2_anchor, current;

		var if_block0 = (ctx.$device.ip) && create_if_block_7$1(component, ctx);

		var if_block1 = (ctx.$device.wifiAP || ctx.$device.apssid) && create_if_block_6$1(component, ctx);

		var nearbyhandylinks = new NearbyHandyLinks({
			root: component.root,
			store: component.store
		});

		var if_block2 = (ctx.$device.apMode && ctx.$device.apInfo) && create_if_block_5$1(component);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText("\n\n              ");
				if (if_block1) if_block1.c();
				text1 = createText("\n\n              ");
				nearbyhandylinks._fragment.c();
				text2 = createText("\n\n              ");
				if (if_block2) if_block2.c();
				if_block2_anchor = createComment();
				div.className = "ip svelte-1lf904p";
				addLoc(div, file$3, 64, 14, 2880);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				insert(target, text0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, text1, anchor);
				nearbyhandylinks._mount(target, anchor);
				insert(target, text2, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$device.ip) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_7$1(component, ctx);
						if_block0.c();
						if_block0.m(div, null);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.$device.wifiAP || ctx.$device.apssid) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_6$1(component, ctx);
						if_block1.c();
						if_block1.m(text1.parentNode, text1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$device.apMode && ctx.$device.apInfo) {
					if (!if_block2) {
						if_block2 = create_if_block_5$1(component);
						if_block2.c();
					}
					if_block2.i(if_block2_anchor.parentNode, if_block2_anchor);
				} else if (if_block2) {
					if_block2.o(function() {
						if_block2.d(1);
						if_block2 = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 2);

				if (nearbyhandylinks) nearbyhandylinks._fragment.o(outrocallback);

				if (if_block2) if_block2.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if (detach) {
					detachNode(text0);
				}

				if (if_block1) if_block1.d(detach);
				if (detach) {
					detachNode(text1);
				}

				nearbyhandylinks.destroy(detach);
				if (detach) {
					detachNode(text2);
				}

				if (if_block2) if_block2.d(detach);
				if (detach) {
					detachNode(if_block2_anchor);
				}
			}
		};
	}

	// (66:16) {#if $device.ip}
	function create_if_block_7$1(component, ctx) {
		var text_value = ctx.$device.ip, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$device) && text_value !== (text_value = ctx.$device.ip)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (71:14) {#if $device.wifiAP || $device.apssid}
	function create_if_block_6$1(component, ctx) {
		var div, text_value = ctx.$device.wifiAP || ctx.$device.apssid, text;

		return {
			c: function create() {
				div = createElement("div");
				text = createText(text_value);
				div.className = "wifi_ap svelte-1lf904p";
				addLoc(div, file$3, 71, 16, 3074);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$device) && text_value !== (text_value = ctx.$device.wifiAP || ctx.$device.apssid)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (77:14) {#if $device.apMode && $device.apInfo}
	function create_if_block_5$1(component, ctx) {
		var div, current;

		var apwificredentials = new ApWifiCredentials({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				div = createElement("div");
				apwificredentials._fragment.c();
				div.className = "ap_wifi_info svelte-1lf904p";
				addLoc(div, file$3, 77, 16, 3262);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				apwificredentials._mount(div, null);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (apwificredentials) apwificredentials._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				apwificredentials.destroy();
			}
		};
	}

	function TileBar(options) {
		this._debugName = '<TileBar>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<TileBar> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","device"]), options.data);
		this.store._add(this, ["connected","device"]);
		if (!('loaded' in this._state)) console.warn("<TileBar> was created without expected data property 'loaded'");
		if (!('$connected' in this._state)) console.warn("<TileBar> was created without expected data property '$connected'");
		if (!('$device' in this._state)) console.warn("<TileBar> was created without expected data property '$device'");
		if (!('atRPi' in this._state)) console.warn("<TileBar> was created without expected data property 'atRPi'");
		if (!('touchPressed' in this._state)) console.warn("<TileBar> was created without expected data property 'touchPressed'");
		if (!('isDevUser' in this._state)) console.warn("<TileBar> was created without expected data property 'isDevUser'");
		if (!('selectedDeviceName' in this._state)) console.warn("<TileBar> was created without expected data property 'selectedDeviceName'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._slotted = options.slots || {};

		this._fragment = create_main_fragment$3(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$2.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(TileBar.prototype, protoDev);
	assign(TileBar.prototype, methods$2);

	TileBar.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/PeerList.html generated by Svelte v2.16.1 */

	var methods$3 = {
	  peersToShow(peerlist, showPeerOnlyIfDisconnected) {
	    return peerlist.filter(({ ready }) => !showPeerOnlyIfDisconnected || (showPeerOnlyIfDisconnected && !ready));
	  }
	};

	function oncreate$3() {}
	const file$4 = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/PeerList.html";

	function get_each_context$1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.deviceTag = list[i].deviceTag;
		child_ctx.ready = list[i].ready;
		child_ctx.versionCompareSymbol = list[i].versionCompareSymbol;
		child_ctx.peerState = list[i].peerState;
		return child_ctx;
	}

	function create_main_fragment$4(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$thisDeviceState && ctx.$thisDeviceState.connected && ctx.$thisDeviceState.peerlist && ctx.$thisDeviceState.peerlist.length > 0) && create_if_block$4(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$thisDeviceState && ctx.$thisDeviceState.connected && ctx.$thisDeviceState.peerlist && ctx.$thisDeviceState.peerlist.length > 0) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$4(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $thisDeviceState && $thisDeviceState.connected && $thisDeviceState.peerlist && $thisDeviceState.peerlist.length > 0}
	function create_if_block$4(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.$thisDeviceState.peerlist.find(({ ready }) => !ctx.showPeerOnlyIfDisconnected || (ctx.showPeerOnlyIfDisconnected && !ready))) && create_if_block_1$3(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.$thisDeviceState.peerlist.find(({ ready }) => !ctx.showPeerOnlyIfDisconnected || (ctx.showPeerOnlyIfDisconnected && !ready))) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$3(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (3:2) {#if $thisDeviceState.peerlist.find(({ ready }) => !showPeerOnlyIfDisconnected || (showPeerOnlyIfDisconnected && !ready))}
	function create_if_block_1$3(component, ctx) {
		var div;

		var each_value = ctx.$thisDeviceState.peerlist;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(component, get_each_context$1(ctx, each_value, i));
		}

		return {
			c: function create() {
				div = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				div.id = "peerlist";
				div.className = "svelte-1pma8zx";
				addLoc(div, file$4, 3, 4, 298);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.showPeerOnlyIfDisconnected || changed.$thisDeviceState || changed.detailed) {
					each_value = ctx.$thisDeviceState.peerlist;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (10:8) {#if !showPeerOnlyIfDisconnected || (showPeerOnlyIfDisconnected && !ready)}
	function create_if_block_2$2(component, ctx) {
		var div, span0, text1, span1, text3, text4_value = ctx.deviceTag, text4, text5, text6;

		var if_block = (ctx.peerState) && create_if_block_3$2(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				span0 = createElement("span");
				span0.textContent = "ok";
				text1 = createText("\n            ");
				span1 = createElement("span");
				span1.textContent = "✖";
				text3 = createText("\n            ");
				text4 = createText(text4_value);
				text5 = createText("\n            ");
				if (if_block) if_block.c();
				text6 = createText("\n          ");
				span0.className = "ok svelte-1pma8zx";
				addLoc(span0, file$4, 11, 12, 702);
				span1.className = "cross svelte-1pma8zx";
				addLoc(span1, file$4, 12, 12, 741);
				div.className = "peer svelte-1pma8zx";
				toggleClass(div, "ready", ctx.ready == true);
				addLoc(div, file$4, 10, 10, 643);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, span0);
				append(div, text1);
				append(div, span1);
				append(div, text3);
				append(div, text4);
				append(div, text5);
				if (if_block) if_block.m(div, null);
				append(div, text6);
			},

			p: function update(changed, ctx) {
				if ((changed.$thisDeviceState) && text4_value !== (text4_value = ctx.deviceTag)) {
					setData(text4, text4_value);
				}

				if (ctx.peerState) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_3$2(component, ctx);
						if_block.c();
						if_block.m(div, text6);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.$thisDeviceState) {
					toggleClass(div, "ready", ctx.ready == true);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (15:12) {#if peerState}
	function create_if_block_3$2(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.peerState.dmtVersion) && create_if_block_4$2(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.peerState.dmtVersion) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_4$2(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (16:14) {#if peerState.dmtVersion}
	function create_if_block_4$2(component, ctx) {
		var span;

		var if_block = (ctx.detailed) && create_if_block_5$2(component, ctx);

		return {
			c: function create() {
				span = createElement("span");
				if (if_block) if_block.c();
				span.className = "dmt_version svelte-1pma8zx";
				addLoc(span, file$4, 16, 16, 879);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				if (if_block) if_block.m(span, null);
			},

			p: function update(changed, ctx) {
				if (ctx.detailed) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_5$2(component, ctx);
						if_block.c();
						if_block.m(span, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (18:18) {#if detailed}
	function create_if_block_5$2(component, ctx) {
		var text_value = ctx.peerState.dmtVersion, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$thisDeviceState) && text_value !== (text_value = ctx.peerState.dmtVersion)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (8:6) {#each $thisDeviceState.peerlist as { deviceTag, ready, versionCompareSymbol, peerState }}
	function create_each_block$1(component, ctx) {
		var if_block_anchor;

		var if_block = (!ctx.showPeerOnlyIfDisconnected || (ctx.showPeerOnlyIfDisconnected && !ctx.ready)) && create_if_block_2$2(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (!ctx.showPeerOnlyIfDisconnected || (ctx.showPeerOnlyIfDisconnected && !ctx.ready)) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_2$2(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	function PeerList(options) {
		this._debugName = '<PeerList>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<PeerList> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["thisDeviceState"]), options.data);
		this.store._add(this, ["thisDeviceState"]);
		if (!('$thisDeviceState' in this._state)) console.warn("<PeerList> was created without expected data property '$thisDeviceState'");
		if (!('showPeerOnlyIfDisconnected' in this._state)) console.warn("<PeerList> was created without expected data property 'showPeerOnlyIfDisconnected'");
		if (!('detailed' in this._state)) console.warn("<PeerList> was created without expected data property 'detailed'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$4(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$3.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(PeerList.prototype, protoDev);
	assign(PeerList.prototype, methods$3);

	PeerList.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	const img$1 = 'data:image/png;base64,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';

	class CssBridge {
	  // cities/Monaco1.jpg
	  setWallpaper(wallpaperSubPath) {
	    //console.log(wallpaperSubPath);
	    if (!wallpaperSubPath) {
	      document.body.style.backgroundImage = '';
	    } else if (wallpaperSubPath.startsWith('/')) {
	      document.body.style.backgroundImage = `url('${wallpaperSubPath}')`;
	    }
	  }

	  setBodyClass(className) {
	    const body = document.getElementsByTagName('body')[0];
	    body.className = className;
	  }
	}

	var css = new CssBridge();

	function log(msg) {
	  console.log(`${new Date().toLocaleString()} → ${msg}`);
	}

	function isInputElementActive() {
	  const { activeElement } = document;
	  const inputs = ['input', 'select', 'textarea']; //'button'

	  if (activeElement && inputs.indexOf(activeElement.tagName.toLowerCase()) !== -1) {
	    return true;
	  }
	}

	log.write = log; // nodejs compatibility in connect.js

	function dir(msg) {
	  console.log(`${new Date().toLocaleString()} → ${JSON.stringify(msg, null, 2)}`);
	}

	function pad(number, digits = 2) {
	  return Array(Math.max(digits - String(number).length + 1, 0)).join(0) + number;
	}

	function getDisplayTime(date) {
	  return `${pad(date.getHours())}:${pad(date.getMinutes())}`;
	}

	function unique(items) {
	  return [...new Set(items)];
	}

	function setWallpaper(wallpaper) {
	  if (wallpaper) {
	    css.setWallpaper(wallpaper);
	  } else {
	    css.setWallpaper('');
	  }
	}

	function msIntoTimeSpan(timeInMs, index = 0, result = {}) {
	  const times = ['day', 'h', 'min', 's'];
	  const arr = [24, 60, 60, 1000];

	  if (index == times.length) {
	    result['ms'] = timeInMs;
	    return result;
	  }

	  if (index == 0) {
	    result.totalSeconds = timeInMs / 1000.0;
	  }

	  const n = arr.slice(index).reduce((total, num) => total * num, 1);
	  result[times[index]] = Math.floor(timeInMs / n);

	  return msIntoTimeSpan(timeInMs % n, index + 1, result);
	}

	function humanTime(ts) {
	  const times = ['day', 'h', 'min', 's'];
	  let str = '';

	  for (const t of times) {
	    if (ts[t] > 0) {
	      if (t != 's' || (t == 's' && ts.totalSeconds < 60)) {
	        // show seconds only if time is under a minute
	        str = `${str} ${ts[t]} ${t}`;
	      }
	    }
	  }

	  return str.trim();
	}

	function songTime(s) {
	  s = Math.round(s);
	  const hours = Math.floor(s / 3600);
	  const rem = s % 3600;
	  const min = Math.floor(rem / 60);
	  s = rem % 60;

	  return hours ? `${hours}h ${pad(min)}min ${pad(s)}s` : `${min}:${pad(s)}`;
	}

	function colorJSON(json) {
	  if (typeof json != 'string') {
	    json = JSON.stringify(json, undefined, 2);
	  }
	  json = json
	    .replace(/&/g, '&amp;')
	    .replace(/</g, '&lt;')
	    .replace(/>/g, '&gt;');
	  return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(match) {
	    var cls = 'number';
	    var color = 'yellow';
	    if (/^"/.test(match)) {
	      if (/:$/.test(match)) {
	        cls = 'key';
	        color = 'cyan';
	      } else {
	        cls = 'string';
	        color = '#66F62A';
	      }
	    } else if (/true|false/.test(match)) {
	      cls = 'boolean';
	      color = 'orange';
	    } else if (/null/.test(match)) {
	      cls = 'null';
	      color = 'red';
	    }
	    //return {cls, text: match};
	    return `<span style="color: ${color}" class="${cls}">${match}</span>`;
	  });
	}

	// Uint8Array to string in Javascript
	// https://stackoverflow.com/a/22373197
	function Utf8ArrayToStr(array) {
	  let out;
	  let i;
	  let c;
	  let char2;
	  let char3;

	  out = '';

	  const len = array.length;

	  i = 0;

	  while (i < len) {
	    c = array[i++];

	    switch (c >> 4) {
	      case 0:
	      case 1:
	      case 2:
	      case 3:
	      case 4:
	      case 5:
	      case 6:
	      case 7:
	        // 0xxxxxxx
	        out += String.fromCharCode(c);
	        break;
	      case 12:
	      case 13:
	        // 110x xxxx   10xx xxxx
	        char2 = array[i++];
	        out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f));
	        break;
	      case 14:
	        // 1110 xxxx  10xx xxxx  10xx xxxx
	        char2 = array[i++];
	        char3 = array[i++];
	        out += String.fromCharCode(((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0));
	        break;
	    }
	  }

	  return out;
	}

	function listify(obj) {
	  if (typeof obj == 'undefined' || obj == null) {
	    return [];
	  }
	  return Array.isArray(obj) ? obj : [obj];
	}

	function bufferToHex(buffer) {
	  return Array.from(new Uint8Array(buffer))
	    .map(b => b.toString(16).padStart(2, '0'))
	    .join('');
	}

	function hexToBuffer(hex) {
	  const tokens = hex.match(/.{1,2}(?=(.{2})+(?!.))|.{1,2}$/g); // split by two, https://blog.abelotech.com/posts/split-string-tokens-defined-length-javascript/
	  return new Uint8Array(tokens.map(token => parseInt(token, 16)));
	}

	var util = {
	  log,
	  dir,
	  pad,
	  getDisplayTime,
	  unique,
	  setWallpaper,
	  msIntoTimeSpan,
	  humanTime,
	  songTime,
	  colorJSON,
	  Utf8ArrayToStr,
	  isInputElementActive,
	  listify,
	  bufferToHex,
	  hexToBuffer
	};

	function wrap(text, color) {
	  return `<span style="color: ${color};">${text}</span>`;
	}

	function red(text) {
	  return wrap(text, '#E34042');
	}

	function green(text) {
	  return wrap(text, '#5FE02A');
	}

	function gray(text) {
	  return wrap(text, 'gray');
	}

	function yellow(text) {
	  return wrap(text, '#E5AE34');
	}

	function cyan(text) {
	  return wrap(text, '#29B3BF');
	}

	function magenta(text) {
	  return wrap(text, '#A144E9');
	}

	var colorsDmt = { red, green, gray, yellow, cyan, magenta };

	function Store(state, options) {
		this._handlers = {};
		this._dependents = [];

		this._computed = blankObject();
		this._sortedComputedProperties = [];

		this._state = assign({}, state);
		this._differs = options && options.immutable ? _differsImmutable : _differs;
	}

	assign(Store.prototype, {
		_add(component, props) {
			this._dependents.push({
				component: component,
				props: props
			});
		},

		_init(props) {
			const state = {};
			for (let i = 0; i < props.length; i += 1) {
				const prop = props[i];
				state['$' + prop] = this._state[prop];
			}
			return state;
		},

		_remove(component) {
			let i = this._dependents.length;
			while (i--) {
				if (this._dependents[i].component === component) {
					this._dependents.splice(i, 1);
					return;
				}
			}
		},

		_set(newState, changed) {
			const previous = this._state;
			this._state = assign(assign({}, previous), newState);

			for (let i = 0; i < this._sortedComputedProperties.length; i += 1) {
				this._sortedComputedProperties[i].update(this._state, changed);
			}

			this.fire('state', {
				changed,
				previous,
				current: this._state
			});

			this._dependents
				.filter(dependent => {
					const componentState = {};
					let dirty = false;

					for (let j = 0; j < dependent.props.length; j += 1) {
						const prop = dependent.props[j];
						if (prop in changed) {
							componentState['$' + prop] = this._state[prop];
							dirty = true;
						}
					}

					if (dirty) {
						dependent.component._stage(componentState);
						return true;
					}
				})
				.forEach(dependent => {
					dependent.component.set({});
				});

			this.fire('update', {
				changed,
				previous,
				current: this._state
			});
		},

		_sortComputedProperties() {
			const computed = this._computed;
			const sorted = this._sortedComputedProperties = [];
			const visited = blankObject();
			let currentKey;

			function visit(key) {
				const c = computed[key];

				if (c) {
					c.deps.forEach(dep => {
						if (dep === currentKey) {
							throw new Error(`Cyclical dependency detected between ${dep} <-> ${key}`);
						}

						visit(dep);
					});

					if (!visited[key]) {
						visited[key] = true;
						sorted.push(c);
					}
				}
			}

			for (const key in this._computed) {
				visit(currentKey = key);
			}
		},

		compute(key, deps, fn) {
			let value;

			const c = {
				deps,
				update: (state, changed, dirty) => {
					const values = deps.map(dep => {
						if (dep in changed) dirty = true;
						return state[dep];
					});

					if (dirty) {
						const newValue = fn.apply(null, values);
						if (this._differs(newValue, value)) {
							value = newValue;
							changed[key] = true;
							state[key] = value;
						}
					}
				}
			};

			this._computed[key] = c;
			this._sortComputedProperties();

			const state = assign({}, this._state);
			const changed = {};
			c.update(state, changed, true);
			this._set(state, changed);
		},

		fire,

		get,

		on,

		set(newState) {
			const oldState = this._state;
			const changed = this._changed = {};
			let dirty = false;

			for (const key in newState) {
				if (this._computed[key]) throw new Error(`'${key}' is a read-only computed property`);
				if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
			}
			if (!dirty) return;

			this._set(newState, changed);
		}
	});

	/*!
	 * https://github.com/Starcounter-Jack/JSON-Patch
	 * (c) 2017 Joachim Wester
	 * MIT license
	 */
	var __extends = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	function hasOwnProperty(obj, key) {
	    return _hasOwnProperty.call(obj, key);
	}
	function _objectKeys(obj) {
	    if (Array.isArray(obj)) {
	        var keys = new Array(obj.length);
	        for (var k = 0; k < keys.length; k++) {
	            keys[k] = "" + k;
	        }
	        return keys;
	    }
	    if (Object.keys) {
	        return Object.keys(obj);
	    }
	    var keys = [];
	    for (var i in obj) {
	        if (hasOwnProperty(obj, i)) {
	            keys.push(i);
	        }
	    }
	    return keys;
	}
	/**
	* Deeply clone the object.
	* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
	* @param  {any} obj value to clone
	* @return {any} cloned obj
	*/
	function _deepClone(obj) {
	    switch (typeof obj) {
	        case "object":
	            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
	        case "undefined":
	            return null; //this is how JSON.stringify behaves for array items
	        default:
	            return obj; //no need to clone primitives
	    }
	}
	//3x faster than cached /^\d+$/.test(str)
	function isInteger(str) {
	    var i = 0;
	    var len = str.length;
	    var charCode;
	    while (i < len) {
	        charCode = str.charCodeAt(i);
	        if (charCode >= 48 && charCode <= 57) {
	            i++;
	            continue;
	        }
	        return false;
	    }
	    return true;
	}
	/**
	* Escapes a json pointer path
	* @param path The raw pointer
	* @return the Escaped path
	*/
	function escapePathComponent(path) {
	    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
	        return path;
	    return path.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	/**
	 * Unescapes a json pointer path
	 * @param path The escaped pointer
	 * @return The unescaped path
	 */
	function unescapePathComponent(path) {
	    return path.replace(/~1/g, '/').replace(/~0/g, '~');
	}
	/**
	* Recursively checks whether an object has any undefined values inside.
	*/
	function hasUndefined(obj) {
	    if (obj === undefined) {
	        return true;
	    }
	    if (obj) {
	        if (Array.isArray(obj)) {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                if (hasUndefined(obj[i])) {
	                    return true;
	                }
	            }
	        }
	        else if (typeof obj === "object") {
	            var objKeys = _objectKeys(obj);
	            var objKeysLength = objKeys.length;
	            for (var i = 0; i < objKeysLength; i++) {
	                if (hasUndefined(obj[objKeys[i]])) {
	                    return true;
	                }
	            }
	        }
	    }
	    return false;
	}
	function patchErrorMessageFormatter(message, args) {
	    var messageParts = [message];
	    for (var key in args) {
	        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
	        if (typeof value !== 'undefined') {
	            messageParts.push(key + ": " + value);
	        }
	    }
	    return messageParts.join('\n');
	}
	var PatchError = /** @class */ (function (_super) {
	    __extends(PatchError, _super);
	    function PatchError(message, name, index, operation, tree) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;
	        _this.name = name;
	        _this.index = index;
	        _this.operation = operation;
	        _this.tree = tree;
	        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
	        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });
	        return _this;
	    }
	    return PatchError;
	}(Error));

	var JsonPatchError = PatchError;
	var deepClone = _deepClone;
	/* We use a Javascript hash to store each
	 function. Each hash entry (property) uses
	 the operation identifiers specified in rfc6902.
	 In this way, we can map each patch operation
	 to its dedicated function in efficient way.
	 */
	/* The operations applicable to an object */
	var objOps = {
	    add: function (obj, key, document) {
	        obj[key] = this.value;
	        return { newDocument: document };
	    },
	    remove: function (obj, key, document) {
	        var removed = obj[key];
	        delete obj[key];
	        return { newDocument: document, removed: removed };
	    },
	    replace: function (obj, key, document) {
	        var removed = obj[key];
	        obj[key] = this.value;
	        return { newDocument: document, removed: removed };
	    },
	    move: function (obj, key, document) {
	        /* in case move target overwrites an existing value,
	        return the removed value, this can be taxing performance-wise,
	        and is potentially unneeded */
	        var removed = getValueByPointer(document, this.path);
	        if (removed) {
	            removed = _deepClone(removed);
	        }
	        var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
	        applyOperation(document, { op: "add", path: this.path, value: originalValue });
	        return { newDocument: document, removed: removed };
	    },
	    copy: function (obj, key, document) {
	        var valueToCopy = getValueByPointer(document, this.from);
	        // enforce copy by value so further operations don't affect source (see issue #177)
	        applyOperation(document, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
	        return { newDocument: document };
	    },
	    test: function (obj, key, document) {
	        return { newDocument: document, test: _areEquals(obj[key], this.value) };
	    },
	    _get: function (obj, key, document) {
	        this.value = obj[key];
	        return { newDocument: document };
	    }
	};
	/* The operations applicable to an array. Many are the same as for the object */
	var arrOps = {
	    add: function (arr, i, document) {
	        if (isInteger(i)) {
	            arr.splice(i, 0, this.value);
	        }
	        else { // array props
	            arr[i] = this.value;
	        }
	        // this may be needed when using '-' in an array
	        return { newDocument: document, index: i };
	    },
	    remove: function (arr, i, document) {
	        var removedList = arr.splice(i, 1);
	        return { newDocument: document, removed: removedList[0] };
	    },
	    replace: function (arr, i, document) {
	        var removed = arr[i];
	        arr[i] = this.value;
	        return { newDocument: document, removed: removed };
	    },
	    move: objOps.move,
	    copy: objOps.copy,
	    test: objOps.test,
	    _get: objOps._get
	};
	/**
	 * Retrieves a value from a JSON document by a JSON pointer.
	 * Returns the value.
	 *
	 * @param document The document to get the value from
	 * @param pointer an escaped JSON pointer
	 * @return The retrieved value
	 */
	function getValueByPointer(document, pointer) {
	    if (pointer == '') {
	        return document;
	    }
	    var getOriginalDestination = { op: "_get", path: pointer };
	    applyOperation(document, getOriginalDestination);
	    return getOriginalDestination.value;
	}
	/**
	 * Apply a single JSON Patch Operation on a JSON document.
	 * Returns the {newDocument, result} of the operation.
	 * It modifies the `document` and `operation` objects - it gets the values by reference.
	 * If you would like to avoid touching your values, clone them:
	 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
	 *
	 * @param document The document to patch
	 * @param operation The operation to apply
	 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
	 * @param mutateDocument Whether to mutate the original document or clone it before applying
	 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
	 * @return `{newDocument, result}` after the operation
	 */
	function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
	    if (validateOperation === void 0) { validateOperation = false; }
	    if (mutateDocument === void 0) { mutateDocument = true; }
	    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
	    if (index === void 0) { index = 0; }
	    if (validateOperation) {
	        if (typeof validateOperation == 'function') {
	            validateOperation(operation, 0, document, operation.path);
	        }
	        else {
	            validator(operation, 0);
	        }
	    }
	    /* ROOT OPERATIONS */
	    if (operation.path === "") {
	        var returnValue = { newDocument: document };
	        if (operation.op === 'add') {
	            returnValue.newDocument = operation.value;
	            return returnValue;
	        }
	        else if (operation.op === 'replace') {
	            returnValue.newDocument = operation.value;
	            returnValue.removed = document; //document we removed
	            return returnValue;
	        }
	        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
	            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field
	            if (operation.op === 'move') { // report removed item
	                returnValue.removed = document;
	            }
	            return returnValue;
	        }
	        else if (operation.op === 'test') {
	            returnValue.test = _areEquals(document, operation.value);
	            if (returnValue.test === false) {
	                throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
	            }
	            returnValue.newDocument = document;
	            return returnValue;
	        }
	        else if (operation.op === 'remove') { // a remove on root
	            returnValue.removed = document;
	            returnValue.newDocument = null;
	            return returnValue;
	        }
	        else if (operation.op === '_get') {
	            operation.value = document;
	            return returnValue;
	        }
	        else { /* bad operation */
	            if (validateOperation) {
	                throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
	            }
	            else {
	                return returnValue;
	            }
	        }
	    } /* END ROOT OPERATIONS */
	    else {
	        if (!mutateDocument) {
	            document = _deepClone(document);
	        }
	        var path = operation.path || "";
	        var keys = path.split('/');
	        var obj = document;
	        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
	        var len = keys.length;
	        var existingPathFragment = undefined;
	        var key = void 0;
	        var validateFunction = void 0;
	        if (typeof validateOperation == 'function') {
	            validateFunction = validateOperation;
	        }
	        else {
	            validateFunction = validator;
	        }
	        while (true) {
	            key = keys[t];
	            if (banPrototypeModifications && key == '__proto__') {
	                throw new TypeError('JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
	            }
	            if (validateOperation) {
	                if (existingPathFragment === undefined) {
	                    if (obj[key] === undefined) {
	                        existingPathFragment = keys.slice(0, t).join('/');
	                    }
	                    else if (t == len - 1) {
	                        existingPathFragment = operation.path;
	                    }
	                    if (existingPathFragment !== undefined) {
	                        validateFunction(operation, 0, document, existingPathFragment);
	                    }
	                }
	            }
	            t++;
	            if (Array.isArray(obj)) {
	                if (key === '-') {
	                    key = obj.length;
	                }
	                else {
	                    if (validateOperation && !isInteger(key)) {
	                        throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
	                    } // only parse key when it's an integer for `arr.prop` to work
	                    else if (isInteger(key)) {
	                        key = ~~key;
	                    }
	                }
	                if (t >= len) {
	                    if (validateOperation && operation.op === "add" && key > obj.length) {
	                        throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
	                    }
	                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch
	                    if (returnValue.test === false) {
	                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
	                    }
	                    return returnValue;
	                }
	            }
	            else {
	                if (key && key.indexOf('~') != -1) {
	                    key = unescapePathComponent(key);
	                }
	                if (t >= len) {
	                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch
	                    if (returnValue.test === false) {
	                        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
	                    }
	                    return returnValue;
	                }
	            }
	            obj = obj[key];
	        }
	    }
	}
	/**
	 * Apply a full JSON Patch array on a JSON document.
	 * Returns the {newDocument, result} of the patch.
	 * It modifies the `document` object and `patch` - it gets the values by reference.
	 * If you would like to avoid touching your values, clone them:
	 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
	 *
	 * @param document The document to patch
	 * @param patch The patch to apply
	 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
	 * @param mutateDocument Whether to mutate the original document or clone it before applying
	 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
	 * @return An array of `{newDocument, result}` after the patch
	 */
	function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
	    if (mutateDocument === void 0) { mutateDocument = true; }
	    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
	    if (validateOperation) {
	        if (!Array.isArray(patch)) {
	            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
	        }
	    }
	    if (!mutateDocument) {
	        document = _deepClone(document);
	    }
	    var results = new Array(patch.length);
	    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
	        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
	        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
	        document = results[i].newDocument; // in case root was replaced
	    }
	    results.newDocument = document;
	    return results;
	}
	/**
	 * Apply a single JSON Patch Operation on a JSON document.
	 * Returns the updated document.
	 * Suitable as a reducer.
	 *
	 * @param document The document to patch
	 * @param operation The operation to apply
	 * @return The updated document
	 */
	function applyReducer(document, operation, index) {
	    var operationResult = applyOperation(document, operation);
	    if (operationResult.test === false) { // failed test
	        throw new JsonPatchError("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
	    }
	    return operationResult.newDocument;
	}
	/**
	 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
	 * @param {object} operation - operation object (patch)
	 * @param {number} index - index of operation in the sequence
	 * @param {object} [document] - object where the operation is supposed to be applied
	 * @param {string} [existingPathFragment] - comes along with `document`
	 */
	function validator(operation, index, document, existingPathFragment) {
	    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
	        throw new JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
	    }
	    else if (!objOps[operation.op]) {
	        throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
	    }
	    else if (typeof operation.path !== 'string') {
	        throw new JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
	    }
	    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
	        // paths that aren't empty string should start with "/"
	        throw new JsonPatchError('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
	    }
	    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
	        throw new JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
	    }
	    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
	        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
	    }
	    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && hasUndefined(operation.value)) {
	        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
	    }
	    else if (document) {
	        if (operation.op == "add") {
	            var pathLen = operation.path.split("/").length;
	            var existingPathLen = existingPathFragment.split("/").length;
	            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
	                throw new JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
	            }
	        }
	        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
	            if (operation.path !== existingPathFragment) {
	                throw new JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
	            }
	        }
	        else if (operation.op === 'move' || operation.op === 'copy') {
	            var existingValue = { op: "_get", path: operation.from, value: undefined };
	            var error = validate([existingValue], document);
	            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
	                throw new JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
	            }
	        }
	    }
	}
	/**
	 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
	 * If error is encountered, returns a JsonPatchError object
	 * @param sequence
	 * @param document
	 * @returns {JsonPatchError|undefined}
	 */
	function validate(sequence, document, externalValidator) {
	    try {
	        if (!Array.isArray(sequence)) {
	            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
	        }
	        if (document) {
	            //clone document and sequence so that we can safely try applying operations
	            applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || true);
	        }
	        else {
	            externalValidator = externalValidator || validator;
	            for (var i = 0; i < sequence.length; i++) {
	                externalValidator(sequence[i], i, document, undefined);
	            }
	        }
	    }
	    catch (e) {
	        if (e instanceof JsonPatchError) {
	            return e;
	        }
	        else {
	            throw e;
	        }
	    }
	}
	// based on https://github.com/epoberezkin/fast-deep-equal
	// MIT License
	// Copyright (c) 2017 Evgeny Poberezkin
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	// The above copyright notice and this permission notice shall be included in all
	// copies or substantial portions of the Software.
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	// SOFTWARE.
	function _areEquals(a, b) {
	    if (a === b)
	        return true;
	    if (a && b && typeof a == 'object' && typeof b == 'object') {
	        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
	        if (arrA && arrB) {
	            length = a.length;
	            if (length != b.length)
	                return false;
	            for (i = length; i-- !== 0;)
	                if (!_areEquals(a[i], b[i]))
	                    return false;
	            return true;
	        }
	        if (arrA != arrB)
	            return false;
	        var keys = Object.keys(a);
	        length = keys.length;
	        if (length !== Object.keys(b).length)
	            return false;
	        for (i = length; i-- !== 0;)
	            if (!b.hasOwnProperty(keys[i]))
	                return false;
	        for (i = length; i-- !== 0;) {
	            key = keys[i];
	            if (!_areEquals(a[key], b[key]))
	                return false;
	        }
	        return true;
	    }
	    return a !== a && b !== b;
	}

	var core = /*#__PURE__*/Object.freeze({
		__proto__: null,
		JsonPatchError: JsonPatchError,
		deepClone: deepClone,
		getValueByPointer: getValueByPointer,
		applyOperation: applyOperation,
		applyPatch: applyPatch,
		applyReducer: applyReducer,
		validator: validator,
		validate: validate,
		_areEquals: _areEquals
	});

	/*!
	 * https://github.com/Starcounter-Jack/JSON-Patch
	 * (c) 2017 Joachim Wester
	 * MIT license
	 */
	var beforeDict = new WeakMap();
	var Mirror = /** @class */ (function () {
	    function Mirror(obj) {
	        this.observers = new Map();
	        this.obj = obj;
	    }
	    return Mirror;
	}());
	var ObserverInfo = /** @class */ (function () {
	    function ObserverInfo(callback, observer) {
	        this.callback = callback;
	        this.observer = observer;
	    }
	    return ObserverInfo;
	}());
	function getMirror(obj) {
	    return beforeDict.get(obj);
	}
	function getObserverFromMirror(mirror, callback) {
	    return mirror.observers.get(callback);
	}
	function removeObserverFromMirror(mirror, observer) {
	    mirror.observers.delete(observer.callback);
	}
	/**
	 * Detach an observer from an object
	 */
	function unobserve(root, observer) {
	    observer.unobserve();
	}
	/**
	 * Observes changes made to an object, which can then be retrieved using generate
	 */
	function observe(obj, callback) {
	    var patches = [];
	    var observer;
	    var mirror = getMirror(obj);
	    if (!mirror) {
	        mirror = new Mirror(obj);
	        beforeDict.set(obj, mirror);
	    }
	    else {
	        var observerInfo = getObserverFromMirror(mirror, callback);
	        observer = observerInfo && observerInfo.observer;
	    }
	    if (observer) {
	        return observer;
	    }
	    observer = {};
	    mirror.value = _deepClone(obj);
	    if (callback) {
	        observer.callback = callback;
	        observer.next = null;
	        var dirtyCheck = function () {
	            generate(observer);
	        };
	        var fastCheck = function () {
	            clearTimeout(observer.next);
	            observer.next = setTimeout(dirtyCheck);
	        };
	        if (typeof window !== 'undefined') { //not Node
	            window.addEventListener('mouseup', fastCheck);
	            window.addEventListener('keyup', fastCheck);
	            window.addEventListener('mousedown', fastCheck);
	            window.addEventListener('keydown', fastCheck);
	            window.addEventListener('change', fastCheck);
	        }
	    }
	    observer.patches = patches;
	    observer.object = obj;
	    observer.unobserve = function () {
	        generate(observer);
	        clearTimeout(observer.next);
	        removeObserverFromMirror(mirror, observer);
	        if (typeof window !== 'undefined') {
	            window.removeEventListener('mouseup', fastCheck);
	            window.removeEventListener('keyup', fastCheck);
	            window.removeEventListener('mousedown', fastCheck);
	            window.removeEventListener('keydown', fastCheck);
	            window.removeEventListener('change', fastCheck);
	        }
	    };
	    mirror.observers.set(callback, new ObserverInfo(callback, observer));
	    return observer;
	}
	/**
	 * Generate an array of patches from an observer
	 */
	function generate(observer, invertible) {
	    if (invertible === void 0) { invertible = false; }
	    var mirror = beforeDict.get(observer.object);
	    _generate(mirror.value, observer.object, observer.patches, "", invertible);
	    if (observer.patches.length) {
	        applyPatch(mirror.value, observer.patches);
	    }
	    var temp = observer.patches;
	    if (temp.length > 0) {
	        observer.patches = [];
	        if (observer.callback) {
	            observer.callback(temp);
	        }
	    }
	    return temp;
	}
	// Dirty check if obj is different from mirror, generate patches and update mirror
	function _generate(mirror, obj, patches, path, invertible) {
	    if (obj === mirror) {
	        return;
	    }
	    if (typeof obj.toJSON === "function") {
	        obj = obj.toJSON();
	    }
	    var newKeys = _objectKeys(obj);
	    var oldKeys = _objectKeys(mirror);
	    var deleted = false;
	    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
	    for (var t = oldKeys.length - 1; t >= 0; t--) {
	        var key = oldKeys[t];
	        var oldVal = mirror[key];
	        if (hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
	            var newVal = obj[key];
	            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
	                _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key), invertible);
	            }
	            else {
	                if (oldVal !== newVal) {
	                    if (invertible) {
	                        patches.push({ op: "test", path: path + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
	                    }
	                    patches.push({ op: "replace", path: path + "/" + escapePathComponent(key), value: _deepClone(newVal) });
	                }
	            }
	        }
	        else if (Array.isArray(mirror) === Array.isArray(obj)) {
	            if (invertible) {
	                patches.push({ op: "test", path: path + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
	            }
	            patches.push({ op: "remove", path: path + "/" + escapePathComponent(key) });
	            deleted = true; // property has been deleted
	        }
	        else {
	            if (invertible) {
	                patches.push({ op: "test", path: path, value: mirror });
	            }
	            patches.push({ op: "replace", path: path, value: obj });
	        }
	    }
	    if (!deleted && newKeys.length == oldKeys.length) {
	        return;
	    }
	    for (var t = 0; t < newKeys.length; t++) {
	        var key = newKeys[t];
	        if (!hasOwnProperty(mirror, key) && obj[key] !== undefined) {
	            patches.push({ op: "add", path: path + "/" + escapePathComponent(key), value: _deepClone(obj[key]) });
	        }
	    }
	}
	/**
	 * Create an array of patches from the differences in two objects
	 */
	function compare(tree1, tree2, invertible) {
	    if (invertible === void 0) { invertible = false; }
	    var patches = [];
	    _generate(tree1, tree2, patches, '', invertible);
	    return patches;
	}

	var duplex = /*#__PURE__*/Object.freeze({
		__proto__: null,
		unobserve: unobserve,
		observe: observe,
		generate: generate,
		compare: compare
	});

	Object.assign({}, core, duplex, {
	    JsonPatchError: PatchError,
	    deepClone: _deepClone,
	    escapePathComponent,
	    unescapePathComponent
	});

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
			path: basedir,
			exports: {},
			require: function (path, base) {
				return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
			}
		}, fn(module, module.exports), module.exports;
	}

	function getAugmentedNamespace(n) {
		if (n.__esModule) return n;
		var a = Object.defineProperty({}, '__esModule', {value: true});
		Object.keys(n).forEach(function (k) {
			var d = Object.getOwnPropertyDescriptor(n, k);
			Object.defineProperty(a, k, d.get ? d : {
				enumerable: true,
				get: function () {
					return n[k];
				}
			});
		});
		return a;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': _nodeResolve_empty
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

	var naclFast = createCommonjsModule(function (module) {
	(function(nacl) {

	// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
	// Public domain.
	//
	// Implementation derived from TweetNaCl version 20140427.
	// See for details: http://tweetnacl.cr.yp.to/

	var gf = function(init) {
	  var i, r = new Float64Array(16);
	  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
	  return r;
	};

	//  Pluggable, initialized in high-level API below.
	var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

	var _0 = new Uint8Array(16);
	var _9 = new Uint8Array(32); _9[0] = 9;

	var gf0 = gf(),
	    gf1 = gf([1]),
	    _121665 = gf([0xdb41, 1]),
	    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
	    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
	    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
	    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
	    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

	function ts64(x, i, h, l) {
	  x[i]   = (h >> 24) & 0xff;
	  x[i+1] = (h >> 16) & 0xff;
	  x[i+2] = (h >>  8) & 0xff;
	  x[i+3] = h & 0xff;
	  x[i+4] = (l >> 24)  & 0xff;
	  x[i+5] = (l >> 16)  & 0xff;
	  x[i+6] = (l >>  8)  & 0xff;
	  x[i+7] = l & 0xff;
	}

	function vn(x, xi, y, yi, n) {
	  var i,d = 0;
	  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
	  return (1 & ((d - 1) >>> 8)) - 1;
	}

	function crypto_verify_16(x, xi, y, yi) {
	  return vn(x,xi,y,yi,16);
	}

	function crypto_verify_32(x, xi, y, yi) {
	  return vn(x,xi,y,yi,32);
	}

	function core_salsa20(o, p, k, c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;

	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);

	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }
	   x0 =  x0 +  j0 | 0;
	   x1 =  x1 +  j1 | 0;
	   x2 =  x2 +  j2 | 0;
	   x3 =  x3 +  j3 | 0;
	   x4 =  x4 +  j4 | 0;
	   x5 =  x5 +  j5 | 0;
	   x6 =  x6 +  j6 | 0;
	   x7 =  x7 +  j7 | 0;
	   x8 =  x8 +  j8 | 0;
	   x9 =  x9 +  j9 | 0;
	  x10 = x10 + j10 | 0;
	  x11 = x11 + j11 | 0;
	  x12 = x12 + j12 | 0;
	  x13 = x13 + j13 | 0;
	  x14 = x14 + j14 | 0;
	  x15 = x15 + j15 | 0;

	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;

	  o[ 4] = x1 >>>  0 & 0xff;
	  o[ 5] = x1 >>>  8 & 0xff;
	  o[ 6] = x1 >>> 16 & 0xff;
	  o[ 7] = x1 >>> 24 & 0xff;

	  o[ 8] = x2 >>>  0 & 0xff;
	  o[ 9] = x2 >>>  8 & 0xff;
	  o[10] = x2 >>> 16 & 0xff;
	  o[11] = x2 >>> 24 & 0xff;

	  o[12] = x3 >>>  0 & 0xff;
	  o[13] = x3 >>>  8 & 0xff;
	  o[14] = x3 >>> 16 & 0xff;
	  o[15] = x3 >>> 24 & 0xff;

	  o[16] = x4 >>>  0 & 0xff;
	  o[17] = x4 >>>  8 & 0xff;
	  o[18] = x4 >>> 16 & 0xff;
	  o[19] = x4 >>> 24 & 0xff;

	  o[20] = x5 >>>  0 & 0xff;
	  o[21] = x5 >>>  8 & 0xff;
	  o[22] = x5 >>> 16 & 0xff;
	  o[23] = x5 >>> 24 & 0xff;

	  o[24] = x6 >>>  0 & 0xff;
	  o[25] = x6 >>>  8 & 0xff;
	  o[26] = x6 >>> 16 & 0xff;
	  o[27] = x6 >>> 24 & 0xff;

	  o[28] = x7 >>>  0 & 0xff;
	  o[29] = x7 >>>  8 & 0xff;
	  o[30] = x7 >>> 16 & 0xff;
	  o[31] = x7 >>> 24 & 0xff;

	  o[32] = x8 >>>  0 & 0xff;
	  o[33] = x8 >>>  8 & 0xff;
	  o[34] = x8 >>> 16 & 0xff;
	  o[35] = x8 >>> 24 & 0xff;

	  o[36] = x9 >>>  0 & 0xff;
	  o[37] = x9 >>>  8 & 0xff;
	  o[38] = x9 >>> 16 & 0xff;
	  o[39] = x9 >>> 24 & 0xff;

	  o[40] = x10 >>>  0 & 0xff;
	  o[41] = x10 >>>  8 & 0xff;
	  o[42] = x10 >>> 16 & 0xff;
	  o[43] = x10 >>> 24 & 0xff;

	  o[44] = x11 >>>  0 & 0xff;
	  o[45] = x11 >>>  8 & 0xff;
	  o[46] = x11 >>> 16 & 0xff;
	  o[47] = x11 >>> 24 & 0xff;

	  o[48] = x12 >>>  0 & 0xff;
	  o[49] = x12 >>>  8 & 0xff;
	  o[50] = x12 >>> 16 & 0xff;
	  o[51] = x12 >>> 24 & 0xff;

	  o[52] = x13 >>>  0 & 0xff;
	  o[53] = x13 >>>  8 & 0xff;
	  o[54] = x13 >>> 16 & 0xff;
	  o[55] = x13 >>> 24 & 0xff;

	  o[56] = x14 >>>  0 & 0xff;
	  o[57] = x14 >>>  8 & 0xff;
	  o[58] = x14 >>> 16 & 0xff;
	  o[59] = x14 >>> 24 & 0xff;

	  o[60] = x15 >>>  0 & 0xff;
	  o[61] = x15 >>>  8 & 0xff;
	  o[62] = x15 >>> 16 & 0xff;
	  o[63] = x15 >>> 24 & 0xff;
	}

	function core_hsalsa20(o,p,k,c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;

	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);

	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }

	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;

	  o[ 4] = x5 >>>  0 & 0xff;
	  o[ 5] = x5 >>>  8 & 0xff;
	  o[ 6] = x5 >>> 16 & 0xff;
	  o[ 7] = x5 >>> 24 & 0xff;

	  o[ 8] = x10 >>>  0 & 0xff;
	  o[ 9] = x10 >>>  8 & 0xff;
	  o[10] = x10 >>> 16 & 0xff;
	  o[11] = x10 >>> 24 & 0xff;

	  o[12] = x15 >>>  0 & 0xff;
	  o[13] = x15 >>>  8 & 0xff;
	  o[14] = x15 >>> 16 & 0xff;
	  o[15] = x15 >>> 24 & 0xff;

	  o[16] = x6 >>>  0 & 0xff;
	  o[17] = x6 >>>  8 & 0xff;
	  o[18] = x6 >>> 16 & 0xff;
	  o[19] = x6 >>> 24 & 0xff;

	  o[20] = x7 >>>  0 & 0xff;
	  o[21] = x7 >>>  8 & 0xff;
	  o[22] = x7 >>> 16 & 0xff;
	  o[23] = x7 >>> 24 & 0xff;

	  o[24] = x8 >>>  0 & 0xff;
	  o[25] = x8 >>>  8 & 0xff;
	  o[26] = x8 >>> 16 & 0xff;
	  o[27] = x8 >>> 24 & 0xff;

	  o[28] = x9 >>>  0 & 0xff;
	  o[29] = x9 >>>  8 & 0xff;
	  o[30] = x9 >>> 16 & 0xff;
	  o[31] = x9 >>> 24 & 0xff;
	}

	function crypto_core_salsa20(out,inp,k,c) {
	  core_salsa20(out,inp,k,c);
	}

	function crypto_core_hsalsa20(out,inp,k,c) {
	  core_hsalsa20(out,inp,k,c);
	}

	var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
	            // "expand 32-byte k"

	function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	    mpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	  }
	  return 0;
	}

	function crypto_stream_salsa20(c,cpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = x[i];
	  }
	  return 0;
	}

	function crypto_stream(c,cpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20(c,cpos,d,sn,s);
	}

	function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
	}

	/*
	* Port of Andrew Moon's Poly1305-donna-16. Public domain.
	* https://github.com/floodyberry/poly1305-donna
	*/

	var poly1305 = function(key) {
	  this.buffer = new Uint8Array(16);
	  this.r = new Uint16Array(10);
	  this.h = new Uint16Array(10);
	  this.pad = new Uint16Array(8);
	  this.leftover = 0;
	  this.fin = 0;

	  var t0, t1, t2, t3, t4, t5, t6, t7;

	  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
	  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
	  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
	  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
	  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
	  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	  this.r[9] = ((t7 >>>  5)) & 0x007f;

	  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
	  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
	  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
	  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
	  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
	  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
	  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
	  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
	};

	poly1305.prototype.blocks = function(m, mpos, bytes) {
	  var hibit = this.fin ? 0 : (1 << 11);
	  var t0, t1, t2, t3, t4, t5, t6, t7, c;
	  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

	  var h0 = this.h[0],
	      h1 = this.h[1],
	      h2 = this.h[2],
	      h3 = this.h[3],
	      h4 = this.h[4],
	      h5 = this.h[5],
	      h6 = this.h[6],
	      h7 = this.h[7],
	      h8 = this.h[8],
	      h9 = this.h[9];

	  var r0 = this.r[0],
	      r1 = this.r[1],
	      r2 = this.r[2],
	      r3 = this.r[3],
	      r4 = this.r[4],
	      r5 = this.r[5],
	      r6 = this.r[6],
	      r7 = this.r[7],
	      r8 = this.r[8],
	      r9 = this.r[9];

	  while (bytes >= 16) {
	    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
	    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
	    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
	    h5 += ((t4 >>>  1)) & 0x1fff;
	    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
	    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	    h9 += ((t7 >>> 5)) | hibit;

	    c = 0;

	    d0 = c;
	    d0 += h0 * r0;
	    d0 += h1 * (5 * r9);
	    d0 += h2 * (5 * r8);
	    d0 += h3 * (5 * r7);
	    d0 += h4 * (5 * r6);
	    c = (d0 >>> 13); d0 &= 0x1fff;
	    d0 += h5 * (5 * r5);
	    d0 += h6 * (5 * r4);
	    d0 += h7 * (5 * r3);
	    d0 += h8 * (5 * r2);
	    d0 += h9 * (5 * r1);
	    c += (d0 >>> 13); d0 &= 0x1fff;

	    d1 = c;
	    d1 += h0 * r1;
	    d1 += h1 * r0;
	    d1 += h2 * (5 * r9);
	    d1 += h3 * (5 * r8);
	    d1 += h4 * (5 * r7);
	    c = (d1 >>> 13); d1 &= 0x1fff;
	    d1 += h5 * (5 * r6);
	    d1 += h6 * (5 * r5);
	    d1 += h7 * (5 * r4);
	    d1 += h8 * (5 * r3);
	    d1 += h9 * (5 * r2);
	    c += (d1 >>> 13); d1 &= 0x1fff;

	    d2 = c;
	    d2 += h0 * r2;
	    d2 += h1 * r1;
	    d2 += h2 * r0;
	    d2 += h3 * (5 * r9);
	    d2 += h4 * (5 * r8);
	    c = (d2 >>> 13); d2 &= 0x1fff;
	    d2 += h5 * (5 * r7);
	    d2 += h6 * (5 * r6);
	    d2 += h7 * (5 * r5);
	    d2 += h8 * (5 * r4);
	    d2 += h9 * (5 * r3);
	    c += (d2 >>> 13); d2 &= 0x1fff;

	    d3 = c;
	    d3 += h0 * r3;
	    d3 += h1 * r2;
	    d3 += h2 * r1;
	    d3 += h3 * r0;
	    d3 += h4 * (5 * r9);
	    c = (d3 >>> 13); d3 &= 0x1fff;
	    d3 += h5 * (5 * r8);
	    d3 += h6 * (5 * r7);
	    d3 += h7 * (5 * r6);
	    d3 += h8 * (5 * r5);
	    d3 += h9 * (5 * r4);
	    c += (d3 >>> 13); d3 &= 0x1fff;

	    d4 = c;
	    d4 += h0 * r4;
	    d4 += h1 * r3;
	    d4 += h2 * r2;
	    d4 += h3 * r1;
	    d4 += h4 * r0;
	    c = (d4 >>> 13); d4 &= 0x1fff;
	    d4 += h5 * (5 * r9);
	    d4 += h6 * (5 * r8);
	    d4 += h7 * (5 * r7);
	    d4 += h8 * (5 * r6);
	    d4 += h9 * (5 * r5);
	    c += (d4 >>> 13); d4 &= 0x1fff;

	    d5 = c;
	    d5 += h0 * r5;
	    d5 += h1 * r4;
	    d5 += h2 * r3;
	    d5 += h3 * r2;
	    d5 += h4 * r1;
	    c = (d5 >>> 13); d5 &= 0x1fff;
	    d5 += h5 * r0;
	    d5 += h6 * (5 * r9);
	    d5 += h7 * (5 * r8);
	    d5 += h8 * (5 * r7);
	    d5 += h9 * (5 * r6);
	    c += (d5 >>> 13); d5 &= 0x1fff;

	    d6 = c;
	    d6 += h0 * r6;
	    d6 += h1 * r5;
	    d6 += h2 * r4;
	    d6 += h3 * r3;
	    d6 += h4 * r2;
	    c = (d6 >>> 13); d6 &= 0x1fff;
	    d6 += h5 * r1;
	    d6 += h6 * r0;
	    d6 += h7 * (5 * r9);
	    d6 += h8 * (5 * r8);
	    d6 += h9 * (5 * r7);
	    c += (d6 >>> 13); d6 &= 0x1fff;

	    d7 = c;
	    d7 += h0 * r7;
	    d7 += h1 * r6;
	    d7 += h2 * r5;
	    d7 += h3 * r4;
	    d7 += h4 * r3;
	    c = (d7 >>> 13); d7 &= 0x1fff;
	    d7 += h5 * r2;
	    d7 += h6 * r1;
	    d7 += h7 * r0;
	    d7 += h8 * (5 * r9);
	    d7 += h9 * (5 * r8);
	    c += (d7 >>> 13); d7 &= 0x1fff;

	    d8 = c;
	    d8 += h0 * r8;
	    d8 += h1 * r7;
	    d8 += h2 * r6;
	    d8 += h3 * r5;
	    d8 += h4 * r4;
	    c = (d8 >>> 13); d8 &= 0x1fff;
	    d8 += h5 * r3;
	    d8 += h6 * r2;
	    d8 += h7 * r1;
	    d8 += h8 * r0;
	    d8 += h9 * (5 * r9);
	    c += (d8 >>> 13); d8 &= 0x1fff;

	    d9 = c;
	    d9 += h0 * r9;
	    d9 += h1 * r8;
	    d9 += h2 * r7;
	    d9 += h3 * r6;
	    d9 += h4 * r5;
	    c = (d9 >>> 13); d9 &= 0x1fff;
	    d9 += h5 * r4;
	    d9 += h6 * r3;
	    d9 += h7 * r2;
	    d9 += h8 * r1;
	    d9 += h9 * r0;
	    c += (d9 >>> 13); d9 &= 0x1fff;

	    c = (((c << 2) + c)) | 0;
	    c = (c + d0) | 0;
	    d0 = c & 0x1fff;
	    c = (c >>> 13);
	    d1 += c;

	    h0 = d0;
	    h1 = d1;
	    h2 = d2;
	    h3 = d3;
	    h4 = d4;
	    h5 = d5;
	    h6 = d6;
	    h7 = d7;
	    h8 = d8;
	    h9 = d9;

	    mpos += 16;
	    bytes -= 16;
	  }
	  this.h[0] = h0;
	  this.h[1] = h1;
	  this.h[2] = h2;
	  this.h[3] = h3;
	  this.h[4] = h4;
	  this.h[5] = h5;
	  this.h[6] = h6;
	  this.h[7] = h7;
	  this.h[8] = h8;
	  this.h[9] = h9;
	};

	poly1305.prototype.finish = function(mac, macpos) {
	  var g = new Uint16Array(10);
	  var c, mask, f, i;

	  if (this.leftover) {
	    i = this.leftover;
	    this.buffer[i++] = 1;
	    for (; i < 16; i++) this.buffer[i] = 0;
	    this.fin = 1;
	    this.blocks(this.buffer, 0, 16);
	  }

	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  for (i = 2; i < 10; i++) {
	    this.h[i] += c;
	    c = this.h[i] >>> 13;
	    this.h[i] &= 0x1fff;
	  }
	  this.h[0] += (c * 5);
	  c = this.h[0] >>> 13;
	  this.h[0] &= 0x1fff;
	  this.h[1] += c;
	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  this.h[2] += c;

	  g[0] = this.h[0] + 5;
	  c = g[0] >>> 13;
	  g[0] &= 0x1fff;
	  for (i = 1; i < 10; i++) {
	    g[i] = this.h[i] + c;
	    c = g[i] >>> 13;
	    g[i] &= 0x1fff;
	  }
	  g[9] -= (1 << 13);

	  mask = (c ^ 1) - 1;
	  for (i = 0; i < 10; i++) g[i] &= mask;
	  mask = ~mask;
	  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

	  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
	  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
	  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
	  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
	  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
	  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
	  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
	  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

	  f = this.h[0] + this.pad[0];
	  this.h[0] = f & 0xffff;
	  for (i = 1; i < 8; i++) {
	    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
	    this.h[i] = f & 0xffff;
	  }

	  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
	  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
	  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
	  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
	  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
	  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
	  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
	  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
	  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
	  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
	  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
	  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
	  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
	  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
	  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
	  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
	};

	poly1305.prototype.update = function(m, mpos, bytes) {
	  var i, want;

	  if (this.leftover) {
	    want = (16 - this.leftover);
	    if (want > bytes)
	      want = bytes;
	    for (i = 0; i < want; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    bytes -= want;
	    mpos += want;
	    this.leftover += want;
	    if (this.leftover < 16)
	      return;
	    this.blocks(this.buffer, 0, 16);
	    this.leftover = 0;
	  }

	  if (bytes >= 16) {
	    want = bytes - (bytes % 16);
	    this.blocks(m, mpos, want);
	    mpos += want;
	    bytes -= want;
	  }

	  if (bytes) {
	    for (i = 0; i < bytes; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    this.leftover += bytes;
	  }
	};

	function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
	  var s = new poly1305(k);
	  s.update(m, mpos, n);
	  s.finish(out, outpos);
	  return 0;
	}

	function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
	  var x = new Uint8Array(16);
	  crypto_onetimeauth(x,0,m,mpos,n,k);
	  return crypto_verify_16(h,hpos,x,0);
	}

	function crypto_secretbox(c,m,d,n,k) {
	  var i;
	  if (d < 32) return -1;
	  crypto_stream_xor(c,0,m,0,d,n,k);
	  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
	  for (i = 0; i < 16; i++) c[i] = 0;
	  return 0;
	}

	function crypto_secretbox_open(m,c,d,n,k) {
	  var i;
	  var x = new Uint8Array(32);
	  if (d < 32) return -1;
	  crypto_stream(x,0,32,n,k);
	  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
	  crypto_stream_xor(m,0,c,0,d,n,k);
	  for (i = 0; i < 32; i++) m[i] = 0;
	  return 0;
	}

	function set25519(r, a) {
	  var i;
	  for (i = 0; i < 16; i++) r[i] = a[i]|0;
	}

	function car25519(o) {
	  var i, v, c = 1;
	  for (i = 0; i < 16; i++) {
	    v = o[i] + c + 65535;
	    c = Math.floor(v / 65536);
	    o[i] = v - c * 65536;
	  }
	  o[0] += c-1 + 37 * (c-1);
	}

	function sel25519(p, q, b) {
	  var t, c = ~(b-1);
	  for (var i = 0; i < 16; i++) {
	    t = c & (p[i] ^ q[i]);
	    p[i] ^= t;
	    q[i] ^= t;
	  }
	}

	function pack25519(o, n) {
	  var i, j, b;
	  var m = gf(), t = gf();
	  for (i = 0; i < 16; i++) t[i] = n[i];
	  car25519(t);
	  car25519(t);
	  car25519(t);
	  for (j = 0; j < 2; j++) {
	    m[0] = t[0] - 0xffed;
	    for (i = 1; i < 15; i++) {
	      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
	      m[i-1] &= 0xffff;
	    }
	    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
	    b = (m[15]>>16) & 1;
	    m[14] &= 0xffff;
	    sel25519(t, m, 1-b);
	  }
	  for (i = 0; i < 16; i++) {
	    o[2*i] = t[i] & 0xff;
	    o[2*i+1] = t[i]>>8;
	  }
	}

	function neq25519(a, b) {
	  var c = new Uint8Array(32), d = new Uint8Array(32);
	  pack25519(c, a);
	  pack25519(d, b);
	  return crypto_verify_32(c, 0, d, 0);
	}

	function par25519(a) {
	  var d = new Uint8Array(32);
	  pack25519(d, a);
	  return d[0] & 1;
	}

	function unpack25519(o, n) {
	  var i;
	  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
	  o[15] &= 0x7fff;
	}

	function A(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
	}

	function Z(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
	}

	function M(o, a, b) {
	  var v, c,
	     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
	     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
	    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
	    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
	    b0 = b[0],
	    b1 = b[1],
	    b2 = b[2],
	    b3 = b[3],
	    b4 = b[4],
	    b5 = b[5],
	    b6 = b[6],
	    b7 = b[7],
	    b8 = b[8],
	    b9 = b[9],
	    b10 = b[10],
	    b11 = b[11],
	    b12 = b[12],
	    b13 = b[13],
	    b14 = b[14],
	    b15 = b[15];

	  v = a[0];
	  t0 += v * b0;
	  t1 += v * b1;
	  t2 += v * b2;
	  t3 += v * b3;
	  t4 += v * b4;
	  t5 += v * b5;
	  t6 += v * b6;
	  t7 += v * b7;
	  t8 += v * b8;
	  t9 += v * b9;
	  t10 += v * b10;
	  t11 += v * b11;
	  t12 += v * b12;
	  t13 += v * b13;
	  t14 += v * b14;
	  t15 += v * b15;
	  v = a[1];
	  t1 += v * b0;
	  t2 += v * b1;
	  t3 += v * b2;
	  t4 += v * b3;
	  t5 += v * b4;
	  t6 += v * b5;
	  t7 += v * b6;
	  t8 += v * b7;
	  t9 += v * b8;
	  t10 += v * b9;
	  t11 += v * b10;
	  t12 += v * b11;
	  t13 += v * b12;
	  t14 += v * b13;
	  t15 += v * b14;
	  t16 += v * b15;
	  v = a[2];
	  t2 += v * b0;
	  t3 += v * b1;
	  t4 += v * b2;
	  t5 += v * b3;
	  t6 += v * b4;
	  t7 += v * b5;
	  t8 += v * b6;
	  t9 += v * b7;
	  t10 += v * b8;
	  t11 += v * b9;
	  t12 += v * b10;
	  t13 += v * b11;
	  t14 += v * b12;
	  t15 += v * b13;
	  t16 += v * b14;
	  t17 += v * b15;
	  v = a[3];
	  t3 += v * b0;
	  t4 += v * b1;
	  t5 += v * b2;
	  t6 += v * b3;
	  t7 += v * b4;
	  t8 += v * b5;
	  t9 += v * b6;
	  t10 += v * b7;
	  t11 += v * b8;
	  t12 += v * b9;
	  t13 += v * b10;
	  t14 += v * b11;
	  t15 += v * b12;
	  t16 += v * b13;
	  t17 += v * b14;
	  t18 += v * b15;
	  v = a[4];
	  t4 += v * b0;
	  t5 += v * b1;
	  t6 += v * b2;
	  t7 += v * b3;
	  t8 += v * b4;
	  t9 += v * b5;
	  t10 += v * b6;
	  t11 += v * b7;
	  t12 += v * b8;
	  t13 += v * b9;
	  t14 += v * b10;
	  t15 += v * b11;
	  t16 += v * b12;
	  t17 += v * b13;
	  t18 += v * b14;
	  t19 += v * b15;
	  v = a[5];
	  t5 += v * b0;
	  t6 += v * b1;
	  t7 += v * b2;
	  t8 += v * b3;
	  t9 += v * b4;
	  t10 += v * b5;
	  t11 += v * b6;
	  t12 += v * b7;
	  t13 += v * b8;
	  t14 += v * b9;
	  t15 += v * b10;
	  t16 += v * b11;
	  t17 += v * b12;
	  t18 += v * b13;
	  t19 += v * b14;
	  t20 += v * b15;
	  v = a[6];
	  t6 += v * b0;
	  t7 += v * b1;
	  t8 += v * b2;
	  t9 += v * b3;
	  t10 += v * b4;
	  t11 += v * b5;
	  t12 += v * b6;
	  t13 += v * b7;
	  t14 += v * b8;
	  t15 += v * b9;
	  t16 += v * b10;
	  t17 += v * b11;
	  t18 += v * b12;
	  t19 += v * b13;
	  t20 += v * b14;
	  t21 += v * b15;
	  v = a[7];
	  t7 += v * b0;
	  t8 += v * b1;
	  t9 += v * b2;
	  t10 += v * b3;
	  t11 += v * b4;
	  t12 += v * b5;
	  t13 += v * b6;
	  t14 += v * b7;
	  t15 += v * b8;
	  t16 += v * b9;
	  t17 += v * b10;
	  t18 += v * b11;
	  t19 += v * b12;
	  t20 += v * b13;
	  t21 += v * b14;
	  t22 += v * b15;
	  v = a[8];
	  t8 += v * b0;
	  t9 += v * b1;
	  t10 += v * b2;
	  t11 += v * b3;
	  t12 += v * b4;
	  t13 += v * b5;
	  t14 += v * b6;
	  t15 += v * b7;
	  t16 += v * b8;
	  t17 += v * b9;
	  t18 += v * b10;
	  t19 += v * b11;
	  t20 += v * b12;
	  t21 += v * b13;
	  t22 += v * b14;
	  t23 += v * b15;
	  v = a[9];
	  t9 += v * b0;
	  t10 += v * b1;
	  t11 += v * b2;
	  t12 += v * b3;
	  t13 += v * b4;
	  t14 += v * b5;
	  t15 += v * b6;
	  t16 += v * b7;
	  t17 += v * b8;
	  t18 += v * b9;
	  t19 += v * b10;
	  t20 += v * b11;
	  t21 += v * b12;
	  t22 += v * b13;
	  t23 += v * b14;
	  t24 += v * b15;
	  v = a[10];
	  t10 += v * b0;
	  t11 += v * b1;
	  t12 += v * b2;
	  t13 += v * b3;
	  t14 += v * b4;
	  t15 += v * b5;
	  t16 += v * b6;
	  t17 += v * b7;
	  t18 += v * b8;
	  t19 += v * b9;
	  t20 += v * b10;
	  t21 += v * b11;
	  t22 += v * b12;
	  t23 += v * b13;
	  t24 += v * b14;
	  t25 += v * b15;
	  v = a[11];
	  t11 += v * b0;
	  t12 += v * b1;
	  t13 += v * b2;
	  t14 += v * b3;
	  t15 += v * b4;
	  t16 += v * b5;
	  t17 += v * b6;
	  t18 += v * b7;
	  t19 += v * b8;
	  t20 += v * b9;
	  t21 += v * b10;
	  t22 += v * b11;
	  t23 += v * b12;
	  t24 += v * b13;
	  t25 += v * b14;
	  t26 += v * b15;
	  v = a[12];
	  t12 += v * b0;
	  t13 += v * b1;
	  t14 += v * b2;
	  t15 += v * b3;
	  t16 += v * b4;
	  t17 += v * b5;
	  t18 += v * b6;
	  t19 += v * b7;
	  t20 += v * b8;
	  t21 += v * b9;
	  t22 += v * b10;
	  t23 += v * b11;
	  t24 += v * b12;
	  t25 += v * b13;
	  t26 += v * b14;
	  t27 += v * b15;
	  v = a[13];
	  t13 += v * b0;
	  t14 += v * b1;
	  t15 += v * b2;
	  t16 += v * b3;
	  t17 += v * b4;
	  t18 += v * b5;
	  t19 += v * b6;
	  t20 += v * b7;
	  t21 += v * b8;
	  t22 += v * b9;
	  t23 += v * b10;
	  t24 += v * b11;
	  t25 += v * b12;
	  t26 += v * b13;
	  t27 += v * b14;
	  t28 += v * b15;
	  v = a[14];
	  t14 += v * b0;
	  t15 += v * b1;
	  t16 += v * b2;
	  t17 += v * b3;
	  t18 += v * b4;
	  t19 += v * b5;
	  t20 += v * b6;
	  t21 += v * b7;
	  t22 += v * b8;
	  t23 += v * b9;
	  t24 += v * b10;
	  t25 += v * b11;
	  t26 += v * b12;
	  t27 += v * b13;
	  t28 += v * b14;
	  t29 += v * b15;
	  v = a[15];
	  t15 += v * b0;
	  t16 += v * b1;
	  t17 += v * b2;
	  t18 += v * b3;
	  t19 += v * b4;
	  t20 += v * b5;
	  t21 += v * b6;
	  t22 += v * b7;
	  t23 += v * b8;
	  t24 += v * b9;
	  t25 += v * b10;
	  t26 += v * b11;
	  t27 += v * b12;
	  t28 += v * b13;
	  t29 += v * b14;
	  t30 += v * b15;

	  t0  += 38 * t16;
	  t1  += 38 * t17;
	  t2  += 38 * t18;
	  t3  += 38 * t19;
	  t4  += 38 * t20;
	  t5  += 38 * t21;
	  t6  += 38 * t22;
	  t7  += 38 * t23;
	  t8  += 38 * t24;
	  t9  += 38 * t25;
	  t10 += 38 * t26;
	  t11 += 38 * t27;
	  t12 += 38 * t28;
	  t13 += 38 * t29;
	  t14 += 38 * t30;
	  // t15 left as is

	  // first car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);

	  // second car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);

	  o[ 0] = t0;
	  o[ 1] = t1;
	  o[ 2] = t2;
	  o[ 3] = t3;
	  o[ 4] = t4;
	  o[ 5] = t5;
	  o[ 6] = t6;
	  o[ 7] = t7;
	  o[ 8] = t8;
	  o[ 9] = t9;
	  o[10] = t10;
	  o[11] = t11;
	  o[12] = t12;
	  o[13] = t13;
	  o[14] = t14;
	  o[15] = t15;
	}

	function S(o, a) {
	  M(o, a, a);
	}

	function inv25519(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 253; a >= 0; a--) {
	    S(c, c);
	    if(a !== 2 && a !== 4) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}

	function pow2523(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 250; a >= 0; a--) {
	      S(c, c);
	      if(a !== 1) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}

	function crypto_scalarmult(q, n, p) {
	  var z = new Uint8Array(32);
	  var x = new Float64Array(80), r, i;
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf();
	  for (i = 0; i < 31; i++) z[i] = n[i];
	  z[31]=(n[31]&127)|64;
	  z[0]&=248;
	  unpack25519(x,p);
	  for (i = 0; i < 16; i++) {
	    b[i]=x[i];
	    d[i]=a[i]=c[i]=0;
	  }
	  a[0]=d[0]=1;
	  for (i=254; i>=0; --i) {
	    r=(z[i>>>3]>>>(i&7))&1;
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	    A(e,a,c);
	    Z(a,a,c);
	    A(c,b,d);
	    Z(b,b,d);
	    S(d,e);
	    S(f,a);
	    M(a,c,a);
	    M(c,b,e);
	    A(e,a,c);
	    Z(a,a,c);
	    S(b,a);
	    Z(c,d,f);
	    M(a,c,_121665);
	    A(a,a,d);
	    M(c,c,a);
	    M(a,d,f);
	    M(d,b,x);
	    S(b,e);
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	  }
	  for (i = 0; i < 16; i++) {
	    x[i+16]=a[i];
	    x[i+32]=c[i];
	    x[i+48]=b[i];
	    x[i+64]=d[i];
	  }
	  var x32 = x.subarray(32);
	  var x16 = x.subarray(16);
	  inv25519(x32,x32);
	  M(x16,x16,x32);
	  pack25519(q,x16);
	  return 0;
	}

	function crypto_scalarmult_base(q, n) {
	  return crypto_scalarmult(q, n, _9);
	}

	function crypto_box_keypair(y, x) {
	  randombytes(x, 32);
	  return crypto_scalarmult_base(y, x);
	}

	function crypto_box_beforenm(k, y, x) {
	  var s = new Uint8Array(32);
	  crypto_scalarmult(s, x, y);
	  return crypto_core_hsalsa20(k, _0, s, sigma);
	}

	var crypto_box_afternm = crypto_secretbox;
	var crypto_box_open_afternm = crypto_secretbox_open;

	function crypto_box(c, m, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_afternm(c, m, d, n, k);
	}

	function crypto_box_open(m, c, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_open_afternm(m, c, d, n, k);
	}

	var K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	function crypto_hashblocks_hl(hh, hl, m, n) {
	  var wh = new Int32Array(16), wl = new Int32Array(16),
	      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
	      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
	      th, tl, i, j, h, l, a, b, c, d;

	  var ah0 = hh[0],
	      ah1 = hh[1],
	      ah2 = hh[2],
	      ah3 = hh[3],
	      ah4 = hh[4],
	      ah5 = hh[5],
	      ah6 = hh[6],
	      ah7 = hh[7],

	      al0 = hl[0],
	      al1 = hl[1],
	      al2 = hl[2],
	      al3 = hl[3],
	      al4 = hl[4],
	      al5 = hl[5],
	      al6 = hl[6],
	      al7 = hl[7];

	  var pos = 0;
	  while (n >= 128) {
	    for (i = 0; i < 16; i++) {
	      j = 8 * i + pos;
	      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
	      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
	    }
	    for (i = 0; i < 80; i++) {
	      bh0 = ah0;
	      bh1 = ah1;
	      bh2 = ah2;
	      bh3 = ah3;
	      bh4 = ah4;
	      bh5 = ah5;
	      bh6 = ah6;
	      bh7 = ah7;

	      bl0 = al0;
	      bl1 = al1;
	      bl2 = al2;
	      bl3 = al3;
	      bl4 = al4;
	      bl5 = al5;
	      bl6 = al6;
	      bl7 = al7;

	      // add
	      h = ah7;
	      l = al7;

	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;

	      // Sigma1
	      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
	      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // Ch
	      h = (ah4 & ah5) ^ (~ah4 & ah6);
	      l = (al4 & al5) ^ (~al4 & al6);

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // K
	      h = K[i*2];
	      l = K[i*2+1];

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // w
	      h = wh[i%16];
	      l = wl[i%16];

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;

	      th = c & 0xffff | d << 16;
	      tl = a & 0xffff | b << 16;

	      // add
	      h = th;
	      l = tl;

	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;

	      // Sigma0
	      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
	      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // Maj
	      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
	      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;

	      bh7 = (c & 0xffff) | (d << 16);
	      bl7 = (a & 0xffff) | (b << 16);

	      // add
	      h = bh3;
	      l = bl3;

	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;

	      h = th;
	      l = tl;

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;

	      bh3 = (c & 0xffff) | (d << 16);
	      bl3 = (a & 0xffff) | (b << 16);

	      ah1 = bh0;
	      ah2 = bh1;
	      ah3 = bh2;
	      ah4 = bh3;
	      ah5 = bh4;
	      ah6 = bh5;
	      ah7 = bh6;
	      ah0 = bh7;

	      al1 = bl0;
	      al2 = bl1;
	      al3 = bl2;
	      al4 = bl3;
	      al5 = bl4;
	      al6 = bl5;
	      al7 = bl6;
	      al0 = bl7;

	      if (i%16 === 15) {
	        for (j = 0; j < 16; j++) {
	          // add
	          h = wh[j];
	          l = wl[j];

	          a = l & 0xffff; b = l >>> 16;
	          c = h & 0xffff; d = h >>> 16;

	          h = wh[(j+9)%16];
	          l = wl[(j+9)%16];

	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;

	          // sigma0
	          th = wh[(j+1)%16];
	          tl = wl[(j+1)%16];
	          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
	          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;

	          // sigma1
	          th = wh[(j+14)%16];
	          tl = wl[(j+14)%16];
	          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
	          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;

	          b += a >>> 16;
	          c += b >>> 16;
	          d += c >>> 16;

	          wh[j] = (c & 0xffff) | (d << 16);
	          wl[j] = (a & 0xffff) | (b << 16);
	        }
	      }
	    }

	    // add
	    h = ah0;
	    l = al0;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[0];
	    l = hl[0];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[0] = ah0 = (c & 0xffff) | (d << 16);
	    hl[0] = al0 = (a & 0xffff) | (b << 16);

	    h = ah1;
	    l = al1;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[1];
	    l = hl[1];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[1] = ah1 = (c & 0xffff) | (d << 16);
	    hl[1] = al1 = (a & 0xffff) | (b << 16);

	    h = ah2;
	    l = al2;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[2];
	    l = hl[2];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[2] = ah2 = (c & 0xffff) | (d << 16);
	    hl[2] = al2 = (a & 0xffff) | (b << 16);

	    h = ah3;
	    l = al3;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[3];
	    l = hl[3];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[3] = ah3 = (c & 0xffff) | (d << 16);
	    hl[3] = al3 = (a & 0xffff) | (b << 16);

	    h = ah4;
	    l = al4;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[4];
	    l = hl[4];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[4] = ah4 = (c & 0xffff) | (d << 16);
	    hl[4] = al4 = (a & 0xffff) | (b << 16);

	    h = ah5;
	    l = al5;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[5];
	    l = hl[5];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[5] = ah5 = (c & 0xffff) | (d << 16);
	    hl[5] = al5 = (a & 0xffff) | (b << 16);

	    h = ah6;
	    l = al6;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[6];
	    l = hl[6];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[6] = ah6 = (c & 0xffff) | (d << 16);
	    hl[6] = al6 = (a & 0xffff) | (b << 16);

	    h = ah7;
	    l = al7;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[7];
	    l = hl[7];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[7] = ah7 = (c & 0xffff) | (d << 16);
	    hl[7] = al7 = (a & 0xffff) | (b << 16);

	    pos += 128;
	    n -= 128;
	  }

	  return n;
	}

	function crypto_hash(out, m, n) {
	  var hh = new Int32Array(8),
	      hl = new Int32Array(8),
	      x = new Uint8Array(256),
	      i, b = n;

	  hh[0] = 0x6a09e667;
	  hh[1] = 0xbb67ae85;
	  hh[2] = 0x3c6ef372;
	  hh[3] = 0xa54ff53a;
	  hh[4] = 0x510e527f;
	  hh[5] = 0x9b05688c;
	  hh[6] = 0x1f83d9ab;
	  hh[7] = 0x5be0cd19;

	  hl[0] = 0xf3bcc908;
	  hl[1] = 0x84caa73b;
	  hl[2] = 0xfe94f82b;
	  hl[3] = 0x5f1d36f1;
	  hl[4] = 0xade682d1;
	  hl[5] = 0x2b3e6c1f;
	  hl[6] = 0xfb41bd6b;
	  hl[7] = 0x137e2179;

	  crypto_hashblocks_hl(hh, hl, m, n);
	  n %= 128;

	  for (i = 0; i < n; i++) x[i] = m[b-n+i];
	  x[n] = 128;

	  n = 256-128*(n<112?1:0);
	  x[n-9] = 0;
	  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
	  crypto_hashblocks_hl(hh, hl, x, n);

	  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

	  return 0;
	}

	function add(p, q) {
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf(),
	      g = gf(), h = gf(), t = gf();

	  Z(a, p[1], p[0]);
	  Z(t, q[1], q[0]);
	  M(a, a, t);
	  A(b, p[0], p[1]);
	  A(t, q[0], q[1]);
	  M(b, b, t);
	  M(c, p[3], q[3]);
	  M(c, c, D2);
	  M(d, p[2], q[2]);
	  A(d, d, d);
	  Z(e, b, a);
	  Z(f, d, c);
	  A(g, d, c);
	  A(h, b, a);

	  M(p[0], e, f);
	  M(p[1], h, g);
	  M(p[2], g, f);
	  M(p[3], e, h);
	}

	function cswap(p, q, b) {
	  var i;
	  for (i = 0; i < 4; i++) {
	    sel25519(p[i], q[i], b);
	  }
	}

	function pack(r, p) {
	  var tx = gf(), ty = gf(), zi = gf();
	  inv25519(zi, p[2]);
	  M(tx, p[0], zi);
	  M(ty, p[1], zi);
	  pack25519(r, ty);
	  r[31] ^= par25519(tx) << 7;
	}

	function scalarmult(p, q, s) {
	  var b, i;
	  set25519(p[0], gf0);
	  set25519(p[1], gf1);
	  set25519(p[2], gf1);
	  set25519(p[3], gf0);
	  for (i = 255; i >= 0; --i) {
	    b = (s[(i/8)|0] >> (i&7)) & 1;
	    cswap(p, q, b);
	    add(q, p);
	    add(p, p);
	    cswap(p, q, b);
	  }
	}

	function scalarbase(p, s) {
	  var q = [gf(), gf(), gf(), gf()];
	  set25519(q[0], X);
	  set25519(q[1], Y);
	  set25519(q[2], gf1);
	  M(q[3], X, Y);
	  scalarmult(p, q, s);
	}

	function crypto_sign_keypair(pk, sk, seeded) {
	  var d = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()];
	  var i;

	  if (!seeded) randombytes(sk, 32);
	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;

	  scalarbase(p, d);
	  pack(pk, p);

	  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
	  return 0;
	}

	var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

	function modL(r, x) {
	  var carry, i, j, k;
	  for (i = 63; i >= 32; --i) {
	    carry = 0;
	    for (j = i - 32, k = i - 12; j < k; ++j) {
	      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
	      carry = Math.floor((x[j] + 128) / 256);
	      x[j] -= carry * 256;
	    }
	    x[j] += carry;
	    x[i] = 0;
	  }
	  carry = 0;
	  for (j = 0; j < 32; j++) {
	    x[j] += carry - (x[31] >> 4) * L[j];
	    carry = x[j] >> 8;
	    x[j] &= 255;
	  }
	  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
	  for (i = 0; i < 32; i++) {
	    x[i+1] += x[i] >> 8;
	    r[i] = x[i] & 255;
	  }
	}

	function reduce(r) {
	  var x = new Float64Array(64), i;
	  for (i = 0; i < 64; i++) x[i] = r[i];
	  for (i = 0; i < 64; i++) r[i] = 0;
	  modL(r, x);
	}

	// Note: difference from C - smlen returned, not passed as argument.
	function crypto_sign(sm, m, n, sk) {
	  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
	  var i, j, x = new Float64Array(64);
	  var p = [gf(), gf(), gf(), gf()];

	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;

	  var smlen = n + 64;
	  for (i = 0; i < n; i++) sm[64 + i] = m[i];
	  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

	  crypto_hash(r, sm.subarray(32), n+32);
	  reduce(r);
	  scalarbase(p, r);
	  pack(sm, p);

	  for (i = 32; i < 64; i++) sm[i] = sk[i];
	  crypto_hash(h, sm, n + 64);
	  reduce(h);

	  for (i = 0; i < 64; i++) x[i] = 0;
	  for (i = 0; i < 32; i++) x[i] = r[i];
	  for (i = 0; i < 32; i++) {
	    for (j = 0; j < 32; j++) {
	      x[i+j] += h[i] * d[j];
	    }
	  }

	  modL(sm.subarray(32), x);
	  return smlen;
	}

	function unpackneg(r, p) {
	  var t = gf(), chk = gf(), num = gf(),
	      den = gf(), den2 = gf(), den4 = gf(),
	      den6 = gf();

	  set25519(r[2], gf1);
	  unpack25519(r[1], p);
	  S(num, r[1]);
	  M(den, num, D);
	  Z(num, num, r[2]);
	  A(den, r[2], den);

	  S(den2, den);
	  S(den4, den2);
	  M(den6, den4, den2);
	  M(t, den6, num);
	  M(t, t, den);

	  pow2523(t, t);
	  M(t, t, num);
	  M(t, t, den);
	  M(t, t, den);
	  M(r[0], t, den);

	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) M(r[0], r[0], I);

	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) return -1;

	  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

	  M(r[3], r[0], r[1]);
	  return 0;
	}

	function crypto_sign_open(m, sm, n, pk) {
	  var i;
	  var t = new Uint8Array(32), h = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()],
	      q = [gf(), gf(), gf(), gf()];

	  if (n < 64) return -1;

	  if (unpackneg(q, pk)) return -1;

	  for (i = 0; i < n; i++) m[i] = sm[i];
	  for (i = 0; i < 32; i++) m[i+32] = pk[i];
	  crypto_hash(h, m, n);
	  reduce(h);
	  scalarmult(p, q, h);

	  scalarbase(q, sm.subarray(32));
	  add(p, q);
	  pack(t, p);

	  n -= 64;
	  if (crypto_verify_32(sm, 0, t, 0)) {
	    for (i = 0; i < n; i++) m[i] = 0;
	    return -1;
	  }

	  for (i = 0; i < n; i++) m[i] = sm[i + 64];
	  return n;
	}

	var crypto_secretbox_KEYBYTES = 32,
	    crypto_secretbox_NONCEBYTES = 24,
	    crypto_secretbox_ZEROBYTES = 32,
	    crypto_secretbox_BOXZEROBYTES = 16,
	    crypto_scalarmult_BYTES = 32,
	    crypto_scalarmult_SCALARBYTES = 32,
	    crypto_box_PUBLICKEYBYTES = 32,
	    crypto_box_SECRETKEYBYTES = 32,
	    crypto_box_BEFORENMBYTES = 32,
	    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
	    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
	    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
	    crypto_sign_BYTES = 64,
	    crypto_sign_PUBLICKEYBYTES = 32,
	    crypto_sign_SECRETKEYBYTES = 64,
	    crypto_sign_SEEDBYTES = 32,
	    crypto_hash_BYTES = 64;

	nacl.lowlevel = {
	  crypto_core_hsalsa20: crypto_core_hsalsa20,
	  crypto_stream_xor: crypto_stream_xor,
	  crypto_stream: crypto_stream,
	  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
	  crypto_stream_salsa20: crypto_stream_salsa20,
	  crypto_onetimeauth: crypto_onetimeauth,
	  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
	  crypto_verify_16: crypto_verify_16,
	  crypto_verify_32: crypto_verify_32,
	  crypto_secretbox: crypto_secretbox,
	  crypto_secretbox_open: crypto_secretbox_open,
	  crypto_scalarmult: crypto_scalarmult,
	  crypto_scalarmult_base: crypto_scalarmult_base,
	  crypto_box_beforenm: crypto_box_beforenm,
	  crypto_box_afternm: crypto_box_afternm,
	  crypto_box: crypto_box,
	  crypto_box_open: crypto_box_open,
	  crypto_box_keypair: crypto_box_keypair,
	  crypto_hash: crypto_hash,
	  crypto_sign: crypto_sign,
	  crypto_sign_keypair: crypto_sign_keypair,
	  crypto_sign_open: crypto_sign_open,

	  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
	  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
	  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
	  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
	  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
	  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
	  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
	  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
	  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
	  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
	  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
	  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
	  crypto_sign_BYTES: crypto_sign_BYTES,
	  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
	  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
	  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
	  crypto_hash_BYTES: crypto_hash_BYTES,

	  gf: gf,
	  D: D,
	  L: L,
	  pack25519: pack25519,
	  unpack25519: unpack25519,
	  M: M,
	  A: A,
	  S: S,
	  Z: Z,
	  pow2523: pow2523,
	  add: add,
	  set25519: set25519,
	  modL: modL,
	  scalarmult: scalarmult,
	  scalarbase: scalarbase,
	};

	/* High-level API */

	function checkLengths(k, n) {
	  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
	  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
	}

	function checkBoxLengths(pk, sk) {
	  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
	  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
	}

	function checkArrayTypes() {
	  for (var i = 0; i < arguments.length; i++) {
	    if (!(arguments[i] instanceof Uint8Array))
	      throw new TypeError('unexpected type, use Uint8Array');
	  }
	}

	function cleanup(arr) {
	  for (var i = 0; i < arr.length; i++) arr[i] = 0;
	}

	nacl.randomBytes = function(n) {
	  var b = new Uint8Array(n);
	  randombytes(b, n);
	  return b;
	};

	nacl.secretbox = function(msg, nonce, key) {
	  checkArrayTypes(msg, nonce, key);
	  checkLengths(key, nonce);
	  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
	  var c = new Uint8Array(m.length);
	  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
	  crypto_secretbox(c, m, m.length, nonce, key);
	  return c.subarray(crypto_secretbox_BOXZEROBYTES);
	};

	nacl.secretbox.open = function(box, nonce, key) {
	  checkArrayTypes(box, nonce, key);
	  checkLengths(key, nonce);
	  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
	  var m = new Uint8Array(c.length);
	  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
	  if (c.length < 32) return null;
	  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
	  return m.subarray(crypto_secretbox_ZEROBYTES);
	};

	nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
	nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
	nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

	nacl.scalarMult = function(n, p) {
	  checkArrayTypes(n, p);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult(q, n, p);
	  return q;
	};

	nacl.scalarMult.base = function(n) {
	  checkArrayTypes(n);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult_base(q, n);
	  return q;
	};

	nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
	nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

	nacl.box = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox(msg, nonce, k);
	};

	nacl.box.before = function(publicKey, secretKey) {
	  checkArrayTypes(publicKey, secretKey);
	  checkBoxLengths(publicKey, secretKey);
	  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
	  crypto_box_beforenm(k, publicKey, secretKey);
	  return k;
	};

	nacl.box.after = nacl.secretbox;

	nacl.box.open = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox.open(msg, nonce, k);
	};

	nacl.box.open.after = nacl.secretbox.open;

	nacl.box.keyPair = function() {
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
	  crypto_box_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};

	nacl.box.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  crypto_scalarmult_base(pk, secretKey);
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};

	nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
	nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
	nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
	nacl.box.nonceLength = crypto_box_NONCEBYTES;
	nacl.box.overheadLength = nacl.secretbox.overheadLength;

	nacl.sign = function(msg, secretKey) {
	  checkArrayTypes(msg, secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
	  crypto_sign(signedMsg, msg, msg.length, secretKey);
	  return signedMsg;
	};

	nacl.sign.open = function(signedMsg, publicKey) {
	  checkArrayTypes(signedMsg, publicKey);
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var tmp = new Uint8Array(signedMsg.length);
	  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
	  if (mlen < 0) return null;
	  var m = new Uint8Array(mlen);
	  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
	  return m;
	};

	nacl.sign.detached = function(msg, secretKey) {
	  var signedMsg = nacl.sign(msg, secretKey);
	  var sig = new Uint8Array(crypto_sign_BYTES);
	  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
	  return sig;
	};

	nacl.sign.detached.verify = function(msg, sig, publicKey) {
	  checkArrayTypes(msg, sig, publicKey);
	  if (sig.length !== crypto_sign_BYTES)
	    throw new Error('bad signature size');
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var i;
	  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
	  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
	  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
	};

	nacl.sign.keyPair = function() {
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  crypto_sign_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};

	nacl.sign.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};

	nacl.sign.keyPair.fromSeed = function(seed) {
	  checkArrayTypes(seed);
	  if (seed.length !== crypto_sign_SEEDBYTES)
	    throw new Error('bad seed size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  for (var i = 0; i < 32; i++) sk[i] = seed[i];
	  crypto_sign_keypair(pk, sk, true);
	  return {publicKey: pk, secretKey: sk};
	};

	nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
	nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
	nacl.sign.seedLength = crypto_sign_SEEDBYTES;
	nacl.sign.signatureLength = crypto_sign_BYTES;

	nacl.hash = function(msg) {
	  checkArrayTypes(msg);
	  var h = new Uint8Array(crypto_hash_BYTES);
	  crypto_hash(h, msg, msg.length);
	  return h;
	};

	nacl.hash.hashLength = crypto_hash_BYTES;

	nacl.verify = function(x, y) {
	  checkArrayTypes(x, y);
	  // Zero length arguments are considered not equal.
	  if (x.length === 0 || y.length === 0) return false;
	  if (x.length !== y.length) return false;
	  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
	};

	nacl.setPRNG = function(fn) {
	  randombytes = fn;
	};

	(function() {
	  // Initialize PRNG if environment provides CSPRNG.
	  // If not, methods calling randombytes will throw.
	  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
	  if (crypto && crypto.getRandomValues) {
	    // Browsers.
	    var QUOTA = 65536;
	    nacl.setPRNG(function(x, n) {
	      var i, v = new Uint8Array(n);
	      for (i = 0; i < n; i += QUOTA) {
	        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
	      }
	      for (i = 0; i < n; i++) x[i] = v[i];
	      cleanup(v);
	    });
	  } else if (typeof commonjsRequire !== 'undefined') {
	    // Node.js.
	    crypto = require$$0;
	    if (crypto && crypto.randomBytes) {
	      nacl.setPRNG(function(x, n) {
	        var i, v = crypto.randomBytes(n);
	        for (i = 0; i < n; i++) x[i] = v[i];
	        cleanup(v);
	      });
	    }
	  }
	})();

	})( module.exports ? module.exports : (self.nacl = self.nacl || {}));
	});

	var naclUtil = createCommonjsModule(function (module) {
	// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
	// Public domain.
	(function(root, f) {
	  if ( module.exports) module.exports = f();
	  else if (root.nacl) root.nacl.util = f();
	  else {
	    root.nacl = {};
	    root.nacl.util = f();
	  }
	}(commonjsGlobal, function() {

	  var util = {};

	  function validateBase64(s) {
	    if (!(/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s))) {
	      throw new TypeError('invalid encoding');
	    }
	  }

	  util.decodeUTF8 = function(s) {
	    if (typeof s !== 'string') throw new TypeError('expected string');
	    var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
	    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	    return b;
	  };

	  util.encodeUTF8 = function(arr) {
	    var i, s = [];
	    for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
	    return decodeURIComponent(escape(s.join('')));
	  };

	  if (typeof atob === 'undefined') {
	    // Node.js

	    if (typeof Buffer.from !== 'undefined') {
	       // Node v6 and later
	      util.encodeBase64 = function (arr) { // v6 and later
	          return Buffer.from(arr).toString('base64');
	      };

	      util.decodeBase64 = function (s) {
	        validateBase64(s);
	        return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0));
	      };

	    } else {
	      // Node earlier than v6
	      util.encodeBase64 = function (arr) { // v6 and later
	        return (new Buffer(arr)).toString('base64');
	      };

	      util.decodeBase64 = function(s) {
	        validateBase64(s);
	        return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
	      };
	    }

	  } else {
	    // Browsers

	    util.encodeBase64 = function(arr) {
	      var i, s = [], len = arr.length;
	      for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
	      return btoa(s.join(''));
	    };

	    util.decodeBase64 = function(s) {
	      validateBase64(s);
	      var i, d = atob(s), b = new Uint8Array(d.length);
	      for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	      return b;
	    };

	  }

	  return util;

	}));
	});

	function isObject(obj) {
	  return obj !== undefined && obj !== null && obj.constructor == Object;
	}

	function addHeader(_msg, flag) {
	  const msg = new Uint8Array(_msg.length + 1);

	  const header = new Uint8Array(1);
	  header[0] = flag;

	  msg.set(header);
	  msg.set(_msg, header.length);

	  return msg;
	}

	function noop$1() {}

	class RunnableLink {
	  constructor(prev, next, fn) {
	    this.prev = prev;
	    this.next = next;
	    this.fn = fn || noop$1;
	  }

	  run(data) {
	    this.fn(data);
	    this.next && this.next.run(data);
	  }
	}

	class LinkedList {
	  constructor(linkConstructor) {
	    this.head = new RunnableLink();
	    this.tail = new RunnableLink(this.head);
	    this.head.next = this.tail;
	    this.linkConstructor = linkConstructor;
	    this.reg = {};
	  }

	  insert(data) {
	    const link = new RunnableLink(this.tail.prev, this.tail, data);
	    link.next.prev = link;
	    link.prev.next = link;
	    return link;
	  }

	  remove(link) {
	    link.prev.next = link.next;
	    link.next.prev = link.prev;
	  }
	}

	let id = 0;

	class Eev {
	  constructor() {
	    this.__events_list = {};
	  }

	  on(name, fn) {
	    const list = this.__events_list[name] || (this.__events_list[name] = new LinkedList());
	    const eev = fn._eev || (fn._eev = ++id);

	    list.reg[eev] || (list.reg[eev] = list.insert(fn));
	  }

	  off(name, fn) {
	    if (fn) {
	      const list = this.__events_list[name];

	      if (!list) {
	        return;
	      }

	      const link = list.reg[fn._eev];

	      list.reg[fn._eev] = undefined;

	      list && link && list.remove(link);
	    }
	  }

	  removeListener(...args) {
	    this.off(...args);
	  }

	  emit(name, data) {
	    const evt = this.__events_list[name];
	    evt && evt.head.run(data);
	  }
	}

	function listify$1(obj) {
	  if (typeof obj == 'undefined' || obj == null) {
	    return [];
	  }
	  return Array.isArray(obj) ? obj : [obj];
	}

	function bufferToHex$1(buffer) {
	  return Array.from(new Uint8Array(buffer))
	    .map(b => b.toString(16).padStart(2, '0'))
	    .join('');
	}

	function hexToBuffer$1(hex) {
	  const tokens = hex.match(/.{1,2}(?=(.{2})+(?!.))|.{1,2}$/g);
	  return new Uint8Array(tokens.map(token => parseInt(token, 16)));
	}

	function integerToByteArray(long, arrayLen = 8) {
	  const byteArray = new Array(arrayLen).fill(0);

	  for (let index = 0; index < byteArray.length; index++) {
	    const byte = long & 0xff;
	    byteArray[index] = byte;
	    long = (long - byte) / 256;
	  }

	  return byteArray;
	}

	/**
	 * Module exports.
	 */

	var browserUtilInspect = inspect;

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 * @license MIT (© Joyent)
	 */
	/* legacy: obj, showHidden, depth, colors*/

	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    _extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}

	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};

	function stylizeNoColor(str, styleType) {
	  return str;
	}

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isString(arg) {
	  return typeof arg === 'string';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isNull(arg) {
	  return arg === null;
	}

	function hasOwn(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	function isRegExp(re) {
	  return isObject$1(re) && objectToString(re) === '[object RegExp]';
	}

	function isObject$1(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isError(e) {
	  return isObject$1(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}

	function isDate(d) {
	  return isObject$1(d) && objectToString(d) === '[object Date]';
	}

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}

	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwn(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}

	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}

	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  try {
	    if (ctx.showHidden && Object.getOwnPropertyNames) {
	      keys = Object.getOwnPropertyNames(value);
	    }
	  } catch (e) {
	    // ignore
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (Array.isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}

	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = { value: void 0 };
	  try {
	    // ie6 › navigator.toString
	    // throws Error: Object doesn't support this property or method
	    desc.value = value[key];
	  } catch (e) {
	    // ignore
	  }
	  try {
	    // ie10 › Object.getOwnPropertyDescriptor(window.location, 'hash')
	    // throws TypeError: Object doesn't support this action
	    if (Object.getOwnPropertyDescriptor) {
	      desc = Object.getOwnPropertyDescriptor(value, key) || desc;
	    }
	  } catch (e) {
	    // ignore
	  }
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwn(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}

	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}

	function reduceToSingleString(output, base, braces) {
	  var length = output.reduce(function(prev, cur) {
	    if (cur.indexOf('\n') >= 0) ;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}

	function _extend(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject$1(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	}

	function doLogging(color, log, ...args) {
	  try {
	    if (log == console.log) {
	      // by doing inspect in this way we get normal text in quotations: '...'
	      // 9/2/2022, 9:42:11 PM → 'Connector ws://192.168.0.16:7780 created'
	      // we remove them with 2x replace ...
	      log(
	        `${new Date().toLocaleString()} → ${browserUtilInspect(...args)
          .replace(/^'/, '')
          .replace(/'$/, '')}`
	      );
	    } else if (typeof log == 'function') {
	      log(...args); // recently changed from args to ...args -- see if some other places need change
	    } else if (log) {
	      // dmt logger object
	      log.logOutput(color, { source: 'connectome' }, ...args);
	    }
	  } catch (e) {
	    console.log(e);
	  }
	}

	class Logger {
	  write(log, ...args) {
	    doLogging(undefined, log, ...args);
	  }

	  red(log, ...args) {
	    doLogging('red', log, ...args);
	  }

	  green(log, ...args) {
	    doLogging('green', log, ...args);
	  }

	  yellow(log, ...args) {
	    doLogging('yellow', log, ...args);
	  }

	  blue(log, ...args) {
	    doLogging('blue', log, ...args);
	  }

	  cyan(log, ...args) {
	    doLogging('cyan', log, ...args);
	  }

	  magenta(log, ...args) {
	    doLogging('magenta', log, ...args);
	  }

	  gray(log, ...args) {
	    doLogging('gray', log, ...args);
	  }

	  white(log, ...args) {
	    doLogging('white', log, ...args);
	  }
	}

	var logger = new Logger();

	//import colors from 'kleur';
	naclFast.util = naclUtil;

	function send({ data, connector }) {
	  const { log } = connector;

	  // const log = (...opts) => {
	  //   if (opts.length == 0) {
	  //     connector.logger.write(log);
	  //   } else {
	  //     connector.logger.write(log,
	  //       colors.magenta('📡'),
	  //       colors.gray(connector.tag || connector.endpoint),
	  //       colors.magenta(...opts)
	  //     );
	  //   }
	  // };

	  if (isObject(data)) {
	    data = JSON.stringify(data);
	  }

	  const nonce = new Uint8Array(integerToByteArray(2 * connector.sentCount, 24));

	  if (!connector.closed()) {
	    if (connector.sentCount > 1) {
	      let flag = 0;

	      if (typeof data == 'string') {
	        flag = 1;
	      }

	      const _encodedMessage = flag == 1 ? naclFast.util.decodeUTF8(data) : data;
	      const encodedMessage = addHeader(_encodedMessage, flag);

	      const encryptedMessage = naclFast.secretbox(encodedMessage, nonce, connector.sharedSecret);

	      if (connector.verbose) {
	        //logger.write(log); // empty line
	        logger.green(
	          log,
	          `Connector ${connector.endpoint} → Sending encrypted message #${connector.sentCount} ↴`
	        );
	        logger.gray(log, data);
	      }

	      connector.connection.websocket.send(encryptedMessage);
	    } else {
	      if (connector.verbose) {
	        //logger.write(log); // empty line
	        logger.green(
	          log,
	          `Connector ${connector.endpoint} → Sending message #${connector.sentCount} ↴`
	        );
	        logger.gray(log, data);
	      }

	      connector.connection.websocket.send(data);
	    }
	  } else {
	    logger.red(log, `⚠️ Warning: "${data}" was not sent because connector is not ready`);
	  }
	}

	//import colors from 'kleur';
	naclFast.util = naclUtil;

	function isRpcCallResult(jsonData) {
	  return Object.keys(jsonData).includes('result') || Object.keys(jsonData).includes('error');
	}

	function wireReceive({ jsonData, encryptedData, rawMessage, wasEncrypted, connector }) {
	  const { log } = connector;

	  // const log = (...opts) => {
	  //   if (opts.length == 0) {
	  //     connector.logger.write(log, );
	  //   } else {
	  //     connector.logger.write(log,
	  //       colors.yellow('📥'),
	  //       colors.gray(connector.tag || connector.endpoint),
	  //       colors.yellow(...opts)
	  //     );
	  //   }
	  // };

	  connector.lastMessageAt = Date.now();

	  const nonce = new Uint8Array(integerToByteArray(2 * connector.receivedCount + 1, 24));

	  if (connector.verbose && !wasEncrypted) {
	    //logger.write(log);
	    logger.magenta(log, `Connector ${connector.endpoint} → Received message #${connector.receivedCount} ↴`);
	  }

	  // 💡 unencrypted jsonData !
	  if (jsonData) {
	    if (jsonData.jsonrpc) {
	      if (isRpcCallResult(jsonData)) {
	        if (connector.verbose && !wasEncrypted) {
	          logger.magenta(log, `Connector ${connector.endpoint} received plain-text rpc result ↴`);
	          logger.gray(log, jsonData);
	        }

	        connector.rpcClient.jsonrpcMsgReceive(rawMessage);
	      } else {
	        connector.emit('json_rpc', rawMessage);
	      }
	    } else {
	      connector.emit('receive', { jsonData, rawMessage });
	    }

	    // logger.magenta(
	    //   log,
	    //   `Connector ${connector.endpoint} → ${rawMessage}`
	    // );
	  } else if (encryptedData) {
	    // 💡 encryptedJson data!!
	    if (connector.verbose == 'extra') {
	      logger.magenta(log, `Connector ${connector.endpoint} received bytes ↴`);
	      logger.gray(log, encryptedData);
	      logger.magenta(
	        log,
	        `Connector ${connector.endpoint} decrypting with shared secret ${connector.sharedSecret}...`
	      );
	    }

	    const _decryptedMessage = naclFast.secretbox.open(encryptedData, nonce, connector.sharedSecret);

	    const flag = _decryptedMessage[0];
	    const decryptedMessage = _decryptedMessage.subarray(1);

	    if (flag == 1) {
	      const decodedMessage = naclFast.util.encodeUTF8(decryptedMessage);

	      if (connector.verbose) {
	        logger.write(log, `Received message: ${decodedMessage}`);
	      }

	      try {
	        const jsonData = JSON.parse(decodedMessage);

	        // 💡 rpc
	        if (jsonData.jsonrpc) {
	          // if (connector.verbose) {
	          //   logger.magenta(log, `Connector ${connector.endpoint} decrypted rpc result ↴`);
	          //   logger.gray(log, jsonData);
	          // }

	          wireReceive({ jsonData, rawMessage: decodedMessage, wasEncrypted: true, connector });
	          // } else if (jsonData.tag) {
	          //   // 💡 tag
	          //   const msg = jsonData;

	          //   if (msg.tag == 'file_not_found') {
	          //     connector.emit(msg.tag, { ...msg, ...{ tag: undefined } });
	          //   } else if (msg.tag == 'binary_start') {
	          //     connector.emit(msg.tag, { ...msg, ...{ tag: undefined } });
	          //   } else if (msg.tag == 'binary_end') {
	          //     connector.emit(msg.tag, { sessionId: msg.sessionId });
	          //   } else {
	          //     connector.emit('receive', { jsonData, rawMessage: decodedMessage });
	          //   }
	        } else if (jsonData.state) {
	          // 💡 Initial state sending ... part of Connectome protocol
	          connector.emit('receive_state', jsonData.state);
	        } else if (jsonData.diff) {
	          // 💡 Subsequent JSON patch diffs (rfc6902)* ... part of Connectome protocol
	          connector.emit('receive_diff', jsonData.diff);
	        } else if (jsonData.signal) {
	          connector.emit(jsonData.signal, jsonData.data);
	        } else if (jsonData.stateField) {
	          connector.emit('receive_state_field', jsonData.stateField);
	        } else {
	          connector.emit('receive', { jsonData, rawMessage: decodedMessage });
	        }
	      } catch (e) {
	        logger.red(log, "Couldn't parse json message although the flag was for string ...");
	        logger.red(log, decodedMessage);
	        throw e;
	      }
	    } else {
	      //const binaryData = decryptedMessage;
	      // const sessionId = Buffer.from(binaryData.buffer, binaryData.byteOffset, 64).toString();
	      // const binaryPayload = Buffer.from(binaryData.buffer, binaryData.byteOffset + 64);
	      // connector.emit('binary_data', { sessionId, data: binaryPayload });
	      connector.emit('receive_binary', decryptedMessage);
	    }
	  }
	}

	naclFast.util = naclUtil;

	function diffieHellman({ connector, afterFirstStep = () => {} }) {
	  const {
	    clientPrivateKey,
	    clientPublicKey,
	    clientPublicKeyHex,
	    protocol,
	    tag,
	    endpoint,
	    verbose
	  } = connector;

	  return new Promise((success, reject) => {
	    connector.remoteObject('Auth')
	      .call('exchangePubkeys', { pubkey: clientPublicKeyHex })
	      .then(remotePubkeyHex => {
	        const sharedSecret = naclFast.box.before(hexToBuffer$1(remotePubkeyHex), clientPrivateKey);

	        afterFirstStep({ sharedSecret, remotePubkeyHex });

	        if (verbose) {
	          logger.write(
	            connector.log,
	            `Connector ${endpoint} established shared secret through diffie-hellman exchange.`
	          );
	        }

	        connector.remoteObject('Auth')
	          .call('finalizeHandshake', { protocol })
	          .then(res => {
	            // finalizeHandshake rpc endpoint on server can cleanly retorn {error} as a result
	            // in case the protocol we are trying to connect to is not registered (does not exist at the endpoint)
	            if (res && res.error) {
	              console.log(res.error);
	              // this connection will keep hangling and no reconnect tries will be made
	              // since we keep websocket open just that nothing is happening

	              // when we enable the protocol on the endpoint we have to restart the process
	              // frontend connector will get disconnected at this point, websocket will close
	              // and from then on it tries reconnecting again so when ws first connects
	              // and protocol is present , it will be a success

	              // DONT'T REJECT here! reject(res.error); -- we need to keep this websocket hanging
	            } else {
	              success();

	              const _tag = tag ? ` (${tag})` : '';
	              logger.cyan(
	                connector.log,
	                `${endpoint}${_tag} ✓ Connection [ ${protocol || '"no-name"'} ] ready`
	              );
	            }
	          })
	          .catch(reject); // for example Timeout ... delayed! we have to be careful with closing any connections because new websocket might have already be created, we should not close that one
	      })
	      .catch(reject);
	  });
	}

	// 💡 we use Emitter inside ConnectedStore to emit 'ready' event
	// 💡 and inside MultiConnectedStore to also emit a few events

	class ReadableStore extends Eev {
	  constructor(initialState) {
	    super();

	    this.state = initialState;

	    this.subscriptions = [];
	  }

	  get() {
	    return this.state;
	  }

	  subscribe(handler) {
	    this.subscriptions.push(handler);

	    handler(this.state);

	    return () => {
	      this.subscriptions = this.subscriptions.filter(sub => sub !== handler);
	    };
	  }

	  announceStateChange() {
	    this.subscriptions.forEach(handler => handler(this.state));
	  }
	}

	class WritableStore extends ReadableStore {
	  set(state) {
	    this.state = state;
	    this.announceStateChange();
	  }
	}

	class Channel extends Eev {
	  constructor(connector) {
	    super();

	    this.connector = connector;
	  }

	  send(...args) {
	    this.connector.send(...args);
	  }
	}

	var errorCodes = {
	  PARSE_ERROR: -32700,
	  INVALID_REQUEST: -32600,
	  METHOD_NOT_FOUND: -32601,
	  INVALID_PARAMS: -32602,
	  REMOTE_INTERNAL_ERROR: -32603,
	  TIMEOUT: -32701
	};

	class MoleServer {
	  constructor({ transports }) {
	    if (!transports) throw new Error('TRANSPORT_REQUIRED');

	    this.transportsToRegister = transports;
	    this.methods = {};
	  }

	  setMethodPrefix(methodPrefix) {
	    this.methodPrefix = methodPrefix;
	  }

	  expose(methods) {
	    this.methods = methods;
	  }

	  registerTransport(transport) {
	    transport.onData(this._processRequest.bind(this, transport));
	  }

	  async _processRequest(transport, data) {
	    const requestData = JSON.parse(data);
	    let responseData;

	    if (Array.isArray(requestData)) {
	      responseData = await Promise.all(requestData.map(request => this._callMethod(request, transport)));
	    } else {
	      responseData = await this._callMethod(requestData, transport);
	    }

	    return JSON.stringify(responseData);
	  }

	  async _callMethod(request, transport) {
	    const isRequest = request.hasOwnProperty('method');
	    if (!isRequest) return;

	    const { method, params = [], id } = request;

	    let methodName = method;

	    if (methodName.includes('::')) {
	      const [prefix, name] = methodName.split('::');
	      methodName = name;
	      if (this.methodPrefix && prefix != this.methodPrefix) {
	        return;
	      }
	    }

	    const methodNotFound =
	      !this.methods[methodName] ||
	      typeof this.methods[methodName] !== 'function' ||
	      methodName === 'constructor' ||
	      methodName.startsWith('_') ||
	      this.methods[methodName] === Object.prototype[methodName];

	    let response = {};

	    if (methodNotFound) {
	      response = {
	        jsonrpc: '2.0',
	        id,
	        error: {
	          code: errorCodes.METHOD_NOT_FOUND,
	          message: `Method [${methodName}] not found on remote target object`
	        }
	      };
	    } else {
	      this.currentTransport = transport;

	      //console.log(`Method call: ${methodName}`);

	      try {
	        const result = await this.methods[methodName].apply(this.methods, params);

	        if (!id) return;

	        response = {
	          jsonrpc: '2.0',
	          result: typeof result === 'undefined' ? null : result,
	          id
	        };
	      } catch (e) {
	        console.log(`Exposed RPC method ${method} internal error:`);
	        console.log(e);
	        console.log('Sending this error as a result to calling client ...');
	        response = {
	          jsonrpc: '2.0',
	          error: {
	            code: errorCodes.REMOTE_INTERNAL_ERROR,
	            message: `Method [${method}] internal error: ${e.stack}`
	          },
	          id
	        };
	      }
	    }

	    return response;
	  }

	  run() {
	    for (const transport of this.transportsToRegister) {
	      this.registerTransport(transport);
	    }

	    this.transportsToRegister = [];
	  }
	}

	class Base extends Error {
	  constructor(data = {}) {
	    super();

	    if (!data.code) throw new Error('Code required');
	    if (!data.message) throw new Error('Message required');

	    this.code = data.code;
	    this.message = data.message;
	  }
	}

	class MethodNotFound extends Base {
	  constructor(message) {
	    super({
	      code: errorCodes.METHOD_NOT_FOUND,
	      message: message || 'Method not found'
	    });
	  }
	}

	class InvalidParams extends Base {
	  constructor() {
	    super({
	      code: errorCodes.INVALID_PARAMS,
	      message: 'Invalid params'
	    });
	  }
	}

	class RemoteInternalError extends Base {
	  constructor(message) {
	    super({
	      code: errorCodes.REMOTE_INTERNAL_ERROR,
	      message: `Error originating at remote endpoint: ${message}` || 'Remote Internal error'
	    });
	  }
	}

	class ParseError extends Base {
	  constructor() {
	    super({
	      code: errorCodes.PARSE_ERROR,
	      message: 'Parse error'
	    });
	  }
	}

	class InvalidRequest extends Base {
	  constructor() {
	    super({
	      code: errorCodes.INVALID_REQUEST,
	      message: 'Invalid request'
	    });
	  }
	}

	class ServerError extends Base {}

	class RequestTimeout extends ServerError {
	  constructor(message, timeout) {
	    super({
	      code: errorCodes.TIMEOUT,
	      message: `Request exceeded maximum execution time (${timeout}ms): ${message}`
	    });
	  }
	}

	var X = {
	  Base,
	  MethodNotFound,
	  InvalidRequest,
	  InvalidParams,
	  RemoteInternalError,
	  ServerError,
	  ParseError,
	  RequestTimeout
	};

	class MoleClient {
	  constructor({ transport, requestTimeout = 20000 }) {
	    if (!transport) throw new Error('TRANSPORT_REQUIRED');
	    this.transport = transport;

	    this.requestTimeout = requestTimeout;

	    this.pendingRequest = {};
	    this.initialized = false;
	  }

	  setMethodPrefix(methodPrefix) {
	    this.methodPrefix = methodPrefix;
	  }

	  async callMethod(methodName, params) {
	    this._init();

	    const method = this.methodPrefix ? `${this.methodPrefix}::${methodName}` : methodName;

	    const request = this._makeRequestObject({ method, params });

	    return this._sendRequest({ object: request, id: request.id });
	  }

	  notify(method, params) {
	    this._init();

	    const request = this._makeRequestObject({ method, params, mode: 'notify' });
	    this.transport.sendData(JSON.stringify(request));
	    return true;
	  }

	  async runBatch(calls) {
	    const batchId = this._generateId();
	    let onlyNotifications = true;

	    const batchRequest = [];

	    for (const [method, params, mode] of calls) {
	      const request = this._makeRequestObject({ method, params, mode, batchId });

	      if (request.id) {
	        onlyNotifications = false;
	      }

	      batchRequest.push(request);
	    }

	    if (onlyNotifications) {
	      return this.transport.sendData(JSON.stringify(batchRequest));
	    }

	    return this._sendRequest({ object: batchRequest, id: batchId });
	  }

	  _init() {
	    if (this.initialized) return;

	    this.transport.onData(this._processResponse.bind(this));

	    this.initialized = true;
	  }

	  _sendRequest({ object, id }) {
	    const data = JSON.stringify(object);

	    return new Promise((resolve, reject) => {
	      this.pendingRequest[id] = { resolve, reject, sentObject: object };

	      setTimeout(() => {
	        if (this.pendingRequest[id]) {
	          delete this.pendingRequest[id];

	          reject(new X.RequestTimeout(data, this.requestTimeout));
	        }
	      }, this.requestTimeout);

	      try {
	        this.transport.sendData(data);
	      } catch (e) {
	        delete this.pendingRequest[id];
	        reject(e);
	      }
	    });
	  }

	  _processResponse(data) {
	    const response = JSON.parse(data);

	    if (Array.isArray(response)) {
	      this._processBatchResponse(response);
	    } else {
	      this._processSingleCallResponse(response);
	    }
	  }

	  _processSingleCallResponse(response) {
	    const isSuccessfulResponse = response.hasOwnProperty('result') || false;
	    const isErrorResponse = response.hasOwnProperty('error');

	    if (!isSuccessfulResponse && !isErrorResponse) return;

	    const resolvers = this.pendingRequest[response.id];
	    delete this.pendingRequest[response.id];

	    if (!resolvers) return;

	    if (isSuccessfulResponse) {
	      resolvers.resolve(response.result);
	    } else if (isErrorResponse) {
	      const errorObject = this._makeErrorObject(response.error);
	      resolvers.reject(errorObject);
	    }
	  }

	  _processBatchResponse(responses) {
	    let batchId;
	    const responseById = {};
	    const errorsWithoutId = [];

	    for (const response of responses) {
	      if (response.id) {
	        if (!batchId) {
	          batchId = response.id.split('|')[0];
	        }

	        responseById[response.id] = response;
	      } else if (response.error) {
	        errorsWithoutId.push(response.error);
	      }
	    }

	    if (!this.pendingRequest[batchId]) return;

	    const { sentObject, resolve } = this.pendingRequest[batchId];
	    delete this.pendingRequest[batchId];

	    const batchResults = [];
	    let errorIdx = 0;
	    for (const request of sentObject) {
	      if (!request.id) {
	        batchResults.push(null);
	        continue;
	      }

	      const response = responseById[request.id];

	      if (response) {
	        const isSuccessfulResponse = response.hasOwnProperty('result') || false;

	        if (isSuccessfulResponse) {
	          batchResults.push({
	            success: true,
	            result: response.result
	          });
	        } else {
	          batchResults.push({
	            success: false,
	            result: this._makeErrorObject(response.error)
	          });
	        }
	      } else {
	        batchResults.push({
	          success: false,
	          error: this._makeErrorObject(errorsWithoutId[errorIdx])
	        });
	        errorIdx++;
	      }
	    }

	    resolve(batchResults);
	  }

	  _makeRequestObject({ method, params, mode, batchId }) {
	    const request = {
	      jsonrpc: '2.0',
	      method
	    };

	    if (params && params.length) {
	      request.params = params;
	    }

	    if (mode !== 'notify') {
	      request.id = batchId ? `${batchId}|${this._generateId()}` : this._generateId();
	    }

	    return request;
	  }

	  _makeErrorObject(errorData) {
	    const errorBuilder = {
	      [errorCodes.METHOD_NOT_FOUND]: () => {
	        return new X.MethodNotFound(errorData.message);
	      },
	      [errorCodes.REMOTE_INTERNAL_ERROR]: () => {
	        return new X.RemoteInternalError(errorData.message);
	      }
	    }[errorData.code];

	    return errorBuilder();
	  }

	  _generateId() {
	    const alphabet = 'bjectSymhasOwnProp-0123456789ABCDEFGHIJKLMNQRTUVWXYZ_dfgiklquvxz';
	    let size = 10;
	    let id = '';

	    while (0 < size--) {
	      id += alphabet[(Math.random() * 64) | 0];
	    }

	    return id;
	  }
	}

	function proxify(moleClient) {
	  const callMethodProxy = proxifyOwnMethod(moleClient.callMethod.bind(moleClient));
	  const notifyProxy = proxifyOwnMethod(moleClient.notify.bind(moleClient));

	  return new Proxy(moleClient, {
	    get(target, methodName) {
	      if (methodName === 'notify') {
	        return notifyProxy;
	      }

	      if (methodName === 'callMethod') {
	        return callMethodProxy;
	      }

	      if (methodName === 'then') {
	        return;
	      }

	      if (methodName === 'setMethodPrefix') {
	        return (...params) => moleClient.setMethodPrefix(params);
	      }

	      return (...params) => target.callMethod.call(target, methodName, params);
	    }
	  });
	}

	function proxifyOwnMethod(ownMethod) {
	  return new Proxy(ownMethod, {
	    get(target, methodName) {
	      return (...params) => target.call(null, methodName, params);
	    },
	    apply(target, _, args) {
	      return target.apply(null, args);
	    }
	  });
	}

	class MoleClientProxified extends MoleClient {
	  constructor(...args) {
	    super(...args);
	    return proxify(this);
	  }
	}

	class TransportClientChannel {
	  constructor(channel) {
	    this.channel = channel;
	  }

	  onData(callback) {
	    this.channel.on('json_rpc', callback);
	  }

	  sendData(data) {
	    this.channel.send(data);
	  }
	}

	class TransportServerChannel {
	  constructor(channel) {
	    this.channel = channel;
	  }

	  onData(callback) {
	    this.channel.on('json_rpc', async reqData => {
	      const resData = await callback(reqData);
	      if (!resData) return;

	      this.channel.send(resData);
	    });
	  }
	}

	var mole = /*#__PURE__*/Object.freeze({
		__proto__: null,
		MoleServer: MoleServer,
		MoleClient: MoleClient,
		MoleClientProxified: MoleClientProxified,
		ClientTransport: TransportClientChannel,
		ServerTransport: TransportServerChannel
	});

	class ConnectomeError extends Error {
	  constructor(message, errorCode) {
	    super(message);

	    this.name = this.constructor.name;

	    this.errorCode = errorCode;
	  }

	  errorCode() {
	    return this.errorCode;
	  }
	}

	const { MoleClient: MoleClient$1, ClientTransport } = mole;

	class SpecificRpcClient {
	  constructor(connectorOrServersideChannel, methodPrefix, requestTimeout) {
	    this.moleChannel = new Channel(connectorOrServersideChannel);
	    this.methodPrefix = methodPrefix;

	    this.connectorOrServersideChannel = connectorOrServersideChannel;

	    this.client = new MoleClient$1({
	      requestTimeout,
	      transport: new ClientTransport(this.moleChannel)
	    });
	  }

	  jsonrpcMsgReceive(stringMessage) {
	    this.moleChannel.emit('json_rpc', stringMessage);
	  }

	  call(methodName, params) {
	    if (this.connectorOrServersideChannel.closed()) {
	      return new Promise((success, reject) => {
	        reject(
	          new ConnectomeError(
	            `Method call [${this.methodPrefix}::${methodName}] on closed channel or connector ignored. Please add a check for closed channel in your code.`,
	            'CLOSED_CHANNEL'
	          )
	        );
	      });
	    }

	    return this.client.callMethod(`${this.methodPrefix}::${methodName}`, params);
	  }
	}

	const DEFAULT_REQUEST_TIMEOUT = 10000;

	class RpcClient {
	  constructor(connectorOrServersideChannel, requestTimeout) {
	    this.connectorOrServersideChannel = connectorOrServersideChannel;
	    this.remoteObjects = {};
	    this.requestTimeout = requestTimeout || DEFAULT_REQUEST_TIMEOUT;
	  }

	  remoteObject(methodPrefix) {
	    const remoteObject = this.remoteObjects[methodPrefix];
	    if (!remoteObject) {
	      this.remoteObjects[methodPrefix] = new SpecificRpcClient(this.connectorOrServersideChannel, methodPrefix, this.requestTimeout);
	    }
	    return this.remoteObjects[methodPrefix];
	  }

	  jsonrpcMsgReceive(stringMessage) {
	    for (const remoteObject of Object.values(this.remoteObjects)) {
	      remoteObject.jsonrpcMsgReceive(stringMessage);
	    }
	  }
	}

	class RPCTarget {
	  constructor({ serversideChannel, serverMethods, methodPrefix }) {
	    const transports = [new TransportServerChannel(serversideChannel)];
	    this.server = new MoleServer({ transports });
	    this.server.expose(serverMethods);
	    this.server.setMethodPrefix(methodPrefix);
	    this.server.run();
	  }
	}

	naclFast.util = naclUtil;

	function newKeypair() {
	  const keys = naclFast.box.keyPair();
	  const publicKeyHex = bufferToHex$1(keys.publicKey);
	  const privateKeyHex = bufferToHex$1(keys.secretKey);

	  return { privateKey: keys.secretKey, publicKey: keys.publicKey, privateKeyHex, publicKeyHex };
	}

	naclFast.util = naclUtil;

	function acceptKeypair(keypair) {
	  if (keypair.publicKeyHex && !keypair.publicKey) {
	    keypair.publicKey = hexToBuffer$1(keypair.publicKeyHex);
	  }

	  if (keypair.privateKeyHex && !keypair.privateKey) {
	    keypair.privateKey = hexToBuffer$1(keypair.privateKeyHex);
	  }

	  return keypair;
	}

	/*!
	 * https://github.com/Starcounter-Jack/JSON-Patch
	 * (c) 2017 Joachim Wester
	 * MIT license
	 */
	var __extends$1 =  (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
	function hasOwnProperty$1(obj, key) {
	    return _hasOwnProperty$1.call(obj, key);
	}
	function _objectKeys$1(obj) {
	    if (Array.isArray(obj)) {
	        var keys = new Array(obj.length);
	        for (var k = 0; k < keys.length; k++) {
	            keys[k] = "" + k;
	        }
	        return keys;
	    }
	    if (Object.keys) {
	        return Object.keys(obj);
	    }
	    var keys = [];
	    for (var i in obj) {
	        if (hasOwnProperty$1(obj, i)) {
	            keys.push(i);
	        }
	    }
	    return keys;
	}
	/**
	* Deeply clone the object.
	* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)
	* @param  {any} obj value to clone
	* @return {any} cloned obj
	*/
	function _deepClone$1(obj) {
	    switch (typeof obj) {
	        case "object":
	            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
	        case "undefined":
	            return null; //this is how JSON.stringify behaves for array items
	        default:
	            return obj; //no need to clone primitives
	    }
	}
	//3x faster than cached /^\d+$/.test(str)
	function isInteger$1(str) {
	    var i = 0;
	    var len = str.length;
	    var charCode;
	    while (i < len) {
	        charCode = str.charCodeAt(i);
	        if (charCode >= 48 && charCode <= 57) {
	            i++;
	            continue;
	        }
	        return false;
	    }
	    return true;
	}
	/**
	* Escapes a json pointer path
	* @param path The raw pointer
	* @return the Escaped path
	*/
	function escapePathComponent$1(path) {
	    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)
	        return path;
	    return path.replace(/~/g, '~0').replace(/\//g, '~1');
	}
	/**
	 * Unescapes a json pointer path
	 * @param path The escaped pointer
	 * @return The unescaped path
	 */
	function unescapePathComponent$1(path) {
	    return path.replace(/~1/g, '/').replace(/~0/g, '~');
	}
	/**
	* Recursively checks whether an object has any undefined values inside.
	*/
	function hasUndefined$1(obj) {
	    if (obj === undefined) {
	        return true;
	    }
	    if (obj) {
	        if (Array.isArray(obj)) {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                if (hasUndefined$1(obj[i])) {
	                    return true;
	                }
	            }
	        }
	        else if (typeof obj === "object") {
	            var objKeys = _objectKeys$1(obj);
	            var objKeysLength = objKeys.length;
	            for (var i = 0; i < objKeysLength; i++) {
	                if (hasUndefined$1(obj[objKeys[i]])) {
	                    return true;
	                }
	            }
	        }
	    }
	    return false;
	}
	function patchErrorMessageFormatter$1(message, args) {
	    var messageParts = [message];
	    for (var key in args) {
	        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print
	        if (typeof value !== 'undefined') {
	            messageParts.push(key + ": " + value);
	        }
	    }
	    return messageParts.join('\n');
	}
	var PatchError$1 = /** @class */ (function (_super) {
	    __extends$1(PatchError, _super);
	    function PatchError(message, name, index, operation, tree) {
	        var _newTarget = this.constructor;
	        var _this = _super.call(this, patchErrorMessageFormatter$1(message, { name: name, index: index, operation: operation, tree: tree })) || this;
	        _this.name = name;
	        _this.index = index;
	        _this.operation = operation;
	        _this.tree = tree;
	        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359
	        _this.message = patchErrorMessageFormatter$1(message, { name: name, index: index, operation: operation, tree: tree });
	        return _this;
	    }
	    return PatchError;
	}(Error));

	var JsonPatchError$1 = PatchError$1;
	var deepClone$1 = _deepClone$1;
	/* We use a Javascript hash to store each
	 function. Each hash entry (property) uses
	 the operation identifiers specified in rfc6902.
	 In this way, we can map each patch operation
	 to its dedicated function in efficient way.
	 */
	/* The operations applicable to an object */
	var objOps$1 = {
	    add: function (obj, key, document) {
	        obj[key] = this.value;
	        return { newDocument: document };
	    },
	    remove: function (obj, key, document) {
	        var removed = obj[key];
	        delete obj[key];
	        return { newDocument: document, removed: removed };
	    },
	    replace: function (obj, key, document) {
	        var removed = obj[key];
	        obj[key] = this.value;
	        return { newDocument: document, removed: removed };
	    },
	    move: function (obj, key, document) {
	        /* in case move target overwrites an existing value,
	        return the removed value, this can be taxing performance-wise,
	        and is potentially unneeded */
	        var removed = getValueByPointer$1(document, this.path);
	        if (removed) {
	            removed = _deepClone$1(removed);
	        }
	        var originalValue = applyOperation$1(document, { op: "remove", path: this.from }).removed;
	        applyOperation$1(document, { op: "add", path: this.path, value: originalValue });
	        return { newDocument: document, removed: removed };
	    },
	    copy: function (obj, key, document) {
	        var valueToCopy = getValueByPointer$1(document, this.from);
	        // enforce copy by value so further operations don't affect source (see issue #177)
	        applyOperation$1(document, { op: "add", path: this.path, value: _deepClone$1(valueToCopy) });
	        return { newDocument: document };
	    },
	    test: function (obj, key, document) {
	        return { newDocument: document, test: _areEquals$1(obj[key], this.value) };
	    },
	    _get: function (obj, key, document) {
	        this.value = obj[key];
	        return { newDocument: document };
	    }
	};
	/* The operations applicable to an array. Many are the same as for the object */
	var arrOps$1 = {
	    add: function (arr, i, document) {
	        if (isInteger$1(i)) {
	            arr.splice(i, 0, this.value);
	        }
	        else { // array props
	            arr[i] = this.value;
	        }
	        // this may be needed when using '-' in an array
	        return { newDocument: document, index: i };
	    },
	    remove: function (arr, i, document) {
	        var removedList = arr.splice(i, 1);
	        return { newDocument: document, removed: removedList[0] };
	    },
	    replace: function (arr, i, document) {
	        var removed = arr[i];
	        arr[i] = this.value;
	        return { newDocument: document, removed: removed };
	    },
	    move: objOps$1.move,
	    copy: objOps$1.copy,
	    test: objOps$1.test,
	    _get: objOps$1._get
	};
	/**
	 * Retrieves a value from a JSON document by a JSON pointer.
	 * Returns the value.
	 *
	 * @param document The document to get the value from
	 * @param pointer an escaped JSON pointer
	 * @return The retrieved value
	 */
	function getValueByPointer$1(document, pointer) {
	    if (pointer == '') {
	        return document;
	    }
	    var getOriginalDestination = { op: "_get", path: pointer };
	    applyOperation$1(document, getOriginalDestination);
	    return getOriginalDestination.value;
	}
	/**
	 * Apply a single JSON Patch Operation on a JSON document.
	 * Returns the {newDocument, result} of the operation.
	 * It modifies the `document` and `operation` objects - it gets the values by reference.
	 * If you would like to avoid touching your values, clone them:
	 * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.
	 *
	 * @param document The document to patch
	 * @param operation The operation to apply
	 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
	 * @param mutateDocument Whether to mutate the original document or clone it before applying
	 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
	 * @return `{newDocument, result}` after the operation
	 */
	function applyOperation$1(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
	    if (validateOperation === void 0) { validateOperation = false; }
	    if (mutateDocument === void 0) { mutateDocument = true; }
	    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
	    if (index === void 0) { index = 0; }
	    if (validateOperation) {
	        if (typeof validateOperation == 'function') {
	            validateOperation(operation, 0, document, operation.path);
	        }
	        else {
	            validator$1(operation, 0);
	        }
	    }
	    /* ROOT OPERATIONS */
	    if (operation.path === "") {
	        var returnValue = { newDocument: document };
	        if (operation.op === 'add') {
	            returnValue.newDocument = operation.value;
	            return returnValue;
	        }
	        else if (operation.op === 'replace') {
	            returnValue.newDocument = operation.value;
	            returnValue.removed = document; //document we removed
	            return returnValue;
	        }
	        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root
	            returnValue.newDocument = getValueByPointer$1(document, operation.from); // get the value by json-pointer in `from` field
	            if (operation.op === 'move') { // report removed item
	                returnValue.removed = document;
	            }
	            return returnValue;
	        }
	        else if (operation.op === 'test') {
	            returnValue.test = _areEquals$1(document, operation.value);
	            if (returnValue.test === false) {
	                throw new JsonPatchError$1("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
	            }
	            returnValue.newDocument = document;
	            return returnValue;
	        }
	        else if (operation.op === 'remove') { // a remove on root
	            returnValue.removed = document;
	            returnValue.newDocument = null;
	            return returnValue;
	        }
	        else if (operation.op === '_get') {
	            operation.value = document;
	            return returnValue;
	        }
	        else { /* bad operation */
	            if (validateOperation) {
	                throw new JsonPatchError$1('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
	            }
	            else {
	                return returnValue;
	            }
	        }
	    } /* END ROOT OPERATIONS */
	    else {
	        if (!mutateDocument) {
	            document = _deepClone$1(document);
	        }
	        var path = operation.path || "";
	        var keys = path.split('/');
	        var obj = document;
	        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift
	        var len = keys.length;
	        var existingPathFragment = undefined;
	        var key = void 0;
	        var validateFunction = void 0;
	        if (typeof validateOperation == 'function') {
	            validateFunction = validateOperation;
	        }
	        else {
	            validateFunction = validator$1;
	        }
	        while (true) {
	            key = keys[t];
	            if (banPrototypeModifications && key == '__proto__') {
	                throw new TypeError('JSON-Patch: modifying `__proto__` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');
	            }
	            if (validateOperation) {
	                if (existingPathFragment === undefined) {
	                    if (obj[key] === undefined) {
	                        existingPathFragment = keys.slice(0, t).join('/');
	                    }
	                    else if (t == len - 1) {
	                        existingPathFragment = operation.path;
	                    }
	                    if (existingPathFragment !== undefined) {
	                        validateFunction(operation, 0, document, existingPathFragment);
	                    }
	                }
	            }
	            t++;
	            if (Array.isArray(obj)) {
	                if (key === '-') {
	                    key = obj.length;
	                }
	                else {
	                    if (validateOperation && !isInteger$1(key)) {
	                        throw new JsonPatchError$1("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
	                    } // only parse key when it's an integer for `arr.prop` to work
	                    else if (isInteger$1(key)) {
	                        key = ~~key;
	                    }
	                }
	                if (t >= len) {
	                    if (validateOperation && operation.op === "add" && key > obj.length) {
	                        throw new JsonPatchError$1("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
	                    }
	                    var returnValue = arrOps$1[operation.op].call(operation, obj, key, document); // Apply patch
	                    if (returnValue.test === false) {
	                        throw new JsonPatchError$1("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
	                    }
	                    return returnValue;
	                }
	            }
	            else {
	                if (key && key.indexOf('~') != -1) {
	                    key = unescapePathComponent$1(key);
	                }
	                if (t >= len) {
	                    var returnValue = objOps$1[operation.op].call(operation, obj, key, document); // Apply patch
	                    if (returnValue.test === false) {
	                        throw new JsonPatchError$1("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
	                    }
	                    return returnValue;
	                }
	            }
	            obj = obj[key];
	        }
	    }
	}
	/**
	 * Apply a full JSON Patch array on a JSON document.
	 * Returns the {newDocument, result} of the patch.
	 * It modifies the `document` object and `patch` - it gets the values by reference.
	 * If you would like to avoid touching your values, clone them:
	 * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.
	 *
	 * @param document The document to patch
	 * @param patch The patch to apply
	 * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.
	 * @param mutateDocument Whether to mutate the original document or clone it before applying
	 * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.
	 * @return An array of `{newDocument, result}` after the patch
	 */
	function applyPatch$1(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
	    if (mutateDocument === void 0) { mutateDocument = true; }
	    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }
	    if (validateOperation) {
	        if (!Array.isArray(patch)) {
	            throw new JsonPatchError$1('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
	        }
	    }
	    if (!mutateDocument) {
	        document = _deepClone$1(document);
	    }
	    var results = new Array(patch.length);
	    for (var i = 0, length_1 = patch.length; i < length_1; i++) {
	        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`
	        results[i] = applyOperation$1(document, patch[i], validateOperation, true, banPrototypeModifications, i);
	        document = results[i].newDocument; // in case root was replaced
	    }
	    results.newDocument = document;
	    return results;
	}
	/**
	 * Apply a single JSON Patch Operation on a JSON document.
	 * Returns the updated document.
	 * Suitable as a reducer.
	 *
	 * @param document The document to patch
	 * @param operation The operation to apply
	 * @return The updated document
	 */
	function applyReducer$1(document, operation, index) {
	    var operationResult = applyOperation$1(document, operation);
	    if (operationResult.test === false) { // failed test
	        throw new JsonPatchError$1("Test operation failed", 'TEST_OPERATION_FAILED', index, operation, document);
	    }
	    return operationResult.newDocument;
	}
	/**
	 * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.
	 * @param {object} operation - operation object (patch)
	 * @param {number} index - index of operation in the sequence
	 * @param {object} [document] - object where the operation is supposed to be applied
	 * @param {string} [existingPathFragment] - comes along with `document`
	 */
	function validator$1(operation, index, document, existingPathFragment) {
	    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {
	        throw new JsonPatchError$1('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);
	    }
	    else if (!objOps$1[operation.op]) {
	        throw new JsonPatchError$1('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);
	    }
	    else if (typeof operation.path !== 'string') {
	        throw new JsonPatchError$1('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);
	    }
	    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {
	        // paths that aren't empty string should start with "/"
	        throw new JsonPatchError$1('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', index, operation, document);
	    }
	    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {
	        throw new JsonPatchError$1('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);
	    }
	    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {
	        throw new JsonPatchError$1('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);
	    }
	    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && hasUndefined$1(operation.value)) {
	        throw new JsonPatchError$1('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);
	    }
	    else if (document) {
	        if (operation.op == "add") {
	            var pathLen = operation.path.split("/").length;
	            var existingPathLen = existingPathFragment.split("/").length;
	            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
	                throw new JsonPatchError$1('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);
	            }
	        }
	        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {
	            if (operation.path !== existingPathFragment) {
	                throw new JsonPatchError$1('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);
	            }
	        }
	        else if (operation.op === 'move' || operation.op === 'copy') {
	            var existingValue = { op: "_get", path: operation.from, value: undefined };
	            var error = validate$1([existingValue], document);
	            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {
	                throw new JsonPatchError$1('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);
	            }
	        }
	    }
	}
	/**
	 * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.
	 * If error is encountered, returns a JsonPatchError object
	 * @param sequence
	 * @param document
	 * @returns {JsonPatchError|undefined}
	 */
	function validate$1(sequence, document, externalValidator) {
	    try {
	        if (!Array.isArray(sequence)) {
	            throw new JsonPatchError$1('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
	        }
	        if (document) {
	            //clone document and sequence so that we can safely try applying operations
	            applyPatch$1(_deepClone$1(document), _deepClone$1(sequence), externalValidator || true);
	        }
	        else {
	            externalValidator = externalValidator || validator$1;
	            for (var i = 0; i < sequence.length; i++) {
	                externalValidator(sequence[i], i, document, undefined);
	            }
	        }
	    }
	    catch (e) {
	        if (e instanceof JsonPatchError$1) {
	            return e;
	        }
	        else {
	            throw e;
	        }
	    }
	}
	// based on https://github.com/epoberezkin/fast-deep-equal
	// MIT License
	// Copyright (c) 2017 Evgeny Poberezkin
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	// The above copyright notice and this permission notice shall be included in all
	// copies or substantial portions of the Software.
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	// SOFTWARE.
	function _areEquals$1(a, b) {
	    if (a === b)
	        return true;
	    if (a && b && typeof a == 'object' && typeof b == 'object') {
	        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
	        if (arrA && arrB) {
	            length = a.length;
	            if (length != b.length)
	                return false;
	            for (i = length; i-- !== 0;)
	                if (!_areEquals$1(a[i], b[i]))
	                    return false;
	            return true;
	        }
	        if (arrA != arrB)
	            return false;
	        var keys = Object.keys(a);
	        length = keys.length;
	        if (length !== Object.keys(b).length)
	            return false;
	        for (i = length; i-- !== 0;)
	            if (!b.hasOwnProperty(keys[i]))
	                return false;
	        for (i = length; i-- !== 0;) {
	            key = keys[i];
	            if (!_areEquals$1(a[key], b[key]))
	                return false;
	        }
	        return true;
	    }
	    return a !== a && b !== b;
	}

	var core$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		JsonPatchError: JsonPatchError$1,
		deepClone: deepClone$1,
		getValueByPointer: getValueByPointer$1,
		applyOperation: applyOperation$1,
		applyPatch: applyPatch$1,
		applyReducer: applyReducer$1,
		validator: validator$1,
		validate: validate$1,
		_areEquals: _areEquals$1
	});

	/*!
	 * https://github.com/Starcounter-Jack/JSON-Patch
	 * (c) 2017 Joachim Wester
	 * MIT license
	 */
	var beforeDict$1 = new WeakMap();
	var Mirror$1 = /** @class */ (function () {
	    function Mirror(obj) {
	        this.observers = new Map();
	        this.obj = obj;
	    }
	    return Mirror;
	}());
	var ObserverInfo$1 = /** @class */ (function () {
	    function ObserverInfo(callback, observer) {
	        this.callback = callback;
	        this.observer = observer;
	    }
	    return ObserverInfo;
	}());
	function getMirror$1(obj) {
	    return beforeDict$1.get(obj);
	}
	function getObserverFromMirror$1(mirror, callback) {
	    return mirror.observers.get(callback);
	}
	function removeObserverFromMirror$1(mirror, observer) {
	    mirror.observers.delete(observer.callback);
	}
	/**
	 * Detach an observer from an object
	 */
	function unobserve$1(root, observer) {
	    observer.unobserve();
	}
	/**
	 * Observes changes made to an object, which can then be retrieved using generate
	 */
	function observe$1(obj, callback) {
	    var patches = [];
	    var observer;
	    var mirror = getMirror$1(obj);
	    if (!mirror) {
	        mirror = new Mirror$1(obj);
	        beforeDict$1.set(obj, mirror);
	    }
	    else {
	        var observerInfo = getObserverFromMirror$1(mirror, callback);
	        observer = observerInfo && observerInfo.observer;
	    }
	    if (observer) {
	        return observer;
	    }
	    observer = {};
	    mirror.value = _deepClone$1(obj);
	    if (callback) {
	        observer.callback = callback;
	        observer.next = null;
	        var dirtyCheck = function () {
	            generate$1(observer);
	        };
	        var fastCheck = function () {
	            clearTimeout(observer.next);
	            observer.next = setTimeout(dirtyCheck);
	        };
	        if (typeof window !== 'undefined') { //not Node
	            window.addEventListener('mouseup', fastCheck);
	            window.addEventListener('keyup', fastCheck);
	            window.addEventListener('mousedown', fastCheck);
	            window.addEventListener('keydown', fastCheck);
	            window.addEventListener('change', fastCheck);
	        }
	    }
	    observer.patches = patches;
	    observer.object = obj;
	    observer.unobserve = function () {
	        generate$1(observer);
	        clearTimeout(observer.next);
	        removeObserverFromMirror$1(mirror, observer);
	        if (typeof window !== 'undefined') {
	            window.removeEventListener('mouseup', fastCheck);
	            window.removeEventListener('keyup', fastCheck);
	            window.removeEventListener('mousedown', fastCheck);
	            window.removeEventListener('keydown', fastCheck);
	            window.removeEventListener('change', fastCheck);
	        }
	    };
	    mirror.observers.set(callback, new ObserverInfo$1(callback, observer));
	    return observer;
	}
	/**
	 * Generate an array of patches from an observer
	 */
	function generate$1(observer, invertible) {
	    if (invertible === void 0) { invertible = false; }
	    var mirror = beforeDict$1.get(observer.object);
	    _generate$1(mirror.value, observer.object, observer.patches, "", invertible);
	    if (observer.patches.length) {
	        applyPatch$1(mirror.value, observer.patches);
	    }
	    var temp = observer.patches;
	    if (temp.length > 0) {
	        observer.patches = [];
	        if (observer.callback) {
	            observer.callback(temp);
	        }
	    }
	    return temp;
	}
	// Dirty check if obj is different from mirror, generate patches and update mirror
	function _generate$1(mirror, obj, patches, path, invertible) {
	    if (obj === mirror) {
	        return;
	    }
	    if (typeof obj.toJSON === "function") {
	        obj = obj.toJSON();
	    }
	    var newKeys = _objectKeys$1(obj);
	    var oldKeys = _objectKeys$1(mirror);
	    var deleted = false;
	    //if ever "move" operation is implemented here, make sure this test runs OK: "should not generate the same patch twice (move)"
	    for (var t = oldKeys.length - 1; t >= 0; t--) {
	        var key = oldKeys[t];
	        var oldVal = mirror[key];
	        if (hasOwnProperty$1(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
	            var newVal = obj[key];
	            if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
	                _generate$1(oldVal, newVal, patches, path + "/" + escapePathComponent$1(key), invertible);
	            }
	            else {
	                if (oldVal !== newVal) {
	                    if (invertible) {
	                        patches.push({ op: "test", path: path + "/" + escapePathComponent$1(key), value: _deepClone$1(oldVal) });
	                    }
	                    patches.push({ op: "replace", path: path + "/" + escapePathComponent$1(key), value: _deepClone$1(newVal) });
	                }
	            }
	        }
	        else if (Array.isArray(mirror) === Array.isArray(obj)) {
	            if (invertible) {
	                patches.push({ op: "test", path: path + "/" + escapePathComponent$1(key), value: _deepClone$1(oldVal) });
	            }
	            patches.push({ op: "remove", path: path + "/" + escapePathComponent$1(key) });
	            deleted = true; // property has been deleted
	        }
	        else {
	            if (invertible) {
	                patches.push({ op: "test", path: path, value: mirror });
	            }
	            patches.push({ op: "replace", path: path, value: obj });
	        }
	    }
	    if (!deleted && newKeys.length == oldKeys.length) {
	        return;
	    }
	    for (var t = 0; t < newKeys.length; t++) {
	        var key = newKeys[t];
	        if (!hasOwnProperty$1(mirror, key) && obj[key] !== undefined) {
	            patches.push({ op: "add", path: path + "/" + escapePathComponent$1(key), value: _deepClone$1(obj[key]) });
	        }
	    }
	}
	/**
	 * Create an array of patches from the differences in two objects
	 */
	function compare$1(tree1, tree2, invertible) {
	    if (invertible === void 0) { invertible = false; }
	    var patches = [];
	    _generate$1(tree1, tree2, patches, '', invertible);
	    return patches;
	}

	var duplex$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		unobserve: unobserve$1,
		observe: observe$1,
		generate: generate$1,
		compare: compare$1
	});

	var fastJsonPatch = Object.assign({}, core$1, duplex$1, {
	    JsonPatchError: PatchError$1,
	    deepClone: _deepClone$1,
	    escapePathComponent: escapePathComponent$1,
	    unescapePathComponent: unescapePathComponent$1
	});

	const { applyPatch: applyJSONPatch } = fastJsonPatch;

	class protocolState extends WritableStore {
	  constructor(connector) {
	    super({});

	    this.connector = connector;

	    // 💡 Special incoming JSON message: { state: ... } ... parsed as part of 'Connectome State Syncing Protocol'
	    this.connector.on('receive_state', state => {
	      this.wireStateReceived = true;

	      // if (this.verbose) {
	      //   console.log(`New store ${address} / ${this.protocol} / ${this.lane} state:`);
	      //   console.log(state);
	      // }

	      this.set(state); // set and announce state
	    });

	    // 💡 Special incoming JSON message: { diff: ... } ... parsed as part of 'Connectome State Syncing Protocol'
	    this.connector.on('receive_diff', diff => {
	      if (this.wireStateReceived) {
	        applyJSONPatch(this.state, diff);
	        this.announceStateChange();
	      }
	    });
	  }

	  field(name) {
	    return this.connector.connectionState.get(name);
	  }
	}

	class connectionState extends WritableStore {
	  constructor(connector) {
	    super({});

	    this.fields = {};

	    this.connector = connector;

	    // fields (we don't do diffing here, always the entire state)
	    this.connector.on('receive_state_field', ({ name, state }) => {
	      this.get(name).set(state); // set and announce per channel state
	    });
	  }

	  // default is null, not {} !
	  get(name) {
	    if (!this.fields[name]) {
	      this.fields[name] = new WritableStore();
	    }

	    return this.fields[name];
	  }
	}

	naclFast.util = naclUtil;

	const ADJUST_UNDEFINED_CONNECTION_STATUS_DELAY = 700; // was 700 for a long time, was ok, maybe a bit long, before that 300

	const DECOMMISSION_INACTIVITY = 60000; // 1min
	//const DECOMMISSION_INACTIVITY = 120000; // 2min
	//const DECOMMISSION_INACTIVITY = 10000; // 2min

	const wsOPEN = 1;

	class Connector extends Eev {
	  constructor({
	    endpoint,
	    protocol,
	    keypair = newKeypair(),
	    rpcRequestTimeout,
	    verbose = false,
	    tag,
	    log = console.log,
	    autoDecommission = false,
	    dummy
	  } = {}) {
	    super();

	    this.protocol = protocol;
	    this.log = log;

	    const { privateKey: clientPrivateKey, publicKey: clientPublicKey } = acceptKeypair(keypair);

	    this.clientPrivateKey = clientPrivateKey;
	    this.clientPublicKey = clientPublicKey;
	    this.clientPublicKeyHex = bufferToHex$1(clientPublicKey);

	    this.rpcClient = new RpcClient(this, rpcRequestTimeout);

	    this.endpoint = endpoint;
	    this.verbose = verbose;
	    this.tag = tag;

	    this.autoDecommission = autoDecommission;

	    this.sentCount = 0;
	    this.receivedCount = 0;

	    this.successfulConnectsCount = 0;

	    if (!dummy) {
	      // remove this check once legacyLib with old MCS is removed
	      // we call connect from legacyLib with dummy == true and this doesn't get invoked
	      // it messes with MCS state in some weird ways, no idea why even
	      // new MCS doesn't have these problems
	      this.state = new protocolState(this);
	      this.connectionState = new connectionState(this);
	    }

	    this.connected = new WritableStore();

	    this.delayedAdjustConnectionStatus();

	    if (verbose) {
	      logger.green(this.log, `Connector ${this.endpoint} created`);
	    }

	    this.decommissionCheckCounter = 0;

	    // not actually true but for what we need it's great ...
	    // this will make sure that we correctly decommission connectors that never even connected for the first time
	    this.lastPongReceivedAt = Date.now();

	    this.on('pong', () => {
	      this.lastPongReceivedAt = Date.now();
	    });
	  }

	  delayedAdjustConnectionStatus() {
	    // 💡 connected == undefined ==> while trying to connect
	    // 💡 connected == false => while disconnected
	    // 💡 connected == true => while connected
	    // for better GUI
	    setTimeout(() => {
	      if (this.connected.get() == undefined) {
	        this.connected.set(false);
	      }
	    }, ADJUST_UNDEFINED_CONNECTION_STATUS_DELAY);
	  }

	  send(data) {
	    send({ data, connector: this });
	    this.sentCount += 1;
	  }

	  signal(signal, data) {
	    if (this.connected.get()) {
	      this.send({ signal, data });
	    } else {
	      logger.write(
	        this.log,
	        'Warning: trying to send signal over disconnected connector, this should be prevented by GUI'
	      );
	    }
	  }

	  // convenience method
	  userAction({ action, scope, payload }) {
	    this.signal('__action', { action, scope, payload });
	  }

	  // pre-check for edge cases
	  on(eventName, handler) {
	    if (eventName == 'ready') {
	      // latecomer !! for example via connectorPool.getConnector
	      // connector might be ready or not ..
	      // with earlier approach we might have missed on ready event because we are attaching handler like this:
	      //
	      // connectorPool.getConnector({ endpoint, host: address, port, deviceTag }).then(connector => {
	      //   connector.on('ready', () => {
	      //     onReconnect({ connector, slotName, program, selectorPredicate });
	      //   });
	      // ...

	      if (this.isReady()) {
	        // connector already ready at time of attaching on ready event,
	        // we have missed the event, now simulate the event so that
	        // calling code handler is executed and client is aware of correct status
	        handler(); // we call on('ready', () => { ... }) handler manually for attached code that missed the event
	      }
	    }

	    // attach real handler
	    super.on(eventName, handler);
	  }

	  // just used in connectome examples for now, no real use in api
	  getSharedSecret() {
	    return this.sharedSecret ? bufferToHex$1(this.sharedSecret) : undefined;
	  }

	  wireReceive({ jsonData, encryptedData, rawMessage }) {
	    wireReceive({ jsonData, encryptedData, rawMessage, connector: this });
	    this.receivedCount += 1;
	  }

	  field(name) {
	    return this.connectionState.get(name);
	  }

	  isReady() {
	    return this.ready;
	  }

	  closed() {
	    return !this.transportConnected;
	  }

	  connectStatus(connected) {
	    if (connected) {
	      this.sentCount = 0;
	      this.receivedCount = 0;

	      this.transportConnected = true;

	      this.successfulConnectsCount += 1;

	      if (this.verbose) {
	        logger.green(this.log, `✓ Connector ${this.endpoint} connected #${this.successfulConnectsCount}`);
	      }

	      const websocketId = this.connection.websocket.__id;

	      const afterFirstStep = ({ sharedSecret, remotePubkeyHex }) => {
	        this.sharedSecret = sharedSecret;
	        this._remotePubkeyHex = remotePubkeyHex;
	      };

	      // there can {error} object returned from finalizeHandshake in case protocol is not present on server
	      // websocket will just keep hanging until first reconnect and prehaps then the desired protocol is present in the endpoint
	      // two more possible errors which are indeed handled in our catch block are:
	      // - timeout when handshake messages were delayed, we have to try again in this case
	      // - some other rpc error (?) mayme implementation.. but this is not relevant since we have no issues that throw inside our handshake
	      // procuderes on server - it is tested well enough, perhaps later if something is added we will encounter such errors again?
	      diffieHellman({ connector: this, afterFirstStep })
	        .then(() => {
	          this.connectedAt = Date.now();
	          this.connected.set(true);

	          this.ready = true;
	          this.emit('ready'); //⚠️ Note: when inside any client handler for ready we throw an error it gets caught in the following catch statement (along with Timeouts and other things)
	        })
	        .catch(e => {
	          // if there was a timeout error our websocket MIGHT have already closed
	          // we only drop the current websocket if it is still open,
	          // most likely it was not a timeout but some error on the other end which was passed to us
	          // websocket would stay open but to try and reconnect we have to drop it, otherwise it will be left hanging
	          // but sometimes we also get an open websocket after rpc timeout (not sure but this code handles it anyway, should be no problem, only better for all cases)
	          if (
	            this.connection.websocket.__id == websocketId &&
	            this.connection.websocket.readyState == wsOPEN
	          ) {
	            //⚠️ we only show if it seems still relevant, special case
	            // previously we had this first log output above this if statement
	            // so on every reject
	            // but then timeout messages sometimes came for websockets that already closed because of normal reconnect when dmt-proc was restarting etc.
	            // and it was strange because new connector was ready and then this late error came
	            // now we don't report handshake rpc errors on already closed websockets, they are probably no interesting at all
	            // but still - watch this space for some time, maybe there are some small remaining voids in this logic
	            if (e.code == errorCodes.TIMEOUT) {
	              logger.write(
	                this.log,
	                `${this.endpoint} x Connector [ ${this.protocol} ] handshake error: "${e.message}"`
	              );

	              logger.write(
	                this.log,
	                `${this.endpoint} Connector dropping stale websocket after handshake error`
	              );

	              // ⚠️ todo: test with some rpc error (not timeout) .. (not sure how to achieve it)..
	              // not so urgent since we don't expect rpc errors except timeouts (we don't have bugs in remote handshake endpoints which would be passes here as rpc errors over the wire)
	              // and maybe implement a short delay here so that there is no immediate fast infinite reconnect loop
	              // with error thrown, socket terminated, error thrown again etc.
	              this.connection.terminate();
	            }
	          }

	          // we show all other errors even if websocket has already closed
	          if (e.code != errorCodes.TIMEOUT) {
	            logger.write(
	              this.log,
	              `${this.endpoint} x Connector [ ${this.protocol} ] on:ready error: "${e.stack}" — (will not try to reconnect, fix the error and reload this gui)`
	            );

	            // TODO: what about errors coming from RPC ? Like remote exceptions
	            // see -- rpc/mole/errorCodes.js --
	            // not critical or even that important because it could only matter in development but once we don't expect any remote exceptions
	            // we don't need to reconnect automatically in such cases.. if error in on:ready we expect frontend to be reloaded anyway
	          }
	        });
	    } else {
	      let isDisconnect;

	      if (this.transportConnected) {
	        isDisconnect = true;
	      }

	      if (this.transportConnected == undefined) {
	        //const tag = this.tag ? ` (${this.tag})` : '';
	        logger.write(this.log, `${this.endpoint} Connector was not able to connect at first try`);
	      }

	      this.transportConnected = false;
	      this.ready = false;
	      this.sharedSecret = undefined; // could also stay but less confusion if we clear it

	      delete this.connectedAt;

	      if (isDisconnect) {
	        this.emit('disconnect');

	        // connected will be false or undefined
	        // establishAndMaintainConnection sets this to undefined after close connection
	        // so that again red cross doesn't appear immediately -- experimental!

	        // used unly when ws is closed
	        // useful on dmt-mobile when we switch back to app
	        // and websockets need to be quickly reconnected
	        // we want to avoid the red x
	        // on the other hand with legit disconnects we will have to tolerate a small delay
	        if (connected == undefined) {
	          this.delayedAdjustConnectionStatus();
	        }

	        this.connected.set(connected); // false or undefined
	      }
	    }
	  }

	  checkForDecommission() {
	    if (!this.autoDecommission) {
	      return;
	    }

	    // we want fresh 12 consecutive checks and only then we check for late pings and decommission connector
	    // this assures that in dmt-mobile when switching back to app connector has chance to reconnect to any endpoint
	    // that was either down or dmt-mobile was in background ... so checks for late pings are only relevant if app is in foreground
	    // for a few seconds

	    if (this.decommissionCheckRequestedAt && Date.now() - this.decommissionCheckRequestedAt > 3000) {
	      this.decommissionCheckCounter = 0;
	    }

	    this.decommissionCheckRequestedAt = Date.now();

	    this.decommissionCheckCounter += 1;

	    // 12 x tick = around 10s
	    if (this.decommissionCheckCounter > 12) {
	      // and now the real check DECOMMISSION_INACTIVITY (1min)
	      if (Date.now() - this.lastPongReceivedAt > DECOMMISSION_INACTIVITY) {
	        logger.write(this.log, `Decommissioning connector ${this.endpoint} (long inactive)`);

	        this.decommission();
	        this.emit('decommission');
	      }
	    }
	  }

	  decommission() {
	    this.decommissioned = true;
	  }

	  remoteObject(handle) {
	    return {
	      call: (methodName, params = []) => {
	        return this.rpcClient.remoteObject(handle).call(methodName, listify$1(params));
	      }
	    };
	  }

	  attachObject(handle, obj) {
	    new RPCTarget({ serversideChannel: this, serverMethods: obj, methodPrefix: handle });
	  }

	  clientPubkey() {
	    return this.clientPublicKeyHex;
	  }

	  remotePubkeyHex() {
	    return this._remotePubkeyHex;
	  }

	  remoteAddress() {
	    return this.endpoint;
	  }
	}

	const browser = typeof window !== 'undefined';

	function determineEndpoint({ endpoint, host, port }) {
	  // if endpoint is specified with "/something", it is rewritten as ws[s]://origin/something
	  if (browser && endpoint && endpoint.startsWith('/')) {
	    const wsProtocol = window.location.protocol.includes('s') ? 'wss' : 'ws';
	    endpoint = `${wsProtocol}://${window.location.host}${endpoint}`;
	  }

	  // if no endpoint is specified then use host and port if provided, otherwise use origin (in browser)
	  // in nodejs host and port have to be provided
	  if (!endpoint) {
	    if (browser) {
	      host = host || window.location.hostname;
	      const wsProtocol = window.location.protocol.includes('s') ? 'wss' : 'ws';

	      endpoint = `${wsProtocol}://${host}`;

	      // new addition
	      if (wsProtocol == 'wss') {
	        // if wss from browser we forget all about the port and use /ws which has to be upgraded to websocket connection by our reverse-proxy
	        // read this as well, very informative :: https://medium.com/intrinsic-blog/why-should-i-use-a-reverse-proxy-if-node-js-is-production-ready-5a079408b2ca
	        endpoint = `${wsProtocol}://${host}/ws`;
	      } else if (port) {
	        endpoint = `${endpoint}:${port}`;
	      } else if (window.location.port) {
	        endpoint = `${endpoint}:${window.location.port}`;
	      }
	    } else {
	      if (!port) {
	        throw new Error(`Connectome determineEndpoint: No websocket port provided for ${host}`);
	      }
	      // node.js ... if wss is needed, then full endpoint has to be passed in instead of host and port
	      // endpoint is then used "as is with no modifications" and this entire block of code is not needed
	      endpoint = `ws://${host || 'localhost'}:${port}`;
	    }
	  }

	  // if endpoint is provided directly and it didn't start with '/', then use this verbatim
	  return endpoint;
	}

	const browser$1 = typeof window !== 'undefined';

	const wsCONNECTING = 0;
	const wsOPEN$1 = 1;
	//const wsCLOSING = 2;
	//const wsCLOSED = 3;

	// connection tick
	const CONN_CHECK_INTERVAL = 1000; // was 1500 for a long time, then 1000 seemed to work ok, 800 was prehaps a bit too low

	// it was 5 for long time (and with higher CONN_CHECK_INTERVAL), 3 seems to be working great now (CONN_CHECK_INTERVAL=800), sweet balance!
	// 1,2 is too low... some raspberries when busy (switching songs / just starting dmt-proc) can easily miss out on sending pongs at the right moment
	const CONN_IDLE_TICKS = 3;

	// how long to wait for a new websocket to connect... after this we cancel it
	const WAIT_FOR_NEW_CONN_TICKS = 5; // 5000 ms ( = (5) * CONN_CHECK_INTERVAL )

	//todo: remove 'dummy' argument once legacyLib with old MCS is history
	function establishAndMaintainConnection(
	  {
	    endpoint,
	    host,
	    port,
	    protocol,
	    keypair,
	    remotePubkey,
	    rpcRequestTimeout,
	    autoDecommission,
	    log,
	    verbose,
	    tag,
	    dummy
	  },
	  { WebSocket }
	) {
	  endpoint = determineEndpoint({ endpoint, host, port });

	  const connector = new Connector({
	    endpoint,
	    protocol,
	    rpcRequestTimeout,
	    keypair,
	    verbose,
	    tag,
	    log,
	    autoDecommission,
	    dummy
	  });

	  const reconnect = () => {
	    tryReconnect({ connector, endpoint }, { WebSocket, reconnect, log, verbose });
	  };

	  connector.connection = {
	    terminate() {
	      this.websocket._removeAllCallbacks();
	      this.websocket.close();
	      //connector.connectStatus(undefined);
	      connector.connectStatus(false);
	      reconnect();
	      //for multiconnected store ↴ so that not everything tries to reconnect at once.. oh well didn't have much influence it seems, we can do everything at once! :)
	      //setTimeout(reconnect, MAX_RECONNECT_DELAY_AFTER_WS_CLOSE * Math.random());
	    },
	    endpoint,
	    checkTicker: 0
	  };

	  const callback = () => {
	    if (!connector.decommissioned) {
	      checkConnection({ connector, reconnect, log });
	      setTimeout(callback, CONN_CHECK_INTERVAL);
	    }
	  };

	  // setTimeout(() => tryReconnect({ connector, endpoint }, { WebSocket, log, verbose }), 10);
	  // setTimeout(callback, CONN_CHECK_INTERVAL);
	  setTimeout(callback, 10);

	  return connector;
	}

	function checkConnection({ connector, reconnect, log }) {
	  const conn = connector.connection;

	  //if (verbose && (connectionIdle(conn) || connector.decommissioned)) {
	  if (connectionIdle(conn) || connector.decommissioned) {
	    if (connector.decommissioned) {
	      // decommissioned
	      logger.yellow(
	        log,
	        `${connector.endpoint} Connection decommisioned, closing websocket ${conn.websocket.__id}, will not retry again `
	      );

	      decommission(connector);
	    } else {
	      // idle connection
	      connector.emit('inactive_connection');
	      logger.yellow(log, `${connector.endpoint} ✖ Terminated inactive connection`);
	    }

	    conn.terminate();
	    return;
	  }

	  const connected = socketConnected(conn);

	  if (connected) {
	    conn.websocket.send('ping');
	  } else {
	    if (connector.connected == undefined) {
	      logger.write(
	        log,
	        `${connector.endpoint} Setting connector status to FALSE because connector.connected is undefined`
	      );
	      connector.connectStatus(false);
	    }

	    reconnect();
	  }

	  conn.checkTicker += 1;
	}

	function tryReconnect({ connector, endpoint }, { WebSocket, reconnect, log, verbose }) {
	  const conn = connector.connection;

	  // if device on the other side went missing we will usually get websocket connecting timeouts
	  // so we retry WAIT_FOR_NEW_CONN_TICKS times (4800ms in total) and then discard the current websocket
	  // and we again try the same with a new WebSocket
	  // if device (IP) is online but websocket server is not responsing / program not running, then ...
	  // [ see explanation a few lines below] ...

	  connector.checkForDecommission();

	  if (connector.decommissioned) {
	    decommission(connector); // our side of things -- tear down any ws callbacks
	    return;
	  }

	  //logger.write(log, `${endpoint} CONN_TICK`);
	  //logger.write(log, `${endpoint} wsReadyState ${conn.currentlyTryingWS?.readyState}`);

	  if (conn.currentlyTryingWS && conn.currentlyTryingWS.readyState == wsCONNECTING) {
	    if (conn.currentlyTryingWS._waitForConnectCounter < WAIT_FOR_NEW_CONN_TICKS) {
	      //logger.write(log, `${endpoint} wsCONNECTING`);
	      conn.currentlyTryingWS._waitForConnectCounter += 1;
	      return;
	    }

	    if (verbose || browser$1) {
	      logger.write(log, `${endpoint} Reconnect timeout, creating new ws`);
	    }

	    conn.currentlyTryingWS._removeAllCallbacks();
	    conn.currentlyTryingWS.close();
	  } else if (verbose || browser$1) {
	    logger.write(log, `${endpoint} Created new websocket`);
	  }

	  // so in case when device is online but websocket server is not running we usually
	  // get immediate close event (websocket readyState becomes CLOSED) and we land here every
	  // CONN_CHECK_INTERVAL ms to create a new WebSocket and try again with a new WebSocket
	  // which will again fail immediately until it can successfuly connect (process is running)
	  // if in addition to process not running the devices goes offline, then we get long delays again
	  // (see above)... and we try with a new websocket every 4800ms again instead on every tick (800ms)

	  const ws = new WebSocket(endpoint);
	  ws.__id = Math.random();

	  conn.currentlyTryingWS = ws;
	  conn.currentlyTryingWS._waitForConnectCounter = 0;

	  if (browser$1) {
	    ws.binaryType = 'arraybuffer';
	  }

	  if (!browser$1) {
	    ws.on('error', () => {});
	  }

	  const openCallback = () => {
	    // should not come here because we remove open callbacks, but sometimes it might
	    if (connector.decommissioned) {
	      return;
	    }

	    if (verbose || browser$1) {
	      logger.write(log, `${endpoint} Websocket open`);
	    }

	    conn.currentlyTryingWS = null;
	    conn.checkTicker = 0;

	    addSocketListeners({ ws, connector, openCallback, reconnect }, { log, verbose });
	    conn.websocket = ws;

	    connector.connectStatus(true);
	  };

	  ws._removeAllCallbacks = () => {
	    ws.removeEventListener('open', openCallback);
	  };

	  if (browser$1) {
	    ws.addEventListener('open', openCallback);
	  } else {
	    ws.on('open', openCallback);
	  }
	}

	function addSocketListeners({ ws, connector, openCallback, reconnect }, { log, verbose }) {
	  const conn = connector.connection;

	  const errorCallback = event => {
	    //const msg = `websocket ${ws.__id} conn ${connector.endpoint} error`;
	    const msg = `${connector.endpoint} Websocket error`;
	    // whould not output normally since error events happen mostly on iphone.. didn't usually happen on desktop browsers or nodejs
	    // this is also not standardized, it outputs nothing useful and we always get close event immediately after this error event
	    console.log(msg);
	    console.log(event);
	    // this also wasn't useful / didn't work everywhere: ws.onerror = error => {}
	  };

	  const closeCallback = () => {
	    logger.write(log, `${connector.endpoint} ✖ Connection closed`);

	    if (connector.decommissioned) {
	      connector.connectStatus(false);
	      return;
	    }

	    // when switching back to dmt-mobile it will usually quickly close the old connection and reconnect
	    // we want some buffer delay (see connector::ADJUST_UNDEFINED_CONNECTION_STATUS_DELAY) as we had on first connection
	    // where we don't show red x for some short time so that ws has a chance to connect first ... looks better in the UI
	    // flip side is that there is such small delay between when we stop some process and when red x appears... but it's quite ok!
	    // we do however disable all commands immediately ... so: show red X when connect status is FALSE excusively and disable all gui actions when it's NOT TRUE (false or undefined)
	    connector.connectStatus(undefined);
	    reconnect();
	    //setTimeout(reconnect, MAX_RECONNECT_DELAY_AFTER_WS_CLOSE * Math.random()); // turns out we don't really need to do these delays, works fine without
	  };

	  const messageCallback = _msg => {
	    if (connector.decommissioned) {
	      return;
	    }

	    conn.checkTicker = 0;

	    const msg = browser$1 ? _msg.data : _msg;

	    if (msg == 'pong') {
	      connector.emit('pong');
	      return;
	    }

	    let jsonData;

	    try {
	      jsonData = JSON.parse(msg);
	    } catch (e) {}

	    if (jsonData) {
	      connector.wireReceive({ jsonData, rawMessage: msg });
	    } else {
	      const encryptedData = browser$1 ? new Uint8Array(msg) : msg;
	      connector.wireReceive({ encryptedData });
	    }
	  };

	  ws._removeAllCallbacks = () => {
	    ws.removeEventListener('error', errorCallback);
	    ws.removeEventListener('close', closeCallback);
	    ws.removeEventListener('message', messageCallback);

	    ws.removeEventListener('open', openCallback);
	  };

	  if (browser$1) {
	    ws.addEventListener('error', errorCallback);
	    ws.addEventListener('close', closeCallback);
	    ws.addEventListener('message', messageCallback);
	  } else {
	    ws.on('error', errorCallback);
	    ws.on('close', closeCallback);
	    ws.on('message', messageCallback);
	  }
	}

	function decommission(connector) {
	  const conn = connector.connection;

	  if (conn.currentlyTryingWS) {
	    conn.currentlyTryingWS._removeAllCallbacks();
	    conn.currentlyTryingWS.close();
	    conn.currentlyTryingWS = null;
	  }

	  if (conn.ws) {
	    conn.ws._removeAllCallbacks();
	    conn.ws.close();
	    conn.ws = null;
	  }

	  connector.connectStatus(false);
	}

	function socketConnected(conn) {
	  return conn.websocket && conn.websocket.readyState == wsOPEN$1;
	}

	function connectionIdle(conn) {
	  return socketConnected(conn) && conn.checkTicker > CONN_IDLE_TICKS;
	}

	function establishAndMaintainConnection$1(opts) {
	  opts.log = opts.log || console.log;
	  return establishAndMaintainConnection(opts, { WebSocket });
	}

	// DMT.JS
	// PERIODIC INTERVAL ON FRONTEND

	function interval({ store, endpoint }) {
	  if (store.dmtInterval) {
	    return;
	  }

	  store.dmtInterval = 500;

	  //console.log('SETTING UP A INTERVAL');

	  //store.compute('guiNotifications', ['notifications', 'frontTicker'], (notifications, frontTicker) => computeGuiNotifications(notifications));

	  const callback = () => {
	    intervalHandler(store);
	    setTimeout(callback, store.dmtInterval);
	  };
	  //setTimeout(callback, store.dmtInterval);
	  callback(); // CHANGED RECENTLY SO THAT localBrowserTime is present immediately! -- useful for serverMode... investigate if ticker causes some other issues because it starts immediately?
	}

	// HELPER METHODS:

	let frontTicker = 0;

	function intervalHandler(store) {
	  const d = new Date();
	  const time = `${d.getHours()}:${('0' + d.getMinutes()).slice(-2)}`;

	  store.tick({ frontTicker, localBrowserTime: time });

	  frontTicker += 1;
	}

	//import { diffApply, jsonPatchPathConverter } from '../../jsonDiffApplyTweaked.js';

	// function constructAction({ action, namespace, payload }) {
	//   const data = {
	//     action,
	//     namespace,
	//     payload
	//   };

	//   return JSON.stringify(data);
	// }

	// intermmediate class to hold the underlying connection state and to illustrate nicely how store connections work

	class StoreConnection {
	  constructor(componentStore, { ip, port } = {}) {
	    // port is ignored!

	    // let ipWithPort = ip;
	    // if (port) {
	    //   ipWithPort = `${ip}:${port}`;
	    // }

	    //const localDevice = `${window.location.hostname}`; // FIX (??) magic number
	    // const endpoint = `ws://${ip ? `${ipWithPort}` : localDevice}`;
	    //const endpoint = `ws://${ip ? `${ipWithPort}` : window.location.host}`; // /ws/gui

	    this.address = ip || window.location.hostname;
	    this.port = 7780;
	    // const endpoint = `ws://${}:7780`;

	    // this.endpoint = endpoint;

	    const protocol = 'dmt/gui';

	    this.store = componentStore;

	    const clientPrivateKey = this.store.multiConnectedStoreRef.privateKey;
	    const clientPublicKey = this.store.multiConnectedStoreRef.publicKey;

	    const connector = establishAndMaintainConnection$1({ host: this.address, port: this.port, protocol, clientPrivateKey, clientPublicKey, dummy: true });

	    this.connector = connector;

	    connector.on('frontend_action', ({ action, payload }) => {
	      console.log(`frontend_action ${action} - ${payload}`);
	      // ConnectedStore without ip is our local devices store
	      if (!this.store.ip) {
	        // we only process actions from local backend (= "this device") although by design we also receive all the others since we're connected to other devices' gui ws endpoint as "one of the GUIs"

	        // action request from backend! for example: { store: frontend, action: reload }
	        if (action) {
	          this.store.multiConnectedStoreRef.fire('gui_action', { action, payload });
	          //obj.fireMulti('gui_action', { action: data.action, payload: data.payload });
	        }
	      }
	    });

	    //connector.attachObject('Frontend', { reverseAction: this.reverseAction.bind(this) });

	    connector.on('ready', () => {
	      this.connectStatus(true);
	    });

	    connector.on('disconnect', () => {
	      this.connectStatus(false);
	    });

	    // connector.on('wire_receive', ({ jsonData }) => {
	    //   this.wireReceive({ jsonData });
	    // });

	    // 💡 Special incoming JSON message: { state: ... } ... parsed as part of 'Connectome State Syncing Protocol'
	    connector.on('receive_state', state => {
	      this.dmtProgramState = state;

	      // const { environment } = this.dmtProgramState;
	      // if(environment && environment.expireAt < Date.now()) {
	      //   delete this.dmtProgramState.environment;
	      // }
	      this.store.set(this.dmtProgramState); // set state on the component this connection is part of
	    });

	    // 💡 Special incoming JSON message: { diff: ... } ... parsed as part of 'Connectome State Syncing Protocol'
	    connector.on('receive_diff', diff => {
	      if (this.dmtProgramState) {
	        applyPatch(this.dmtProgramState, diff);
	      }

	      // ⚠️ ugly hack! !!!! grrrr:::!!
	      // later it has to work without this... as of now this.store.set() doesn't actually clear data
	      // later we still need this check in frontend so that temperature is cleared if dmt-proc is down on that device
	      // const { environment } = this.dmtProgramState;
	      // if (!environment || (environment && environment.expireAt < Date.now())) {
	      //   this.dmtProgramState.environment = { temperature: null };
	      // }

	      this.store.set(this.dmtProgramState);
	    });

	    // const designateChannel = designation => {
	    //   this.connector
	    //     .remoteCall('designate', designation)
	    //     .then(() => {
	    //       //console.log(`Designate channel result: ${result}`);
	    //     })
	    //     .catch(e => {
	    //       //console.log('ERROR');
	    //       console.log(e);
	    //     });
	    // };

	    // periodic handler on frontend - every 0.5s
	    if (!ip) {
	      interval({ store: this.store });
	    }
	  }

	  decommission() {
	    this.connector.decommission();
	    //this.decommissioned = true;
	  }

	  remoteObject(handle) {
	    return this.connector.remoteObject(handle);
	  }

	  // called from component store

	  signal(name, data) {
	    this.connector.signal(name, data);
	  }

	  // pauseReconnect() {
	  //   const alreadyPaused = this.connector.reconnectPaused;
	  //   this.connector.reconnectPaused = true; // connection will notice and destroy itself

	  //   return !alreadyPaused;
	  // }

	  // resumeReconnect() {
	  //   console.log(`Resume reconnect ${this.address} ...`);
	  //   this.connector.reconnectPaused = false; // connection will notice and destroy itself
	  //   connect({ obj: this.connector, address: this.address, port: this.port, resumeNow: true }); // this is just to trigger reconnect immeditely instead of waiting for next 1s interval which would notice reconnectPaused=false on this object
	  // }

	  // ----------------------------------------------------
	  // these are only called from connect functions (could also be implemented with events)
	  //

	  // connection status (used to show big red X for example)

	  connectStatus(connected) {
	    if (!connected) {
	      this.dmtProgramState = undefined;
	    }

	    this.store.set({ connected });
	  }

	  // isConnected() {
	  //   return this.store.get().connected;
	  // }

	  // when something is received over our (websocket) connection
	  // wireReceive({ jsonData }) {
	  //   // maybe not needed because websocket should be closed anyway... test if it work without this!
	  //   if (this.connector.decommissioned) {
	  //     return;
	  //   }
	  //   //this.decommissioned = true;
	  //   //console.log(`WIRE RECEIVE: ${JSON.stringify(jsonData, null, 2)}`);

	  //   // have to check because wireReceive can also be called with { binaryData } !
	  //   if (!jsonData) {
	  //     return;
	  //   }

	  //   // TODO:
	  //   // we could trim playlist or any other such data and keep only the part that is needed to show on the GUI
	  //   // this would then finally solve all the slowness with long playlists ...
	  //   // no we already avoid this but still on every show or store switch the entire playlist has to be iterated and put into gui elements
	  //   // DO ONLY THE VISIBLE PART OF THE PLAYLIST !!!

	  //   if (jsonData.state) {
	  //     // when full new state comes over the wire
	  //     this.dmtProgramState = jsonData.state;
	  //     this.store.set(this.dmtProgramState); // set state on the component this connection is part of
	  //   } else if (jsonData.diff) {
	  //     // sometimes a diff manages to sneak in over the connection before
	  //     // we send the initial state... we just ignore these diffs - they are not relevant, the correct ones are
	  //     // those that start coming after we have received the entire initial state

	  //     // OPEN ISSUE: this can get out of sync ....
	  //     // if computer is sleeping and on reconnect to store if enough things changed we get a problem!!!

	  //     //       HOW IT HAPPENED:

	  //     // Lab was selected on DPANEL and ECLIPSE

	  //     // Eclipse was sleeping, when waking it up in this instant I saw red error on dpanel (for Lab)
	  //     // ------

	  //     // lab pid 21202 5/11/2020, 10:56:37 PM 2572441ms (+8033ms) ∞ Gui error in browser: TypeError: Cannot read property 'lastUpdateAt' of undefined
	  //     //     at ../../../../.common-deps-frontend/node_modules/fast-json-patch/module/core.mjs:22:26
	  //     //     at ../../../../.common-deps-frontend/node_modules/fast-json-patch/module/core.mjs:231:59
	  //     //     at ../../../../.common-deps-frontend/node_modules/fast-json-patch/module/core.mjs:270:21
	  //     //     at ../../../lib/stores/connection/storeConnection.js:159:8

	  //     //     if (this.dmtProgramState) {
	  //     //       line 159 ->  applyPatch(this.dmtProgramState, jsonData.diff);
	  //     //     }

	  //     //     at ../../../lib/stores/connection/storeConnection.js:60:13
	  //     //     at ../../../../connectome/lib/utils/emitter/runnableLink.js:11:9
	  //     //     at ../../../../connectome/lib/utils/emitter/runnableLink.js:12:27
	  //     //     at ../../../../connectome/lib/utils/emitter/index.js:49:20
	  //     //     at ../../../../connectome/lib/connector/receive.js:93:20
	  //     //     at receive(../../../../connectome/lib/connector/connector.js:43:4)
	  //     //
	  //     //
	  //     // WHAT PROBABLY HAPPENED:
	  //     //
	  //     // When disconnected, this.dmtProgramState was not cleared
	  //     // and upon reconnecting a diff sometimes came before the new base state
	  //     // and this caused issues .. solution: clear this.dmtProgramState when connection drops
	  //     // test if it ever happens again ...

	  //     if (this.dmtProgramState) {
	  //       applyPatch(this.dmtProgramState, jsonData.diff);
	  //     }
	  //     //diffApply(this.dmtProgramState, jsonData.diff, jsonPatchPathConverter);
	  //     // const duration = Date.now() - start;
	  //     // console.log(`Diff apply time: ${duration}`);

	  //     this.store.set(this.dmtProgramState);
	  //     // } else if (jsonData.namespace) {
	  //     //   console.log('REVERSE ACTION');
	  //     //   console.log(jsonData);
	  //     //   this.reverseAction(jsonData); // gui::reload etc...
	  //   } else {
	  //     console.log(`Unknown wire message format: ${JSON.stringify(jsonData, null, 2)}`);
	  //   }
	  // }

	  // implement with remoteObject as well!!! .... should work nicely with mole...
	  // so gui also has remote object and we can call it from server....
	  // when we receive action from backend to frontend
	  // reverseAction({ action, payload }) {

	  // }
	}

	//import SvelteDevStore from 'svelte-dev-store';
	//const TheStore = "development" == 'production' ? Store : SvelteDevStore;

	//class DmtStore extends TheStore {}
	//, production: "development" == 'production'

	class ConnectedStore extends Store {
	  constructor(data = {}, { ip = null, port = null, multiConnectedStoreRef = null } = {}) {
	    super(data);
	    //this.loading = true;
	    this.ip = ip;
	    this.port = port;
	    this.multiConnectedStoreRef = multiConnectedStoreRef;

	    // store connection does two things:
	    // 1. automatically populates the component state as it is sent over the wire (will call this.set(...) on this instance on each data receive)
	    // 2. sends actions down the wire (this.storeConnection.send(...))
	    this.storeConnection = new StoreConnection(this, { ip, port });
	  }

	  decommission() {
	    console.log(`Decommissioning connected store ${this.ip} ...`);
	    this.storeConnection.decommission();
	  }

	  signal(name, data) {
	    this.storeConnection.signal(name, data);
	  }

	  remoteObject(handle) {
	    return this.storeConnection.remoteObject(handle);
	  }

	  entangle(component) {
	    // do nothing, we only implement this in MultiConnectedStore
	  }

	  // pauseReconnect() {
	  //   return this.storeConnection.pauseReconnect();
	  // }

	  // resumeReconnect() {
	  //   this.storeConnection.resumeReconnect();
	  // }

	  tick({ frontTicker, localBrowserTime }) {
	    if (!this.multiConnectedStoreRef) {
	      this.set({ frontTicker, localBrowserTime });
	    } else {
	      this.multiConnectedStoreRef.set({ frontTicker, localBrowserTime });
	    }
	  }
	}

	function aspectViewDef({ componentStatePatch, state, globalStore }) {
	  componentStatePatch.wallpapers = [];

	  let viewDef = {};

	  if (state.gui && state.gui.views) {
	    const { views } = state.gui;
	    viewDef = views[globalStore.get().view] || {};

	    // prepare wallpaper array (used only for prefetching all the wallpapers as soon as possible)
	    const wallpapers = [];

	    for (const view of Object.values(views)) {
	      if (view.wallpaper) {
	        wallpapers.push(view.wallpaper);
	      }
	    }

	    componentStatePatch.wallpapers = wallpapers;
	  }

	  if (viewDef) {
	    // we do it through global store that saves previous value of wallpaper and calls util.setWallpaper only if new value is different
	    // this is just in case browser would not be able to optimize constant setting of the same wallpaper in css
	    globalStore.setWallpaper(viewDef.wallpaper);
	  }

	  componentStatePatch.viewDef = viewDef;
	}

	function aspectBasics({ component, componentStatePatch, state, frontendLog, meta }) {
	  componentStatePatch.frontendLog = frontendLog;

	  const { thisDeviceName, selectedDeviceName, activeStoreKey } = meta;

	  if (!component.get().thisDeviceName) {
	    componentStatePatch.thisDeviceName = thisDeviceName;
	  }

	  componentStatePatch.selectedDeviceName = selectedDeviceName; // needed for now in NearbyHandyLinks.html
	  componentStatePatch.selectedDeviceKey = activeStoreKey;

	  // this is changed as needed in aspectGui
	  componentStatePatch.homebase = selectedDeviceName == thisDeviceName;
	}

	function aspectNearbyDevices({ componentStatePatch, nearbyDevices }) {
	  componentStatePatch.nearbyDevices = nearbyDevices;
	}

	function aspectDevice({ componentStatePatch, state, tunneledState }) {
	  if (state.device) {
	    componentStatePatch.timeDate = state.time;
	    componentStatePatch.holiday = state.time.holiday;
	    componentStatePatch.environment = state.environment;
	    componentStatePatch.isDevMachine = state.device.devMachine;
	    componentStatePatch.isDevUser = state.device.devUser;

	    //componentStatePatch.getParams = globalStore.get().getParams; // also listed in interComponent....

	    // if we're actually on the touch screen on Raspberry Pi
	    componentStatePatch.atRPi = state.device.isRPi && window.location.hostname == 'localhost';

	    if (state.device.demoDevice && state.device.demoDevice.date) {
	      const demoDate = new Date(state.device.demoDevice.date);
	      componentStatePatch._demoTime = util.getDisplayTime(demoDate);
	    }

	    componentStatePatch.loaded = true;

	    // if (!componentStatePatch.loaded) {
	    //   componentStatePatch.loaded = true;
	    //   // some properties in state come a bit later (for example $player)
	    //   // when we only check loaded && $player in state, we sometimes get false but in fact $player gets assigned just a tiny bit later
	    //   // and we have an ugly "Player not configured" text flash on the screen
	    //   setTimeout(() => {
	    //     componentStatePatch.fullyLoaded = true;
	    //   }, 500);
	    // }
	  }

	  if (tunneledState.device) {
	    componentStatePatch.isRPi = tunneledState.device.isRPi;
	  }
	}

	function aspectGui({ component, componentStatePatch, state, meta, globalStore }) {
	  const { selectedDeviceName, thisDeviceName } = meta;

	  // not sure why this doesn't work
	  // todo: try to optimize again so that this is done only once and not everytime cponentBridge is invoked
	  //!component.serviceDefinitionsHaveBeenRead &&
	  if (state.services && state.services.gui) {
	    //component.serviceDefinitionsHaveBeenRead = true;

	    const defGui = state.services.gui;

	    if (defGui.idleView) {
	      globalStore.set({ idleView: defGui.idleView });
	    }

	    // override and disable display of ip on all views (except if explicitely set to true on some specific view)
	    // note: we are only talking about showing of ip address outside of home screen... on home it is always shown!
	    if (defGui.showIp == 'false' && componentStatePatch.viewDef.showIp != 'true') {
	      componentStatePatch.viewDef.showIp = 'false';
	    }

	    const defGuiNearby = defGui.nearby || {};

	    if (defGuiNearby.homebase) {
	      const { homebase } = defGuiNearby;
	      componentStatePatch.homebaseName = homebase;
	      componentStatePatch.homebase =
	        (defGuiNearby.homebase && selectedDeviceName == homebase) || (!defGuiNearby.homebase && selectedDeviceName == thisDeviceName);
	    }

	    if (defGuiNearby.disableDeviceSelector == 'true') {
	      componentStatePatch.disableDeviceSelector = true;
	    }
	  }

	  // will add global property to app div to prevent all pointer events:
	  // pointer-events: none;
	  componentStatePatch.preventPointerEvents = globalStore.videoOverlay();
	}

	function addPropertiesToGUIComponent({ component, thisDeviceState, meta, tunneledState, globalStore, nearbyDevices, frontendLog, changed }) {
	  // TODO::: optimize and consider "changed" information

	  const state = thisDeviceState;

	  const componentStatePatch = {};

	  aspectBasics({ component, componentStatePatch, state, frontendLog, meta });
	  aspectDevice({ componentStatePatch, state, tunneledState });
	  aspectViewDef({ componentStatePatch, state, globalStore });
	  aspectGui({ componentStatePatch, component, state, meta, globalStore });
	  aspectNearbyDevices({ componentStatePatch, nearbyDevices });

	  // console.log("PATCH:");
	  // console.log(componentStatePatch);

	  component.set(componentStatePatch);
	}

	var componentBridge = { addPropertiesToGUIComponent };

	function noop$2() {}

	class RunnableLink$1 {
	  constructor(prev, next, fn) {
	    this.prev = prev;
	    this.next = next;
	    this.fn = fn || noop$2;
	  }

	  run(data) {
	    this.fn(data);
	    this.next && this.next.run(data);
	  }
	}

	// A relatively generic LinkedList impl
	class LinkedList$1 {
	  constructor(linkConstructor) {
	    this.head = new RunnableLink$1();
	    this.tail = new RunnableLink$1(this.head);
	    this.head.next = this.tail;
	    this.linkConstructor = linkConstructor;
	    this.reg = {};
	  }

	  insert(data) {
	    const link = new RunnableLink$1(this.tail.prev, this.tail, data);
	    link.next.prev = link;
	    link.prev.next = link;
	    return link;
	  }

	  remove(link) {
	    link.prev.next = link.next;
	    link.next.prev = link.prev;
	  }
	}

	let id$1 = 0;
	const splitter = /[\s,]+/g;

	// A link in the linked list which allows
	// for efficient execution of the callbacks

	class Eev$1 {
	  constructor() {
	    this.events = {};
	  }

	  on(names, fn) {
	    const me = this;

	    names.split(splitter).forEach(name => {
	      const list = me.events[name] || (me.events[name] = new LinkedList$1());
	      const eev = fn._eev || (fn._eev = ++id$1);

	      list.reg[eev] || (list.reg[eev] = list.insert(fn));
	    });
	  }

	  off(names, fn) {
	    const me = this;
	    fn &&
	      names.split(splitter).forEach(function(name) {
	        const list = me.events[name];

	        if (!list) {
	          return;
	        }

	        const link = list.reg[fn._eev];

	        list.reg[fn._eev] = undefined;

	        list && link && list.remove(link);
	      });
	  }

	  emit(name, data) {
	    const evt = this.events[name];
	    evt && evt.head.run(data);
	  }
	}

	var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function commonjsRequire$1 () {
		throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
	}

	function createCommonjsModule$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var naclFast$1 = createCommonjsModule$1(function (module) {
	(function(nacl) {

	// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
	// Public domain.
	//
	// Implementation derived from TweetNaCl version 20140427.
	// See for details: http://tweetnacl.cr.yp.to/

	var gf = function(init) {
	  var i, r = new Float64Array(16);
	  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
	  return r;
	};

	//  Pluggable, initialized in high-level API below.
	var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

	var _0 = new Uint8Array(16);
	var _9 = new Uint8Array(32); _9[0] = 9;

	var gf0 = gf(),
	    gf1 = gf([1]),
	    _121665 = gf([0xdb41, 1]),
	    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
	    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
	    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
	    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
	    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

	function ts64(x, i, h, l) {
	  x[i]   = (h >> 24) & 0xff;
	  x[i+1] = (h >> 16) & 0xff;
	  x[i+2] = (h >>  8) & 0xff;
	  x[i+3] = h & 0xff;
	  x[i+4] = (l >> 24)  & 0xff;
	  x[i+5] = (l >> 16)  & 0xff;
	  x[i+6] = (l >>  8)  & 0xff;
	  x[i+7] = l & 0xff;
	}

	function vn(x, xi, y, yi, n) {
	  var i,d = 0;
	  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
	  return (1 & ((d - 1) >>> 8)) - 1;
	}

	function crypto_verify_16(x, xi, y, yi) {
	  return vn(x,xi,y,yi,16);
	}

	function crypto_verify_32(x, xi, y, yi) {
	  return vn(x,xi,y,yi,32);
	}

	function core_salsa20(o, p, k, c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;

	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);

	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }
	   x0 =  x0 +  j0 | 0;
	   x1 =  x1 +  j1 | 0;
	   x2 =  x2 +  j2 | 0;
	   x3 =  x3 +  j3 | 0;
	   x4 =  x4 +  j4 | 0;
	   x5 =  x5 +  j5 | 0;
	   x6 =  x6 +  j6 | 0;
	   x7 =  x7 +  j7 | 0;
	   x8 =  x8 +  j8 | 0;
	   x9 =  x9 +  j9 | 0;
	  x10 = x10 + j10 | 0;
	  x11 = x11 + j11 | 0;
	  x12 = x12 + j12 | 0;
	  x13 = x13 + j13 | 0;
	  x14 = x14 + j14 | 0;
	  x15 = x15 + j15 | 0;

	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;

	  o[ 4] = x1 >>>  0 & 0xff;
	  o[ 5] = x1 >>>  8 & 0xff;
	  o[ 6] = x1 >>> 16 & 0xff;
	  o[ 7] = x1 >>> 24 & 0xff;

	  o[ 8] = x2 >>>  0 & 0xff;
	  o[ 9] = x2 >>>  8 & 0xff;
	  o[10] = x2 >>> 16 & 0xff;
	  o[11] = x2 >>> 24 & 0xff;

	  o[12] = x3 >>>  0 & 0xff;
	  o[13] = x3 >>>  8 & 0xff;
	  o[14] = x3 >>> 16 & 0xff;
	  o[15] = x3 >>> 24 & 0xff;

	  o[16] = x4 >>>  0 & 0xff;
	  o[17] = x4 >>>  8 & 0xff;
	  o[18] = x4 >>> 16 & 0xff;
	  o[19] = x4 >>> 24 & 0xff;

	  o[20] = x5 >>>  0 & 0xff;
	  o[21] = x5 >>>  8 & 0xff;
	  o[22] = x5 >>> 16 & 0xff;
	  o[23] = x5 >>> 24 & 0xff;

	  o[24] = x6 >>>  0 & 0xff;
	  o[25] = x6 >>>  8 & 0xff;
	  o[26] = x6 >>> 16 & 0xff;
	  o[27] = x6 >>> 24 & 0xff;

	  o[28] = x7 >>>  0 & 0xff;
	  o[29] = x7 >>>  8 & 0xff;
	  o[30] = x7 >>> 16 & 0xff;
	  o[31] = x7 >>> 24 & 0xff;

	  o[32] = x8 >>>  0 & 0xff;
	  o[33] = x8 >>>  8 & 0xff;
	  o[34] = x8 >>> 16 & 0xff;
	  o[35] = x8 >>> 24 & 0xff;

	  o[36] = x9 >>>  0 & 0xff;
	  o[37] = x9 >>>  8 & 0xff;
	  o[38] = x9 >>> 16 & 0xff;
	  o[39] = x9 >>> 24 & 0xff;

	  o[40] = x10 >>>  0 & 0xff;
	  o[41] = x10 >>>  8 & 0xff;
	  o[42] = x10 >>> 16 & 0xff;
	  o[43] = x10 >>> 24 & 0xff;

	  o[44] = x11 >>>  0 & 0xff;
	  o[45] = x11 >>>  8 & 0xff;
	  o[46] = x11 >>> 16 & 0xff;
	  o[47] = x11 >>> 24 & 0xff;

	  o[48] = x12 >>>  0 & 0xff;
	  o[49] = x12 >>>  8 & 0xff;
	  o[50] = x12 >>> 16 & 0xff;
	  o[51] = x12 >>> 24 & 0xff;

	  o[52] = x13 >>>  0 & 0xff;
	  o[53] = x13 >>>  8 & 0xff;
	  o[54] = x13 >>> 16 & 0xff;
	  o[55] = x13 >>> 24 & 0xff;

	  o[56] = x14 >>>  0 & 0xff;
	  o[57] = x14 >>>  8 & 0xff;
	  o[58] = x14 >>> 16 & 0xff;
	  o[59] = x14 >>> 24 & 0xff;

	  o[60] = x15 >>>  0 & 0xff;
	  o[61] = x15 >>>  8 & 0xff;
	  o[62] = x15 >>> 16 & 0xff;
	  o[63] = x15 >>> 24 & 0xff;
	}

	function core_hsalsa20(o,p,k,c) {
	  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
	      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
	      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
	      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
	      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
	      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
	      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
	      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
	      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
	      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
	      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
	      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
	      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
	      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
	      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
	      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

	  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
	      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
	      x15 = j15, u;

	  for (var i = 0; i < 20; i += 2) {
	    u = x0 + x12 | 0;
	    x4 ^= u<<7 | u>>>(32-7);
	    u = x4 + x0 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x4 | 0;
	    x12 ^= u<<13 | u>>>(32-13);
	    u = x12 + x8 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x1 | 0;
	    x9 ^= u<<7 | u>>>(32-7);
	    u = x9 + x5 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x9 | 0;
	    x1 ^= u<<13 | u>>>(32-13);
	    u = x1 + x13 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x6 | 0;
	    x14 ^= u<<7 | u>>>(32-7);
	    u = x14 + x10 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x14 | 0;
	    x6 ^= u<<13 | u>>>(32-13);
	    u = x6 + x2 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x11 | 0;
	    x3 ^= u<<7 | u>>>(32-7);
	    u = x3 + x15 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x3 | 0;
	    x11 ^= u<<13 | u>>>(32-13);
	    u = x11 + x7 | 0;
	    x15 ^= u<<18 | u>>>(32-18);

	    u = x0 + x3 | 0;
	    x1 ^= u<<7 | u>>>(32-7);
	    u = x1 + x0 | 0;
	    x2 ^= u<<9 | u>>>(32-9);
	    u = x2 + x1 | 0;
	    x3 ^= u<<13 | u>>>(32-13);
	    u = x3 + x2 | 0;
	    x0 ^= u<<18 | u>>>(32-18);

	    u = x5 + x4 | 0;
	    x6 ^= u<<7 | u>>>(32-7);
	    u = x6 + x5 | 0;
	    x7 ^= u<<9 | u>>>(32-9);
	    u = x7 + x6 | 0;
	    x4 ^= u<<13 | u>>>(32-13);
	    u = x4 + x7 | 0;
	    x5 ^= u<<18 | u>>>(32-18);

	    u = x10 + x9 | 0;
	    x11 ^= u<<7 | u>>>(32-7);
	    u = x11 + x10 | 0;
	    x8 ^= u<<9 | u>>>(32-9);
	    u = x8 + x11 | 0;
	    x9 ^= u<<13 | u>>>(32-13);
	    u = x9 + x8 | 0;
	    x10 ^= u<<18 | u>>>(32-18);

	    u = x15 + x14 | 0;
	    x12 ^= u<<7 | u>>>(32-7);
	    u = x12 + x15 | 0;
	    x13 ^= u<<9 | u>>>(32-9);
	    u = x13 + x12 | 0;
	    x14 ^= u<<13 | u>>>(32-13);
	    u = x14 + x13 | 0;
	    x15 ^= u<<18 | u>>>(32-18);
	  }

	  o[ 0] = x0 >>>  0 & 0xff;
	  o[ 1] = x0 >>>  8 & 0xff;
	  o[ 2] = x0 >>> 16 & 0xff;
	  o[ 3] = x0 >>> 24 & 0xff;

	  o[ 4] = x5 >>>  0 & 0xff;
	  o[ 5] = x5 >>>  8 & 0xff;
	  o[ 6] = x5 >>> 16 & 0xff;
	  o[ 7] = x5 >>> 24 & 0xff;

	  o[ 8] = x10 >>>  0 & 0xff;
	  o[ 9] = x10 >>>  8 & 0xff;
	  o[10] = x10 >>> 16 & 0xff;
	  o[11] = x10 >>> 24 & 0xff;

	  o[12] = x15 >>>  0 & 0xff;
	  o[13] = x15 >>>  8 & 0xff;
	  o[14] = x15 >>> 16 & 0xff;
	  o[15] = x15 >>> 24 & 0xff;

	  o[16] = x6 >>>  0 & 0xff;
	  o[17] = x6 >>>  8 & 0xff;
	  o[18] = x6 >>> 16 & 0xff;
	  o[19] = x6 >>> 24 & 0xff;

	  o[20] = x7 >>>  0 & 0xff;
	  o[21] = x7 >>>  8 & 0xff;
	  o[22] = x7 >>> 16 & 0xff;
	  o[23] = x7 >>> 24 & 0xff;

	  o[24] = x8 >>>  0 & 0xff;
	  o[25] = x8 >>>  8 & 0xff;
	  o[26] = x8 >>> 16 & 0xff;
	  o[27] = x8 >>> 24 & 0xff;

	  o[28] = x9 >>>  0 & 0xff;
	  o[29] = x9 >>>  8 & 0xff;
	  o[30] = x9 >>> 16 & 0xff;
	  o[31] = x9 >>> 24 & 0xff;
	}

	function crypto_core_salsa20(out,inp,k,c) {
	  core_salsa20(out,inp,k,c);
	}

	function crypto_core_hsalsa20(out,inp,k,c) {
	  core_hsalsa20(out,inp,k,c);
	}

	var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
	            // "expand 32-byte k"

	function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	    mpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
	  }
	  return 0;
	}

	function crypto_stream_salsa20(c,cpos,b,n,k) {
	  var z = new Uint8Array(16), x = new Uint8Array(64);
	  var u, i;
	  for (i = 0; i < 16; i++) z[i] = 0;
	  for (i = 0; i < 8; i++) z[i] = n[i];
	  while (b >= 64) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
	    u = 1;
	    for (i = 8; i < 16; i++) {
	      u = u + (z[i] & 0xff) | 0;
	      z[i] = u & 0xff;
	      u >>>= 8;
	    }
	    b -= 64;
	    cpos += 64;
	  }
	  if (b > 0) {
	    crypto_core_salsa20(x,z,k,sigma);
	    for (i = 0; i < b; i++) c[cpos+i] = x[i];
	  }
	  return 0;
	}

	function crypto_stream(c,cpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20(c,cpos,d,sn,s);
	}

	function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
	  var s = new Uint8Array(32);
	  crypto_core_hsalsa20(s,n,k,sigma);
	  var sn = new Uint8Array(8);
	  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
	  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
	}

	/*
	* Port of Andrew Moon's Poly1305-donna-16. Public domain.
	* https://github.com/floodyberry/poly1305-donna
	*/

	var poly1305 = function(key) {
	  this.buffer = new Uint8Array(16);
	  this.r = new Uint16Array(10);
	  this.h = new Uint16Array(10);
	  this.pad = new Uint16Array(8);
	  this.leftover = 0;
	  this.fin = 0;

	  var t0, t1, t2, t3, t4, t5, t6, t7;

	  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
	  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
	  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
	  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
	  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
	  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	  this.r[9] = ((t7 >>>  5)) & 0x007f;

	  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
	  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
	  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
	  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
	  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
	  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
	  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
	  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
	};

	poly1305.prototype.blocks = function(m, mpos, bytes) {
	  var hibit = this.fin ? 0 : (1 << 11);
	  var t0, t1, t2, t3, t4, t5, t6, t7, c;
	  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

	  var h0 = this.h[0],
	      h1 = this.h[1],
	      h2 = this.h[2],
	      h3 = this.h[3],
	      h4 = this.h[4],
	      h5 = this.h[5],
	      h6 = this.h[6],
	      h7 = this.h[7],
	      h8 = this.h[8],
	      h9 = this.h[9];

	  var r0 = this.r[0],
	      r1 = this.r[1],
	      r2 = this.r[2],
	      r3 = this.r[3],
	      r4 = this.r[4],
	      r5 = this.r[5],
	      r6 = this.r[6],
	      r7 = this.r[7],
	      r8 = this.r[8],
	      r9 = this.r[9];

	  while (bytes >= 16) {
	    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
	    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
	    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
	    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
	    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
	    h5 += ((t4 >>>  1)) & 0x1fff;
	    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
	    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
	    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
	    h9 += ((t7 >>> 5)) | hibit;

	    c = 0;

	    d0 = c;
	    d0 += h0 * r0;
	    d0 += h1 * (5 * r9);
	    d0 += h2 * (5 * r8);
	    d0 += h3 * (5 * r7);
	    d0 += h4 * (5 * r6);
	    c = (d0 >>> 13); d0 &= 0x1fff;
	    d0 += h5 * (5 * r5);
	    d0 += h6 * (5 * r4);
	    d0 += h7 * (5 * r3);
	    d0 += h8 * (5 * r2);
	    d0 += h9 * (5 * r1);
	    c += (d0 >>> 13); d0 &= 0x1fff;

	    d1 = c;
	    d1 += h0 * r1;
	    d1 += h1 * r0;
	    d1 += h2 * (5 * r9);
	    d1 += h3 * (5 * r8);
	    d1 += h4 * (5 * r7);
	    c = (d1 >>> 13); d1 &= 0x1fff;
	    d1 += h5 * (5 * r6);
	    d1 += h6 * (5 * r5);
	    d1 += h7 * (5 * r4);
	    d1 += h8 * (5 * r3);
	    d1 += h9 * (5 * r2);
	    c += (d1 >>> 13); d1 &= 0x1fff;

	    d2 = c;
	    d2 += h0 * r2;
	    d2 += h1 * r1;
	    d2 += h2 * r0;
	    d2 += h3 * (5 * r9);
	    d2 += h4 * (5 * r8);
	    c = (d2 >>> 13); d2 &= 0x1fff;
	    d2 += h5 * (5 * r7);
	    d2 += h6 * (5 * r6);
	    d2 += h7 * (5 * r5);
	    d2 += h8 * (5 * r4);
	    d2 += h9 * (5 * r3);
	    c += (d2 >>> 13); d2 &= 0x1fff;

	    d3 = c;
	    d3 += h0 * r3;
	    d3 += h1 * r2;
	    d3 += h2 * r1;
	    d3 += h3 * r0;
	    d3 += h4 * (5 * r9);
	    c = (d3 >>> 13); d3 &= 0x1fff;
	    d3 += h5 * (5 * r8);
	    d3 += h6 * (5 * r7);
	    d3 += h7 * (5 * r6);
	    d3 += h8 * (5 * r5);
	    d3 += h9 * (5 * r4);
	    c += (d3 >>> 13); d3 &= 0x1fff;

	    d4 = c;
	    d4 += h0 * r4;
	    d4 += h1 * r3;
	    d4 += h2 * r2;
	    d4 += h3 * r1;
	    d4 += h4 * r0;
	    c = (d4 >>> 13); d4 &= 0x1fff;
	    d4 += h5 * (5 * r9);
	    d4 += h6 * (5 * r8);
	    d4 += h7 * (5 * r7);
	    d4 += h8 * (5 * r6);
	    d4 += h9 * (5 * r5);
	    c += (d4 >>> 13); d4 &= 0x1fff;

	    d5 = c;
	    d5 += h0 * r5;
	    d5 += h1 * r4;
	    d5 += h2 * r3;
	    d5 += h3 * r2;
	    d5 += h4 * r1;
	    c = (d5 >>> 13); d5 &= 0x1fff;
	    d5 += h5 * r0;
	    d5 += h6 * (5 * r9);
	    d5 += h7 * (5 * r8);
	    d5 += h8 * (5 * r7);
	    d5 += h9 * (5 * r6);
	    c += (d5 >>> 13); d5 &= 0x1fff;

	    d6 = c;
	    d6 += h0 * r6;
	    d6 += h1 * r5;
	    d6 += h2 * r4;
	    d6 += h3 * r3;
	    d6 += h4 * r2;
	    c = (d6 >>> 13); d6 &= 0x1fff;
	    d6 += h5 * r1;
	    d6 += h6 * r0;
	    d6 += h7 * (5 * r9);
	    d6 += h8 * (5 * r8);
	    d6 += h9 * (5 * r7);
	    c += (d6 >>> 13); d6 &= 0x1fff;

	    d7 = c;
	    d7 += h0 * r7;
	    d7 += h1 * r6;
	    d7 += h2 * r5;
	    d7 += h3 * r4;
	    d7 += h4 * r3;
	    c = (d7 >>> 13); d7 &= 0x1fff;
	    d7 += h5 * r2;
	    d7 += h6 * r1;
	    d7 += h7 * r0;
	    d7 += h8 * (5 * r9);
	    d7 += h9 * (5 * r8);
	    c += (d7 >>> 13); d7 &= 0x1fff;

	    d8 = c;
	    d8 += h0 * r8;
	    d8 += h1 * r7;
	    d8 += h2 * r6;
	    d8 += h3 * r5;
	    d8 += h4 * r4;
	    c = (d8 >>> 13); d8 &= 0x1fff;
	    d8 += h5 * r3;
	    d8 += h6 * r2;
	    d8 += h7 * r1;
	    d8 += h8 * r0;
	    d8 += h9 * (5 * r9);
	    c += (d8 >>> 13); d8 &= 0x1fff;

	    d9 = c;
	    d9 += h0 * r9;
	    d9 += h1 * r8;
	    d9 += h2 * r7;
	    d9 += h3 * r6;
	    d9 += h4 * r5;
	    c = (d9 >>> 13); d9 &= 0x1fff;
	    d9 += h5 * r4;
	    d9 += h6 * r3;
	    d9 += h7 * r2;
	    d9 += h8 * r1;
	    d9 += h9 * r0;
	    c += (d9 >>> 13); d9 &= 0x1fff;

	    c = (((c << 2) + c)) | 0;
	    c = (c + d0) | 0;
	    d0 = c & 0x1fff;
	    c = (c >>> 13);
	    d1 += c;

	    h0 = d0;
	    h1 = d1;
	    h2 = d2;
	    h3 = d3;
	    h4 = d4;
	    h5 = d5;
	    h6 = d6;
	    h7 = d7;
	    h8 = d8;
	    h9 = d9;

	    mpos += 16;
	    bytes -= 16;
	  }
	  this.h[0] = h0;
	  this.h[1] = h1;
	  this.h[2] = h2;
	  this.h[3] = h3;
	  this.h[4] = h4;
	  this.h[5] = h5;
	  this.h[6] = h6;
	  this.h[7] = h7;
	  this.h[8] = h8;
	  this.h[9] = h9;
	};

	poly1305.prototype.finish = function(mac, macpos) {
	  var g = new Uint16Array(10);
	  var c, mask, f, i;

	  if (this.leftover) {
	    i = this.leftover;
	    this.buffer[i++] = 1;
	    for (; i < 16; i++) this.buffer[i] = 0;
	    this.fin = 1;
	    this.blocks(this.buffer, 0, 16);
	  }

	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  for (i = 2; i < 10; i++) {
	    this.h[i] += c;
	    c = this.h[i] >>> 13;
	    this.h[i] &= 0x1fff;
	  }
	  this.h[0] += (c * 5);
	  c = this.h[0] >>> 13;
	  this.h[0] &= 0x1fff;
	  this.h[1] += c;
	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  this.h[2] += c;

	  g[0] = this.h[0] + 5;
	  c = g[0] >>> 13;
	  g[0] &= 0x1fff;
	  for (i = 1; i < 10; i++) {
	    g[i] = this.h[i] + c;
	    c = g[i] >>> 13;
	    g[i] &= 0x1fff;
	  }
	  g[9] -= (1 << 13);

	  mask = (c ^ 1) - 1;
	  for (i = 0; i < 10; i++) g[i] &= mask;
	  mask = ~mask;
	  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

	  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
	  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
	  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
	  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
	  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
	  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
	  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
	  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

	  f = this.h[0] + this.pad[0];
	  this.h[0] = f & 0xffff;
	  for (i = 1; i < 8; i++) {
	    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
	    this.h[i] = f & 0xffff;
	  }

	  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
	  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
	  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
	  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
	  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
	  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
	  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
	  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
	  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
	  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
	  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
	  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
	  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
	  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
	  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
	  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
	};

	poly1305.prototype.update = function(m, mpos, bytes) {
	  var i, want;

	  if (this.leftover) {
	    want = (16 - this.leftover);
	    if (want > bytes)
	      want = bytes;
	    for (i = 0; i < want; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    bytes -= want;
	    mpos += want;
	    this.leftover += want;
	    if (this.leftover < 16)
	      return;
	    this.blocks(this.buffer, 0, 16);
	    this.leftover = 0;
	  }

	  if (bytes >= 16) {
	    want = bytes - (bytes % 16);
	    this.blocks(m, mpos, want);
	    mpos += want;
	    bytes -= want;
	  }

	  if (bytes) {
	    for (i = 0; i < bytes; i++)
	      this.buffer[this.leftover + i] = m[mpos+i];
	    this.leftover += bytes;
	  }
	};

	function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
	  var s = new poly1305(k);
	  s.update(m, mpos, n);
	  s.finish(out, outpos);
	  return 0;
	}

	function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
	  var x = new Uint8Array(16);
	  crypto_onetimeauth(x,0,m,mpos,n,k);
	  return crypto_verify_16(h,hpos,x,0);
	}

	function crypto_secretbox(c,m,d,n,k) {
	  var i;
	  if (d < 32) return -1;
	  crypto_stream_xor(c,0,m,0,d,n,k);
	  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
	  for (i = 0; i < 16; i++) c[i] = 0;
	  return 0;
	}

	function crypto_secretbox_open(m,c,d,n,k) {
	  var i;
	  var x = new Uint8Array(32);
	  if (d < 32) return -1;
	  crypto_stream(x,0,32,n,k);
	  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
	  crypto_stream_xor(m,0,c,0,d,n,k);
	  for (i = 0; i < 32; i++) m[i] = 0;
	  return 0;
	}

	function set25519(r, a) {
	  var i;
	  for (i = 0; i < 16; i++) r[i] = a[i]|0;
	}

	function car25519(o) {
	  var i, v, c = 1;
	  for (i = 0; i < 16; i++) {
	    v = o[i] + c + 65535;
	    c = Math.floor(v / 65536);
	    o[i] = v - c * 65536;
	  }
	  o[0] += c-1 + 37 * (c-1);
	}

	function sel25519(p, q, b) {
	  var t, c = ~(b-1);
	  for (var i = 0; i < 16; i++) {
	    t = c & (p[i] ^ q[i]);
	    p[i] ^= t;
	    q[i] ^= t;
	  }
	}

	function pack25519(o, n) {
	  var i, j, b;
	  var m = gf(), t = gf();
	  for (i = 0; i < 16; i++) t[i] = n[i];
	  car25519(t);
	  car25519(t);
	  car25519(t);
	  for (j = 0; j < 2; j++) {
	    m[0] = t[0] - 0xffed;
	    for (i = 1; i < 15; i++) {
	      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
	      m[i-1] &= 0xffff;
	    }
	    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
	    b = (m[15]>>16) & 1;
	    m[14] &= 0xffff;
	    sel25519(t, m, 1-b);
	  }
	  for (i = 0; i < 16; i++) {
	    o[2*i] = t[i] & 0xff;
	    o[2*i+1] = t[i]>>8;
	  }
	}

	function neq25519(a, b) {
	  var c = new Uint8Array(32), d = new Uint8Array(32);
	  pack25519(c, a);
	  pack25519(d, b);
	  return crypto_verify_32(c, 0, d, 0);
	}

	function par25519(a) {
	  var d = new Uint8Array(32);
	  pack25519(d, a);
	  return d[0] & 1;
	}

	function unpack25519(o, n) {
	  var i;
	  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
	  o[15] &= 0x7fff;
	}

	function A(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
	}

	function Z(o, a, b) {
	  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
	}

	function M(o, a, b) {
	  var v, c,
	     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
	     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
	    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
	    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
	    b0 = b[0],
	    b1 = b[1],
	    b2 = b[2],
	    b3 = b[3],
	    b4 = b[4],
	    b5 = b[5],
	    b6 = b[6],
	    b7 = b[7],
	    b8 = b[8],
	    b9 = b[9],
	    b10 = b[10],
	    b11 = b[11],
	    b12 = b[12],
	    b13 = b[13],
	    b14 = b[14],
	    b15 = b[15];

	  v = a[0];
	  t0 += v * b0;
	  t1 += v * b1;
	  t2 += v * b2;
	  t3 += v * b3;
	  t4 += v * b4;
	  t5 += v * b5;
	  t6 += v * b6;
	  t7 += v * b7;
	  t8 += v * b8;
	  t9 += v * b9;
	  t10 += v * b10;
	  t11 += v * b11;
	  t12 += v * b12;
	  t13 += v * b13;
	  t14 += v * b14;
	  t15 += v * b15;
	  v = a[1];
	  t1 += v * b0;
	  t2 += v * b1;
	  t3 += v * b2;
	  t4 += v * b3;
	  t5 += v * b4;
	  t6 += v * b5;
	  t7 += v * b6;
	  t8 += v * b7;
	  t9 += v * b8;
	  t10 += v * b9;
	  t11 += v * b10;
	  t12 += v * b11;
	  t13 += v * b12;
	  t14 += v * b13;
	  t15 += v * b14;
	  t16 += v * b15;
	  v = a[2];
	  t2 += v * b0;
	  t3 += v * b1;
	  t4 += v * b2;
	  t5 += v * b3;
	  t6 += v * b4;
	  t7 += v * b5;
	  t8 += v * b6;
	  t9 += v * b7;
	  t10 += v * b8;
	  t11 += v * b9;
	  t12 += v * b10;
	  t13 += v * b11;
	  t14 += v * b12;
	  t15 += v * b13;
	  t16 += v * b14;
	  t17 += v * b15;
	  v = a[3];
	  t3 += v * b0;
	  t4 += v * b1;
	  t5 += v * b2;
	  t6 += v * b3;
	  t7 += v * b4;
	  t8 += v * b5;
	  t9 += v * b6;
	  t10 += v * b7;
	  t11 += v * b8;
	  t12 += v * b9;
	  t13 += v * b10;
	  t14 += v * b11;
	  t15 += v * b12;
	  t16 += v * b13;
	  t17 += v * b14;
	  t18 += v * b15;
	  v = a[4];
	  t4 += v * b0;
	  t5 += v * b1;
	  t6 += v * b2;
	  t7 += v * b3;
	  t8 += v * b4;
	  t9 += v * b5;
	  t10 += v * b6;
	  t11 += v * b7;
	  t12 += v * b8;
	  t13 += v * b9;
	  t14 += v * b10;
	  t15 += v * b11;
	  t16 += v * b12;
	  t17 += v * b13;
	  t18 += v * b14;
	  t19 += v * b15;
	  v = a[5];
	  t5 += v * b0;
	  t6 += v * b1;
	  t7 += v * b2;
	  t8 += v * b3;
	  t9 += v * b4;
	  t10 += v * b5;
	  t11 += v * b6;
	  t12 += v * b7;
	  t13 += v * b8;
	  t14 += v * b9;
	  t15 += v * b10;
	  t16 += v * b11;
	  t17 += v * b12;
	  t18 += v * b13;
	  t19 += v * b14;
	  t20 += v * b15;
	  v = a[6];
	  t6 += v * b0;
	  t7 += v * b1;
	  t8 += v * b2;
	  t9 += v * b3;
	  t10 += v * b4;
	  t11 += v * b5;
	  t12 += v * b6;
	  t13 += v * b7;
	  t14 += v * b8;
	  t15 += v * b9;
	  t16 += v * b10;
	  t17 += v * b11;
	  t18 += v * b12;
	  t19 += v * b13;
	  t20 += v * b14;
	  t21 += v * b15;
	  v = a[7];
	  t7 += v * b0;
	  t8 += v * b1;
	  t9 += v * b2;
	  t10 += v * b3;
	  t11 += v * b4;
	  t12 += v * b5;
	  t13 += v * b6;
	  t14 += v * b7;
	  t15 += v * b8;
	  t16 += v * b9;
	  t17 += v * b10;
	  t18 += v * b11;
	  t19 += v * b12;
	  t20 += v * b13;
	  t21 += v * b14;
	  t22 += v * b15;
	  v = a[8];
	  t8 += v * b0;
	  t9 += v * b1;
	  t10 += v * b2;
	  t11 += v * b3;
	  t12 += v * b4;
	  t13 += v * b5;
	  t14 += v * b6;
	  t15 += v * b7;
	  t16 += v * b8;
	  t17 += v * b9;
	  t18 += v * b10;
	  t19 += v * b11;
	  t20 += v * b12;
	  t21 += v * b13;
	  t22 += v * b14;
	  t23 += v * b15;
	  v = a[9];
	  t9 += v * b0;
	  t10 += v * b1;
	  t11 += v * b2;
	  t12 += v * b3;
	  t13 += v * b4;
	  t14 += v * b5;
	  t15 += v * b6;
	  t16 += v * b7;
	  t17 += v * b8;
	  t18 += v * b9;
	  t19 += v * b10;
	  t20 += v * b11;
	  t21 += v * b12;
	  t22 += v * b13;
	  t23 += v * b14;
	  t24 += v * b15;
	  v = a[10];
	  t10 += v * b0;
	  t11 += v * b1;
	  t12 += v * b2;
	  t13 += v * b3;
	  t14 += v * b4;
	  t15 += v * b5;
	  t16 += v * b6;
	  t17 += v * b7;
	  t18 += v * b8;
	  t19 += v * b9;
	  t20 += v * b10;
	  t21 += v * b11;
	  t22 += v * b12;
	  t23 += v * b13;
	  t24 += v * b14;
	  t25 += v * b15;
	  v = a[11];
	  t11 += v * b0;
	  t12 += v * b1;
	  t13 += v * b2;
	  t14 += v * b3;
	  t15 += v * b4;
	  t16 += v * b5;
	  t17 += v * b6;
	  t18 += v * b7;
	  t19 += v * b8;
	  t20 += v * b9;
	  t21 += v * b10;
	  t22 += v * b11;
	  t23 += v * b12;
	  t24 += v * b13;
	  t25 += v * b14;
	  t26 += v * b15;
	  v = a[12];
	  t12 += v * b0;
	  t13 += v * b1;
	  t14 += v * b2;
	  t15 += v * b3;
	  t16 += v * b4;
	  t17 += v * b5;
	  t18 += v * b6;
	  t19 += v * b7;
	  t20 += v * b8;
	  t21 += v * b9;
	  t22 += v * b10;
	  t23 += v * b11;
	  t24 += v * b12;
	  t25 += v * b13;
	  t26 += v * b14;
	  t27 += v * b15;
	  v = a[13];
	  t13 += v * b0;
	  t14 += v * b1;
	  t15 += v * b2;
	  t16 += v * b3;
	  t17 += v * b4;
	  t18 += v * b5;
	  t19 += v * b6;
	  t20 += v * b7;
	  t21 += v * b8;
	  t22 += v * b9;
	  t23 += v * b10;
	  t24 += v * b11;
	  t25 += v * b12;
	  t26 += v * b13;
	  t27 += v * b14;
	  t28 += v * b15;
	  v = a[14];
	  t14 += v * b0;
	  t15 += v * b1;
	  t16 += v * b2;
	  t17 += v * b3;
	  t18 += v * b4;
	  t19 += v * b5;
	  t20 += v * b6;
	  t21 += v * b7;
	  t22 += v * b8;
	  t23 += v * b9;
	  t24 += v * b10;
	  t25 += v * b11;
	  t26 += v * b12;
	  t27 += v * b13;
	  t28 += v * b14;
	  t29 += v * b15;
	  v = a[15];
	  t15 += v * b0;
	  t16 += v * b1;
	  t17 += v * b2;
	  t18 += v * b3;
	  t19 += v * b4;
	  t20 += v * b5;
	  t21 += v * b6;
	  t22 += v * b7;
	  t23 += v * b8;
	  t24 += v * b9;
	  t25 += v * b10;
	  t26 += v * b11;
	  t27 += v * b12;
	  t28 += v * b13;
	  t29 += v * b14;
	  t30 += v * b15;

	  t0  += 38 * t16;
	  t1  += 38 * t17;
	  t2  += 38 * t18;
	  t3  += 38 * t19;
	  t4  += 38 * t20;
	  t5  += 38 * t21;
	  t6  += 38 * t22;
	  t7  += 38 * t23;
	  t8  += 38 * t24;
	  t9  += 38 * t25;
	  t10 += 38 * t26;
	  t11 += 38 * t27;
	  t12 += 38 * t28;
	  t13 += 38 * t29;
	  t14 += 38 * t30;
	  // t15 left as is

	  // first car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);

	  // second car
	  c = 1;
	  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
	  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
	  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
	  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
	  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
	  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
	  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
	  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
	  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
	  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
	  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
	  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
	  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
	  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
	  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
	  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
	  t0 += c-1 + 37 * (c-1);

	  o[ 0] = t0;
	  o[ 1] = t1;
	  o[ 2] = t2;
	  o[ 3] = t3;
	  o[ 4] = t4;
	  o[ 5] = t5;
	  o[ 6] = t6;
	  o[ 7] = t7;
	  o[ 8] = t8;
	  o[ 9] = t9;
	  o[10] = t10;
	  o[11] = t11;
	  o[12] = t12;
	  o[13] = t13;
	  o[14] = t14;
	  o[15] = t15;
	}

	function S(o, a) {
	  M(o, a, a);
	}

	function inv25519(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 253; a >= 0; a--) {
	    S(c, c);
	    if(a !== 2 && a !== 4) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}

	function pow2523(o, i) {
	  var c = gf();
	  var a;
	  for (a = 0; a < 16; a++) c[a] = i[a];
	  for (a = 250; a >= 0; a--) {
	      S(c, c);
	      if(a !== 1) M(c, c, i);
	  }
	  for (a = 0; a < 16; a++) o[a] = c[a];
	}

	function crypto_scalarmult(q, n, p) {
	  var z = new Uint8Array(32);
	  var x = new Float64Array(80), r, i;
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf();
	  for (i = 0; i < 31; i++) z[i] = n[i];
	  z[31]=(n[31]&127)|64;
	  z[0]&=248;
	  unpack25519(x,p);
	  for (i = 0; i < 16; i++) {
	    b[i]=x[i];
	    d[i]=a[i]=c[i]=0;
	  }
	  a[0]=d[0]=1;
	  for (i=254; i>=0; --i) {
	    r=(z[i>>>3]>>>(i&7))&1;
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	    A(e,a,c);
	    Z(a,a,c);
	    A(c,b,d);
	    Z(b,b,d);
	    S(d,e);
	    S(f,a);
	    M(a,c,a);
	    M(c,b,e);
	    A(e,a,c);
	    Z(a,a,c);
	    S(b,a);
	    Z(c,d,f);
	    M(a,c,_121665);
	    A(a,a,d);
	    M(c,c,a);
	    M(a,d,f);
	    M(d,b,x);
	    S(b,e);
	    sel25519(a,b,r);
	    sel25519(c,d,r);
	  }
	  for (i = 0; i < 16; i++) {
	    x[i+16]=a[i];
	    x[i+32]=c[i];
	    x[i+48]=b[i];
	    x[i+64]=d[i];
	  }
	  var x32 = x.subarray(32);
	  var x16 = x.subarray(16);
	  inv25519(x32,x32);
	  M(x16,x16,x32);
	  pack25519(q,x16);
	  return 0;
	}

	function crypto_scalarmult_base(q, n) {
	  return crypto_scalarmult(q, n, _9);
	}

	function crypto_box_keypair(y, x) {
	  randombytes(x, 32);
	  return crypto_scalarmult_base(y, x);
	}

	function crypto_box_beforenm(k, y, x) {
	  var s = new Uint8Array(32);
	  crypto_scalarmult(s, x, y);
	  return crypto_core_hsalsa20(k, _0, s, sigma);
	}

	var crypto_box_afternm = crypto_secretbox;
	var crypto_box_open_afternm = crypto_secretbox_open;

	function crypto_box(c, m, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_afternm(c, m, d, n, k);
	}

	function crypto_box_open(m, c, d, n, y, x) {
	  var k = new Uint8Array(32);
	  crypto_box_beforenm(k, y, x);
	  return crypto_box_open_afternm(m, c, d, n, k);
	}

	var K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	function crypto_hashblocks_hl(hh, hl, m, n) {
	  var wh = new Int32Array(16), wl = new Int32Array(16),
	      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
	      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
	      th, tl, i, j, h, l, a, b, c, d;

	  var ah0 = hh[0],
	      ah1 = hh[1],
	      ah2 = hh[2],
	      ah3 = hh[3],
	      ah4 = hh[4],
	      ah5 = hh[5],
	      ah6 = hh[6],
	      ah7 = hh[7],

	      al0 = hl[0],
	      al1 = hl[1],
	      al2 = hl[2],
	      al3 = hl[3],
	      al4 = hl[4],
	      al5 = hl[5],
	      al6 = hl[6],
	      al7 = hl[7];

	  var pos = 0;
	  while (n >= 128) {
	    for (i = 0; i < 16; i++) {
	      j = 8 * i + pos;
	      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
	      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
	    }
	    for (i = 0; i < 80; i++) {
	      bh0 = ah0;
	      bh1 = ah1;
	      bh2 = ah2;
	      bh3 = ah3;
	      bh4 = ah4;
	      bh5 = ah5;
	      bh6 = ah6;
	      bh7 = ah7;

	      bl0 = al0;
	      bl1 = al1;
	      bl2 = al2;
	      bl3 = al3;
	      bl4 = al4;
	      bl5 = al5;
	      bl6 = al6;
	      bl7 = al7;

	      // add
	      h = ah7;
	      l = al7;

	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;

	      // Sigma1
	      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
	      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // Ch
	      h = (ah4 & ah5) ^ (~ah4 & ah6);
	      l = (al4 & al5) ^ (~al4 & al6);

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // K
	      h = K[i*2];
	      l = K[i*2+1];

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // w
	      h = wh[i%16];
	      l = wl[i%16];

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;

	      th = c & 0xffff | d << 16;
	      tl = a & 0xffff | b << 16;

	      // add
	      h = th;
	      l = tl;

	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;

	      // Sigma0
	      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
	      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      // Maj
	      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
	      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;

	      bh7 = (c & 0xffff) | (d << 16);
	      bl7 = (a & 0xffff) | (b << 16);

	      // add
	      h = bh3;
	      l = bl3;

	      a = l & 0xffff; b = l >>> 16;
	      c = h & 0xffff; d = h >>> 16;

	      h = th;
	      l = tl;

	      a += l & 0xffff; b += l >>> 16;
	      c += h & 0xffff; d += h >>> 16;

	      b += a >>> 16;
	      c += b >>> 16;
	      d += c >>> 16;

	      bh3 = (c & 0xffff) | (d << 16);
	      bl3 = (a & 0xffff) | (b << 16);

	      ah1 = bh0;
	      ah2 = bh1;
	      ah3 = bh2;
	      ah4 = bh3;
	      ah5 = bh4;
	      ah6 = bh5;
	      ah7 = bh6;
	      ah0 = bh7;

	      al1 = bl0;
	      al2 = bl1;
	      al3 = bl2;
	      al4 = bl3;
	      al5 = bl4;
	      al6 = bl5;
	      al7 = bl6;
	      al0 = bl7;

	      if (i%16 === 15) {
	        for (j = 0; j < 16; j++) {
	          // add
	          h = wh[j];
	          l = wl[j];

	          a = l & 0xffff; b = l >>> 16;
	          c = h & 0xffff; d = h >>> 16;

	          h = wh[(j+9)%16];
	          l = wl[(j+9)%16];

	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;

	          // sigma0
	          th = wh[(j+1)%16];
	          tl = wl[(j+1)%16];
	          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
	          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;

	          // sigma1
	          th = wh[(j+14)%16];
	          tl = wl[(j+14)%16];
	          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
	          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

	          a += l & 0xffff; b += l >>> 16;
	          c += h & 0xffff; d += h >>> 16;

	          b += a >>> 16;
	          c += b >>> 16;
	          d += c >>> 16;

	          wh[j] = (c & 0xffff) | (d << 16);
	          wl[j] = (a & 0xffff) | (b << 16);
	        }
	      }
	    }

	    // add
	    h = ah0;
	    l = al0;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[0];
	    l = hl[0];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[0] = ah0 = (c & 0xffff) | (d << 16);
	    hl[0] = al0 = (a & 0xffff) | (b << 16);

	    h = ah1;
	    l = al1;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[1];
	    l = hl[1];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[1] = ah1 = (c & 0xffff) | (d << 16);
	    hl[1] = al1 = (a & 0xffff) | (b << 16);

	    h = ah2;
	    l = al2;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[2];
	    l = hl[2];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[2] = ah2 = (c & 0xffff) | (d << 16);
	    hl[2] = al2 = (a & 0xffff) | (b << 16);

	    h = ah3;
	    l = al3;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[3];
	    l = hl[3];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[3] = ah3 = (c & 0xffff) | (d << 16);
	    hl[3] = al3 = (a & 0xffff) | (b << 16);

	    h = ah4;
	    l = al4;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[4];
	    l = hl[4];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[4] = ah4 = (c & 0xffff) | (d << 16);
	    hl[4] = al4 = (a & 0xffff) | (b << 16);

	    h = ah5;
	    l = al5;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[5];
	    l = hl[5];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[5] = ah5 = (c & 0xffff) | (d << 16);
	    hl[5] = al5 = (a & 0xffff) | (b << 16);

	    h = ah6;
	    l = al6;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[6];
	    l = hl[6];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[6] = ah6 = (c & 0xffff) | (d << 16);
	    hl[6] = al6 = (a & 0xffff) | (b << 16);

	    h = ah7;
	    l = al7;

	    a = l & 0xffff; b = l >>> 16;
	    c = h & 0xffff; d = h >>> 16;

	    h = hh[7];
	    l = hl[7];

	    a += l & 0xffff; b += l >>> 16;
	    c += h & 0xffff; d += h >>> 16;

	    b += a >>> 16;
	    c += b >>> 16;
	    d += c >>> 16;

	    hh[7] = ah7 = (c & 0xffff) | (d << 16);
	    hl[7] = al7 = (a & 0xffff) | (b << 16);

	    pos += 128;
	    n -= 128;
	  }

	  return n;
	}

	function crypto_hash(out, m, n) {
	  var hh = new Int32Array(8),
	      hl = new Int32Array(8),
	      x = new Uint8Array(256),
	      i, b = n;

	  hh[0] = 0x6a09e667;
	  hh[1] = 0xbb67ae85;
	  hh[2] = 0x3c6ef372;
	  hh[3] = 0xa54ff53a;
	  hh[4] = 0x510e527f;
	  hh[5] = 0x9b05688c;
	  hh[6] = 0x1f83d9ab;
	  hh[7] = 0x5be0cd19;

	  hl[0] = 0xf3bcc908;
	  hl[1] = 0x84caa73b;
	  hl[2] = 0xfe94f82b;
	  hl[3] = 0x5f1d36f1;
	  hl[4] = 0xade682d1;
	  hl[5] = 0x2b3e6c1f;
	  hl[6] = 0xfb41bd6b;
	  hl[7] = 0x137e2179;

	  crypto_hashblocks_hl(hh, hl, m, n);
	  n %= 128;

	  for (i = 0; i < n; i++) x[i] = m[b-n+i];
	  x[n] = 128;

	  n = 256-128*(n<112?1:0);
	  x[n-9] = 0;
	  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
	  crypto_hashblocks_hl(hh, hl, x, n);

	  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

	  return 0;
	}

	function add(p, q) {
	  var a = gf(), b = gf(), c = gf(),
	      d = gf(), e = gf(), f = gf(),
	      g = gf(), h = gf(), t = gf();

	  Z(a, p[1], p[0]);
	  Z(t, q[1], q[0]);
	  M(a, a, t);
	  A(b, p[0], p[1]);
	  A(t, q[0], q[1]);
	  M(b, b, t);
	  M(c, p[3], q[3]);
	  M(c, c, D2);
	  M(d, p[2], q[2]);
	  A(d, d, d);
	  Z(e, b, a);
	  Z(f, d, c);
	  A(g, d, c);
	  A(h, b, a);

	  M(p[0], e, f);
	  M(p[1], h, g);
	  M(p[2], g, f);
	  M(p[3], e, h);
	}

	function cswap(p, q, b) {
	  var i;
	  for (i = 0; i < 4; i++) {
	    sel25519(p[i], q[i], b);
	  }
	}

	function pack(r, p) {
	  var tx = gf(), ty = gf(), zi = gf();
	  inv25519(zi, p[2]);
	  M(tx, p[0], zi);
	  M(ty, p[1], zi);
	  pack25519(r, ty);
	  r[31] ^= par25519(tx) << 7;
	}

	function scalarmult(p, q, s) {
	  var b, i;
	  set25519(p[0], gf0);
	  set25519(p[1], gf1);
	  set25519(p[2], gf1);
	  set25519(p[3], gf0);
	  for (i = 255; i >= 0; --i) {
	    b = (s[(i/8)|0] >> (i&7)) & 1;
	    cswap(p, q, b);
	    add(q, p);
	    add(p, p);
	    cswap(p, q, b);
	  }
	}

	function scalarbase(p, s) {
	  var q = [gf(), gf(), gf(), gf()];
	  set25519(q[0], X);
	  set25519(q[1], Y);
	  set25519(q[2], gf1);
	  M(q[3], X, Y);
	  scalarmult(p, q, s);
	}

	function crypto_sign_keypair(pk, sk, seeded) {
	  var d = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()];
	  var i;

	  if (!seeded) randombytes(sk, 32);
	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;

	  scalarbase(p, d);
	  pack(pk, p);

	  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
	  return 0;
	}

	var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

	function modL(r, x) {
	  var carry, i, j, k;
	  for (i = 63; i >= 32; --i) {
	    carry = 0;
	    for (j = i - 32, k = i - 12; j < k; ++j) {
	      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
	      carry = Math.floor((x[j] + 128) / 256);
	      x[j] -= carry * 256;
	    }
	    x[j] += carry;
	    x[i] = 0;
	  }
	  carry = 0;
	  for (j = 0; j < 32; j++) {
	    x[j] += carry - (x[31] >> 4) * L[j];
	    carry = x[j] >> 8;
	    x[j] &= 255;
	  }
	  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
	  for (i = 0; i < 32; i++) {
	    x[i+1] += x[i] >> 8;
	    r[i] = x[i] & 255;
	  }
	}

	function reduce(r) {
	  var x = new Float64Array(64), i;
	  for (i = 0; i < 64; i++) x[i] = r[i];
	  for (i = 0; i < 64; i++) r[i] = 0;
	  modL(r, x);
	}

	// Note: difference from C - smlen returned, not passed as argument.
	function crypto_sign(sm, m, n, sk) {
	  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
	  var i, j, x = new Float64Array(64);
	  var p = [gf(), gf(), gf(), gf()];

	  crypto_hash(d, sk, 32);
	  d[0] &= 248;
	  d[31] &= 127;
	  d[31] |= 64;

	  var smlen = n + 64;
	  for (i = 0; i < n; i++) sm[64 + i] = m[i];
	  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

	  crypto_hash(r, sm.subarray(32), n+32);
	  reduce(r);
	  scalarbase(p, r);
	  pack(sm, p);

	  for (i = 32; i < 64; i++) sm[i] = sk[i];
	  crypto_hash(h, sm, n + 64);
	  reduce(h);

	  for (i = 0; i < 64; i++) x[i] = 0;
	  for (i = 0; i < 32; i++) x[i] = r[i];
	  for (i = 0; i < 32; i++) {
	    for (j = 0; j < 32; j++) {
	      x[i+j] += h[i] * d[j];
	    }
	  }

	  modL(sm.subarray(32), x);
	  return smlen;
	}

	function unpackneg(r, p) {
	  var t = gf(), chk = gf(), num = gf(),
	      den = gf(), den2 = gf(), den4 = gf(),
	      den6 = gf();

	  set25519(r[2], gf1);
	  unpack25519(r[1], p);
	  S(num, r[1]);
	  M(den, num, D);
	  Z(num, num, r[2]);
	  A(den, r[2], den);

	  S(den2, den);
	  S(den4, den2);
	  M(den6, den4, den2);
	  M(t, den6, num);
	  M(t, t, den);

	  pow2523(t, t);
	  M(t, t, num);
	  M(t, t, den);
	  M(t, t, den);
	  M(r[0], t, den);

	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) M(r[0], r[0], I);

	  S(chk, r[0]);
	  M(chk, chk, den);
	  if (neq25519(chk, num)) return -1;

	  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

	  M(r[3], r[0], r[1]);
	  return 0;
	}

	function crypto_sign_open(m, sm, n, pk) {
	  var i;
	  var t = new Uint8Array(32), h = new Uint8Array(64);
	  var p = [gf(), gf(), gf(), gf()],
	      q = [gf(), gf(), gf(), gf()];

	  if (n < 64) return -1;

	  if (unpackneg(q, pk)) return -1;

	  for (i = 0; i < n; i++) m[i] = sm[i];
	  for (i = 0; i < 32; i++) m[i+32] = pk[i];
	  crypto_hash(h, m, n);
	  reduce(h);
	  scalarmult(p, q, h);

	  scalarbase(q, sm.subarray(32));
	  add(p, q);
	  pack(t, p);

	  n -= 64;
	  if (crypto_verify_32(sm, 0, t, 0)) {
	    for (i = 0; i < n; i++) m[i] = 0;
	    return -1;
	  }

	  for (i = 0; i < n; i++) m[i] = sm[i + 64];
	  return n;
	}

	var crypto_secretbox_KEYBYTES = 32,
	    crypto_secretbox_NONCEBYTES = 24,
	    crypto_secretbox_ZEROBYTES = 32,
	    crypto_secretbox_BOXZEROBYTES = 16,
	    crypto_scalarmult_BYTES = 32,
	    crypto_scalarmult_SCALARBYTES = 32,
	    crypto_box_PUBLICKEYBYTES = 32,
	    crypto_box_SECRETKEYBYTES = 32,
	    crypto_box_BEFORENMBYTES = 32,
	    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
	    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
	    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
	    crypto_sign_BYTES = 64,
	    crypto_sign_PUBLICKEYBYTES = 32,
	    crypto_sign_SECRETKEYBYTES = 64,
	    crypto_sign_SEEDBYTES = 32,
	    crypto_hash_BYTES = 64;

	nacl.lowlevel = {
	  crypto_core_hsalsa20: crypto_core_hsalsa20,
	  crypto_stream_xor: crypto_stream_xor,
	  crypto_stream: crypto_stream,
	  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
	  crypto_stream_salsa20: crypto_stream_salsa20,
	  crypto_onetimeauth: crypto_onetimeauth,
	  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
	  crypto_verify_16: crypto_verify_16,
	  crypto_verify_32: crypto_verify_32,
	  crypto_secretbox: crypto_secretbox,
	  crypto_secretbox_open: crypto_secretbox_open,
	  crypto_scalarmult: crypto_scalarmult,
	  crypto_scalarmult_base: crypto_scalarmult_base,
	  crypto_box_beforenm: crypto_box_beforenm,
	  crypto_box_afternm: crypto_box_afternm,
	  crypto_box: crypto_box,
	  crypto_box_open: crypto_box_open,
	  crypto_box_keypair: crypto_box_keypair,
	  crypto_hash: crypto_hash,
	  crypto_sign: crypto_sign,
	  crypto_sign_keypair: crypto_sign_keypair,
	  crypto_sign_open: crypto_sign_open,

	  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
	  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
	  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
	  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
	  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
	  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
	  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
	  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
	  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
	  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
	  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
	  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
	  crypto_sign_BYTES: crypto_sign_BYTES,
	  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
	  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
	  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
	  crypto_hash_BYTES: crypto_hash_BYTES,

	  gf: gf,
	  D: D,
	  L: L,
	  pack25519: pack25519,
	  unpack25519: unpack25519,
	  M: M,
	  A: A,
	  S: S,
	  Z: Z,
	  pow2523: pow2523,
	  add: add,
	  set25519: set25519,
	  modL: modL,
	  scalarmult: scalarmult,
	  scalarbase: scalarbase,
	};

	/* High-level API */

	function checkLengths(k, n) {
	  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
	  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
	}

	function checkBoxLengths(pk, sk) {
	  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
	  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
	}

	function checkArrayTypes() {
	  for (var i = 0; i < arguments.length; i++) {
	    if (!(arguments[i] instanceof Uint8Array))
	      throw new TypeError('unexpected type, use Uint8Array');
	  }
	}

	function cleanup(arr) {
	  for (var i = 0; i < arr.length; i++) arr[i] = 0;
	}

	nacl.randomBytes = function(n) {
	  var b = new Uint8Array(n);
	  randombytes(b, n);
	  return b;
	};

	nacl.secretbox = function(msg, nonce, key) {
	  checkArrayTypes(msg, nonce, key);
	  checkLengths(key, nonce);
	  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
	  var c = new Uint8Array(m.length);
	  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
	  crypto_secretbox(c, m, m.length, nonce, key);
	  return c.subarray(crypto_secretbox_BOXZEROBYTES);
	};

	nacl.secretbox.open = function(box, nonce, key) {
	  checkArrayTypes(box, nonce, key);
	  checkLengths(key, nonce);
	  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
	  var m = new Uint8Array(c.length);
	  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
	  if (c.length < 32) return null;
	  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
	  return m.subarray(crypto_secretbox_ZEROBYTES);
	};

	nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
	nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
	nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

	nacl.scalarMult = function(n, p) {
	  checkArrayTypes(n, p);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult(q, n, p);
	  return q;
	};

	nacl.scalarMult.base = function(n) {
	  checkArrayTypes(n);
	  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
	  var q = new Uint8Array(crypto_scalarmult_BYTES);
	  crypto_scalarmult_base(q, n);
	  return q;
	};

	nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
	nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

	nacl.box = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox(msg, nonce, k);
	};

	nacl.box.before = function(publicKey, secretKey) {
	  checkArrayTypes(publicKey, secretKey);
	  checkBoxLengths(publicKey, secretKey);
	  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
	  crypto_box_beforenm(k, publicKey, secretKey);
	  return k;
	};

	nacl.box.after = nacl.secretbox;

	nacl.box.open = function(msg, nonce, publicKey, secretKey) {
	  var k = nacl.box.before(publicKey, secretKey);
	  return nacl.secretbox.open(msg, nonce, k);
	};

	nacl.box.open.after = nacl.secretbox.open;

	nacl.box.keyPair = function() {
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
	  crypto_box_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};

	nacl.box.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
	  crypto_scalarmult_base(pk, secretKey);
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};

	nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
	nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
	nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
	nacl.box.nonceLength = crypto_box_NONCEBYTES;
	nacl.box.overheadLength = nacl.secretbox.overheadLength;

	nacl.sign = function(msg, secretKey) {
	  checkArrayTypes(msg, secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
	  crypto_sign(signedMsg, msg, msg.length, secretKey);
	  return signedMsg;
	};

	nacl.sign.open = function(signedMsg, publicKey) {
	  checkArrayTypes(signedMsg, publicKey);
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var tmp = new Uint8Array(signedMsg.length);
	  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
	  if (mlen < 0) return null;
	  var m = new Uint8Array(mlen);
	  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
	  return m;
	};

	nacl.sign.detached = function(msg, secretKey) {
	  var signedMsg = nacl.sign(msg, secretKey);
	  var sig = new Uint8Array(crypto_sign_BYTES);
	  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
	  return sig;
	};

	nacl.sign.detached.verify = function(msg, sig, publicKey) {
	  checkArrayTypes(msg, sig, publicKey);
	  if (sig.length !== crypto_sign_BYTES)
	    throw new Error('bad signature size');
	  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
	    throw new Error('bad public key size');
	  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
	  var i;
	  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
	  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
	  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
	};

	nacl.sign.keyPair = function() {
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  crypto_sign_keypair(pk, sk);
	  return {publicKey: pk, secretKey: sk};
	};

	nacl.sign.keyPair.fromSecretKey = function(secretKey) {
	  checkArrayTypes(secretKey);
	  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
	    throw new Error('bad secret key size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
	  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
	};

	nacl.sign.keyPair.fromSeed = function(seed) {
	  checkArrayTypes(seed);
	  if (seed.length !== crypto_sign_SEEDBYTES)
	    throw new Error('bad seed size');
	  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
	  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
	  for (var i = 0; i < 32; i++) sk[i] = seed[i];
	  crypto_sign_keypair(pk, sk, true);
	  return {publicKey: pk, secretKey: sk};
	};

	nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
	nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
	nacl.sign.seedLength = crypto_sign_SEEDBYTES;
	nacl.sign.signatureLength = crypto_sign_BYTES;

	nacl.hash = function(msg) {
	  checkArrayTypes(msg);
	  var h = new Uint8Array(crypto_hash_BYTES);
	  crypto_hash(h, msg, msg.length);
	  return h;
	};

	nacl.hash.hashLength = crypto_hash_BYTES;

	nacl.verify = function(x, y) {
	  checkArrayTypes(x, y);
	  // Zero length arguments are considered not equal.
	  if (x.length === 0 || y.length === 0) return false;
	  if (x.length !== y.length) return false;
	  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
	};

	nacl.setPRNG = function(fn) {
	  randombytes = fn;
	};

	(function() {
	  // Initialize PRNG if environment provides CSPRNG.
	  // If not, methods calling randombytes will throw.
	  var crypto$1 = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
	  if (crypto$1 && crypto$1.getRandomValues) {
	    // Browsers.
	    var QUOTA = 65536;
	    nacl.setPRNG(function(x, n) {
	      var i, v = new Uint8Array(n);
	      for (i = 0; i < n; i += QUOTA) {
	        crypto$1.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
	      }
	      for (i = 0; i < n; i++) x[i] = v[i];
	      cleanup(v);
	    });
	  } else if (typeof commonjsRequire$1 !== 'undefined') {
	    // Node.js.
	    crypto$1 = crypto;
	    if (crypto$1 && crypto$1.randomBytes) {
	      nacl.setPRNG(function(x, n) {
	        var i, v = crypto$1.randomBytes(n);
	        for (i = 0; i < n; i++) x[i] = v[i];
	        cleanup(v);
	      });
	    }
	  }
	})();

	})( module.exports ? module.exports : (self.nacl = self.nacl || {}));
	});

	var naclUtil$1 = createCommonjsModule$1(function (module) {
	// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
	// Public domain.
	(function(root, f) {
	  if ( module.exports) module.exports = f();
	  else if (root.nacl) root.nacl.util = f();
	  else {
	    root.nacl = {};
	    root.nacl.util = f();
	  }
	}(commonjsGlobal$1, function() {

	  var util = {};

	  function validateBase64(s) {
	    if (!(/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s))) {
	      throw new TypeError('invalid encoding');
	    }
	  }

	  util.decodeUTF8 = function(s) {
	    if (typeof s !== 'string') throw new TypeError('expected string');
	    var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
	    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	    return b;
	  };

	  util.encodeUTF8 = function(arr) {
	    var i, s = [];
	    for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
	    return decodeURIComponent(escape(s.join('')));
	  };

	  if (typeof atob === 'undefined') {
	    // Node.js

	    if (typeof Buffer.from !== 'undefined') {
	       // Node v6 and later
	      util.encodeBase64 = function (arr) { // v6 and later
	          return Buffer.from(arr).toString('base64');
	      };

	      util.decodeBase64 = function (s) {
	        validateBase64(s);
	        return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0));
	      };

	    } else {
	      // Node earlier than v6
	      util.encodeBase64 = function (arr) { // v6 and later
	        return (new Buffer(arr)).toString('base64');
	      };

	      util.decodeBase64 = function(s) {
	        validateBase64(s);
	        return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
	      };
	    }

	  } else {
	    // Browsers

	    util.encodeBase64 = function(arr) {
	      var i, s = [], len = arr.length;
	      for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
	      return btoa(s.join(''));
	    };

	    util.decodeBase64 = function(s) {
	      validateBase64(s);
	      var i, d = atob(s), b = new Uint8Array(d.length);
	      for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
	      return b;
	    };

	  }

	  return util;

	}));
	});

	naclFast$1.util = naclUtil$1;
	const { log: log$1, bufferToHex: bufferToHex$2 } = util;

	// HELPER METHODS:

	function reloadView(view, ip, port, deviceName, deviceKey) {
	  log$1('RECEIVED GUI RELOAD REQUEST. HANG TIGHT. BE RIGHT BACK.');
	  if (view) {
	    let str = `?deviceKey=${deviceKey}`;
	    if (ip) {
	      str += `&ip=${ip}`;
	      if (port) {
	        str += `&port=${port}`;
	      }
	      if (deviceName) {
	        str += `&deviceName=${deviceName}`;
	      }
	    }
	    window.location.href = `${window.location.protocol}//${window.location.hostname}:${window.location.port}/${view}${str}`;
	  } else {
	    location.reload(true); // browser object -- location.reload(forceGet)
	  }
	}

	function computeGuiNotifications(notifications) {
	  const now = Date.now();
	  return notifications
	    ? notifications
	        .filter(n => now < n.expireAt)
	        .map(n => {
	          return Object.assign(n, { relativeTimeAdded: util.humanTime(util.msIntoTimeSpan(now - n.addedAt)) });
	        })
	    : notifications;
	}

	class MultiConnectedStore extends Store {
	  constructor(data = {}) {
	    super(); // our Base store will hold reflected data of all encapsulated stores

	    const keys = naclFast$1.box.keyPair();
	    this.publicKey = keys.publicKey;
	    this.privateKey = keys.secretKey;

	    this.bus = new Eev$1();

	    // additional information describing the currently loaded state inside this::Store (svelte, dmt)
	    // gets copied into super.set({meta:...}) inside stateChangedHandler
	    this.meta = {
	      thisDeviceName: null,
	      defaultStoreData: data
	    };

	    // warning: console.log() used in contructor of this store will not have an effect of showing this info
	    // in frontend log ...
	    // interception of console.log and redirection to frontendlog is done in main.js after this store is instantiated
	    this.frontendLog = [];

	    this.debug = {};

	    // -----IDLE-------
	    this.guiIdleSeconds = 0;

	    // revert to home screen after 60-90s of inactivity (undeterministic, depending of exact timer situation in each case)
	    const guiIdleBump = () => {
	      const { idleView } = this.get();

	      if (idleView) {
	        this.guiIdleSeconds += 30; //

	        if (this.guiIdleSeconds > 60) {
	          const currentView = window.location.pathname.replace(/\//g, '');
	          if (currentView != idleView) {
	            // GUI WAS IDLE FOR 60s AT THIS POINT:
	            this.switchView(idleView);
	          }
	        }
	      }

	      setTimeout(guiIdleBump, 30000);
	    };

	    setTimeout(guiIdleBump, 5000);

	    // ------------

	    this.thisDeviceState = {};
	    this.nearbyDevices = [];

	    this.on('gui_action', ({ action, payload }) => this.processActionOriginatingFromBackendOnThisDevice({ action, payload }));

	    this.stores = {};

	    this.setupThisStore(data);
	  }

	  updateGuiNotifications() {
	    if (this.thisDeviceState) {
	      const { notifications } = this.thisDeviceState;

	      if (notifications) {
	        super.set({ guiNotifications: computeGuiNotifications(notifications) });
	      }
	    }
	  }

	  setupThisStore(data) {
	    const thisStore = new ConnectedStore(data, { multiConnectedStoreRef: this });

	    // new stores are added each time we first connect to some device gui endpoint
	    // if store doesn't have an ip, it's the localhost store

	    const x = () => {
	      this.updateGuiNotifications();

	      setTimeout(() => {
	        x();
	      }, 500);
	    };

	    x();

	    thisStore.on('state', ({ current, changed, previous }) => {
	      this.thisDeviceState = current; // no need to clone the state here because svelte already does the right thing... might not be the case with other frameworks ? If something doesn't work, make sure to clone the state here

	      const state = { thisDeviceState: this.thisDeviceState };

	      if (changed.nearbyDevices) {
	        const nearbyDevices = JSON.parse(JSON.stringify(this.filterNearbyDevices(current.nearbyDevices || [])));

	        this.nearbyDevices = nearbyDevices;
	        state.nearbyDevices = nearbyDevices;

	        this.detectDeviceIPChangesForActiveStores();
	      }

	      delete this.thisDeviceState.nearbyDevices;

	      if (changed.notifications) {
	        state.guiNotifications = computeGuiNotifications(current.notifications);
	      }

	      //delete this.thisDeviceState.notifications;

	      super.set(state);

	      // we cache and save deviceName returned from locally connected backend store with id (==index) equal to 0
	      // (this store is same as all the other stores except that it is connected to localhost:7780 via ws as oppoised to:
	      // some_lan_ip:7780)
	      if (current.device) {
	        const { deviceName, deviceKey: thisDeviceKey } = current.device;

	        // this is an object property (like activeStoreKey) but will be copied to store data in changeHandler
	        this.meta.thisDeviceName = deviceName;
	        this.meta.thisDeviceKey = thisDeviceKey;

	        if (!this.meta.activeStoreKey) {
	          this.meta.activeStoreKey = thisDeviceKey;
	          this.stores[thisDeviceKey] = thisStore;
	        }

	        this.stateChangeHandler({ state: current, storeKey: thisDeviceKey, stateDiff: changed });
	      }
	    });
	  }

	  detectDeviceIPChangesForActiveStores() {
	    for (const [storeKey, store] of Object.entries(this.stores)) {
	      //console.log(`${storeKey}: ${store.ip}`);

	      for (const { deviceName, deviceKey, thisDevice, ip, guiPort } of this.nearbyDevices) {
	        if (!thisDevice && deviceKey == storeKey) {
	          if (store.ip != ip) {
	            console.log(`IP CHANGED: ${deviceName}: ${deviceKey} ${store.ip} -> ${ip}`);

	            store.decommission(); // destroy current store on wrong IP
	            delete this.stores[storeKey]; //this.createNewStore({ deviceKey, ip, port: guiPort });

	            if (this.meta.activeStoreKey == storeKey) {
	              this.switch({ deviceKey, ip, port: guiPort, deviceName });
	            }

	            // todo: what if ip does not change but device is really missing never to come back..
	            // we should decommission stuch stores as well !! TODO IMPORTANT!!!
	          }
	        }
	      }
	    }
	  }

	  // cannot use console.log from here!!
	  addToFrontendLog(...args) {
	    // arguments are collected and single argument passed in actually became an array with one element
	    if (args.length == 1) {
	      args = args[0];
	    }

	    if (typeof args == 'string') {
	      this.frontendLog.push(args);
	    } else {
	      try {
	        this.frontendLog.push(`${JSON.stringify(args)}`);
	      } catch (e) {
	        this.frontendLog.push(args);
	      }
	    }
	    const limit = 28;
	    this.frontendLog = this.frontendLog.slice(-limit);
	  }

	  switchView(view) {
	    this.guiEngaged();
	    this.set({ view });
	    history.pushState({ view }, view, `/${view}`);
	  }

	  // this is one of the most important methods on the store
	  // it is responsible for reflecting the state of each connected store into our "imitation store"
	  stateChangeHandler({ state, storeKey, stateDiff }) {
	    if (this.meta.activeStoreKey == storeKey) {
	      // only for debugging purposes - showing state change counter in gui ==>
	      state.stateChangeCounter = state.stateChangeCounter || 0;
	      state.stateChangeCounter += 1;
	      state.stateChangeCounter %= 1000;

	      //const completeState = Object.assign(state, { meta: this.meta });

	      // further research: understand how we get state, obviously it's possible to get partial state here...
	      // probably has to do with notifications... in any case for our purposes we detect the full state by
	      // presence of "device" key...

	      if (state.device && state.device.deviceName) {
	        this.meta.selectedDeviceName = state.device.deviceName;
	      }

	      //super.set(completeState); // state enhanced with meta info
	      super.set(state); // state enhanced with meta info

	      // UGLY and also probably not all that is needed, we want to somehow
	      // delete all properties from the previous state (this.get())
	      // that are not also in new state ... this was happening when switching from tv to "testground" for example
	      // (which doesn't have player or playlist in state
	      // not sure how to do this better (eg. remove all)

	      // also remembered something, todo: if player is inside state and we disable it in .def then restart the process
	      // should get removed from state!
	      //
	      //  ---------->>>>>>>>>>>> HACK

	      if (state.player == null) {
	        super.set({ player: null });
	      }
	      if (state.services == null) {
	        super.set({ services: null });
	      }
	      if (state.environment == null) {
	        super.set({ environment: null });
	      }
	      if (state.playlist == null) {
	        super.set({ playlist: null });
	      }
	      if (state.playlistMetadata == null) {
	        super.set({ playlistMetadata: null });
	      }
	      if (state.sysinfo == null) {
	        super.set({ sysinfo: null });
	      }
	      if (state.searchResults == null) {
	        super.set({ searchResults: null });
	      }
	    }
	  }

	  currentStore() {
	    //console.log(this.meta.activeStoreKey);
	    return this.stores[this.meta.activeStoreKey];
	  }

	  createNewStore({ deviceKey, ip, port }) {
	    const newStore = new ConnectedStore(this.meta.defaultStoreData, { multiConnectedStoreRef: this, ip, port });

	    newStore.on('state', ({ current, changed, previous }) => {
	      delete current.notifications; // not interested in remote notifications -- we don't show or use them
	      // we make sure that in our Svelte Global Store (and thus GUI) there are only this device notifications...
	      delete current.nearbyDevices; // also not interested in other devices "nearbyDevices list"

	      this.stateChangeHandler({ state: current, storeKey: deviceKey, stateDiff: changed });
	    });

	    return newStore;
	  }

	  // deviceName is only for gui prefill purposes, to switch by resolving ip, use: this.switchByDeviceName(...)
	  switch({ deviceKey = this.meta.thisDeviceKey, ip = null, port = null, deviceName = null } = {}) {
	    // we cannot omit ip, port and deviceName from here and only get deviceKey, then read other things from nearbyDevices
	    // we mostly could but would get into problems with reloadView since there is no time to get nearbyDevices from backend
	    // before we would already need them

	    this.guiEngaged();

	    // didn't work when ip changed!!
	    //this.lastDeviceIp = this.currentStore().ip;

	    if (!this.stores[deviceKey]) {
	      this.stores[deviceKey] = this.createNewStore({ deviceKey, ip, port });
	    }

	    // pre-fill device name in case we cannot connect to device at all
	    if (deviceName) {
	      this.meta.selectedDeviceName = deviceName;
	      //super.set({ device: { deviceName: deviceName }, meta: { selectedDeviceName: deviceName } });
	      super.set({ device: { deviceName } });
	    }
	    //}

	    this.meta.activeStoreKey = deviceKey;

	    setTimeout(() => {
	      const current = this.currentStore().get();

	      // not full state is yet here on freshly added store!
	      // solution and requirement: the same method will be called upon full state (and each state change) as seen a few lines
	      // above where this.stateChangeHandler is also called inside a handled state change on the new store
	      this.stateChangeHandler({ state: current, storeKey: deviceKey });

	      this.fire('update'); // Svelte likes this
	    }, 10); // TODO: experiment with this value.... 10 milliseconds! 0 also seems to work ;) but there needs to be a separate event callback using setTimeout
	    // not sure if state will still be missing initially over slower links? But even if there is, there is always a frontendTicker event twice per second on every gui ... not sure STILL if this propagates over to other devices? NEED TO MAKE A EVENTFLOW framework ASAP
	    // MAYBE TRY WITH: setImmediate or nextTick (https://stackoverflow.com/a/44275063)
	    // https://flaviocopes.com/node-setimmediate/

	    console.log(`Underlying connected store switched to device with pubkey ${this.meta.activeStoreKey}`);

	    // great that this works! usually we would have to reflect the initial state of the newly added store into our Fake Store manually
	    // we'd need an event from the new store that the first push of state happened, then we'd just use super.set() to set the passed-in-state
	  }

	  switchToggle() {
	    //this.switch({ ip: this.lastDeviceIp });
	  }

	  switchByDeviceNameOrIp({ deviceName, ip }) {
	    const matchingDevice = this.nearbyDevices.find(device => (deviceName && device.deviceName == deviceName) || (ip && device.ip == ip));

	    if (matchingDevice) {
	      matchingDevice.guiPort = matchingDevice.port;
	      this.switch(matchingDevice);
	    }
	  }

	  // send user actions from frontend (clicks, options etc...) to the appropriate backend (on local or currently tunneled device) via websocket
	  // name is always 'action' in this case
	  signal(name, data) {
	    // this is not really needed but we have it just in case if "pointer-events: none;" is not added exactly at te right time
	    // it will be added through componentBridge::aspectGui which also check videoOverlay() property
	    if (this.videoOverlay()) {
	      return;
	    }

	    this.guiEngaged();
	    this.currentStore().signal(name, data);
	  }

	  signalLocalDevice(name, data) {
	    const thisStore = this.stores[this.meta.thisDeviceKey];
	    thisStore.signal(name, data);
	  }

	  videoOverlay() {
	    if (this.thisDeviceState && window.location.hostname == 'localhost') {
	      const { player } = this.thisDeviceState;
	      if (player && player.currentMedia && player.currentMedia.mediaType == 'video') {
	        // we ignore all user actions when video is overlayed on current device
	        // in addition to that in App.html we set "pointer-events: none;" on the main class to
	        // prevent all clicks (like changing the views, switching store, hiding and opening menus etc.)
	        return true;
	      }
	    }
	  }

	  // Reflect part of device state (local or tunneled) into frontent component state (like a Svelte component)
	  // all a component needs to do is this (example for Svelte):

	  // oncreate() {
	  //   // adds thisDeviceName and selectedDeviceName to the component store
	  //   this.store.entangle(this);
	  // },

	  // Also reflect part of the definition as defined by definition selector (reference -- similar to xpath):

	  // oncreate() {
	  //   // adds thisDeviceName and selectedDeviceName to the component store
	  //   // also adds specific fields from device definition --- (.def property access similar to xpath)
	  //   this.store.entangle(this, { def: 'service[gui].nearby' });
	  // }
	  entangle(component) {
	    const state = () => {
	      return {
	        component,
	        thisDeviceState: this.thisDeviceState,
	        meta: this.meta,
	        frontendLog: this.frontendLog,
	        tunneledState: this.get(),
	        nearbyDevices: this.nearbyDevices,
	        //guiNotifications: this.guiNotifications,
	        globalStore: this
	      };
	    };

	    componentBridge.addPropertiesToGUIComponent(state());

	    const listener = this.on('state', ({ current, changed, previous }) => componentBridge.addPropertiesToGUIComponent(Object.assign(state(), { changed })));

	    component.on('destroy', listener.cancel);
	  }

	  // on currently tunneled device
	  remoteObject(handle) {
	    const currentStore = this.currentStore();
	    return currentStore.remoteObject(handle);
	  }

	  // we don't need this! only for logging purposes
	  // get(...args) {
	  //   //console.log('STORE GETTER CALLED');
	  //   return super.get(...args);
	  // }

	  processActionOriginatingFromBackendOnThisDevice({ action, payload }) {
	    // action request from backend! for example: { store: frontend, action: reload }

	    if (action == 'load' || action == 'reload') {
	      const view = payload; //action.split(':')[1];

	      if (view) {
	        const { gui } = this.thisDeviceState;
	        if (!gui || !gui.views || !Object.keys(gui.views).find(v => v == view)) {
	          console.log(`unknown view: ${view}, cannot show/reload it!`);
	          return;
	        }
	      }

	      if (action.startsWith('load')) {
	        this.switchView(view);
	        return;
	      }

	      const currentStore = this.currentStore();

	      let deviceName;
	      const { device } = currentStore.get();
	      if (device) {
	        // not sure when this happens... but it was a notice once on TV (cannot read property deviceName of undefined)
	        // so we check if device was present in currentStore....
	        deviceName = device.deviceName;
	      }

	      reloadView(view || this.get().view, currentStore.ip, currentStore.port, deviceName, this.meta.activeStoreKey); // if view is null (we only passed on "reload", then it will reload home)
	      // we cannot do that here!! :: has to be actual reload!! not sure how to switch back to correct store!! maybe save info!!
	      //this.set({ view }); // keeps current store ... reloadView resets everyting and connects to localhost!
	    }

	    if (action == 'switch') {
	      const deviceNameOrIp = payload; // action.split(':')[1];

	      if (deviceNameOrIp.indexOf('.') > -1 || !deviceNameOrIp) {
	        this.switchByDeviceNameOrIp({ ip: deviceNameOrIp }); // if ip is null (we only passed on "reload", then it will switch to this device)
	      } else {
	        this.switchByDeviceNameOrIp({ deviceName: deviceNameOrIp });
	      }
	    }
	  }

	  filterNearbyDevices(nearbyDevices) {
	    return nearbyDevices.filter(({ hasGui }) => hasGui);
	  }

	  // called on every click anywhere in the app (set up in App.html -> document on:click)
	  guiEngaged() {
	    this.guiIdleSeconds = 0;
	  }

	  setWallpaper(wallpaper) {
	    if (this.get().currentWallpaper != wallpaper) {
	      this.set({ currentWallpaper: wallpaper });
	      util.setWallpaper(wallpaper);
	    }
	  }
	}

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/Escape.html generated by Svelte v2.16.1 */



	var methods$4 = {
	  handleKeypress(event) {
	    if(util.isInputElementActive()) {
	      return
	    }

	    if(event.key && !event.altKey && !event.metaKey && !event.shiftKey) {
	      if(event.key == 'Escape' || event.key == 'h') {
	        this.escape();
	      }
	    }
	  },
	  escape() {
	    if(this.get().atRPi) {
	      // visual notification (especially important on touch) that command was given
	      this.set({ touchPressed: 'escape' });
	      setTimeout(() => { this.fire('escape'); this.set({ touchPressed: undefined }); }, 0); // so that thread has actual time to show the effect
	    } else {
	      this.fire('escape');
	    }
	  }
	};

	function oncreate$4() {
	  this.set({ homeButtonImgInline: img$1 });

	  // adds thisDeviceName, selectedDeviceKey and selectedDeviceName to the component store
	  this.store.entangle(this);
	}
	const file$5 = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/Escape.html";

	function create_main_fragment$5(component, ctx) {
		var if_block_anchor, current;

		function onwindowkeydown(event) {
			component.handleKeypress(event);	}
		window.addEventListener("keydown", onwindowkeydown);

		var if_block = (ctx.loaded && ctx.$connected) && create_if_block$5(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded && ctx.$connected) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$5(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				window.removeEventListener("keydown", onwindowkeydown);

				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (3:0) {#if loaded && $connected}
	function create_if_block$5(component, ctx) {
		var div, current;

		var if_block = (ctx.homeButtonImgInline) && create_if_block_1$4(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.id = "top_icons";
				div.className = "svelte-1ig0od5";
				toggleClass(div, "touch_pressed", ctx.touchPressed == 'escape');
				addLoc(div, file$5, 4, 2, 83);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.homeButtonImgInline) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$4(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(div, null);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}

				if (changed.touchPressed) {
					toggleClass(div, "touch_pressed", ctx.touchPressed == 'escape');
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (6:4) {#if homeButtonImgInline}
	function create_if_block_1$4(component, ctx) {
		var div, img, text, current;

		function click_handler(event) {
			component.escape();
		}

		var peerlist_initial_data = { showPeerOnlyIfDisconnected: true };
		var peerlist = new PeerList({
			root: component.root,
			store: component.store,
			data: peerlist_initial_data
		});

		return {
			c: function create() {
				div = createElement("div");
				img = createElement("img");
				text = createText("\n\n      ");
				peerlist._fragment.c();
				addListener(img, "click", click_handler);
				img.src = ctx.homeButtonImgInline;
				img.alt = "home";
				img.className = "svelte-1ig0od5";
				addLoc(img, file$5, 7, 8, 285);
				div.className = "escape svelte-1ig0od5";
				toggleClass(div, "touch_pressed", ctx.touchPressed == 'escape');
				toggleClass(div, "nonRPi", !ctx.atRPi);
				addLoc(div, file$5, 6, 6, 187);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, img);
				insert(target, text, anchor);
				peerlist._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (!current || changed.homeButtonImgInline) {
					img.src = ctx.homeButtonImgInline;
				}

				if (changed.touchPressed) {
					toggleClass(div, "touch_pressed", ctx.touchPressed == 'escape');
				}

				if (changed.atRPi) {
					toggleClass(div, "nonRPi", !ctx.atRPi);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (peerlist) peerlist._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(img, "click", click_handler);
				if (detach) {
					detachNode(text);
				}

				peerlist.destroy(detach);
			}
		};
	}

	function Escape(options) {
		this._debugName = '<Escape>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Escape> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected"]), options.data);
		this.store._add(this, ["connected"]);
		if (!('loaded' in this._state)) console.warn("<Escape> was created without expected data property 'loaded'");
		if (!('$connected' in this._state)) console.warn("<Escape> was created without expected data property '$connected'");
		if (!('touchPressed' in this._state)) console.warn("<Escape> was created without expected data property 'touchPressed'");
		if (!('homeButtonImgInline' in this._state)) console.warn("<Escape> was created without expected data property 'homeButtonImgInline'");
		if (!('atRPi' in this._state)) console.warn("<Escape> was created without expected data property 'atRPi'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$5(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$4.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Escape.prototype, protoDev);
	assign(Escape.prototype, methods$4);

	Escape.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/VolumeWidget.html generated by Svelte v2.16.1 */

	var methods$5 = {
	  action(action) {
	    this.store.signal('action', { action, scope: 'player' });
	  },
	  pause() {
	    this.action('pause');
	  },
	  volumeUp() {
	    this.action('volume_up');
	  },
	  volumeDown() {
	    this.action('volume_down');
	  }
	};

	function oncreate$5() {}
	const file$6 = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/VolumeWidget.html";

	function create_main_fragment$6(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$player && ctx.$player.paused == false && ctx.$player.currentMedia && ctx.$player.currentMedia.song) && create_if_block$6(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$player && ctx.$player.paused == false && ctx.$player.currentMedia && ctx.$player.currentMedia.song) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$6(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $player && $player.paused == false && $player.currentMedia && $player.currentMedia.song}
	function create_if_block$6(component, ctx) {
		var div2, div0, a0, text1, div1, a1, text3, text4_value = ctx.$player.volume, text4, text5, a2;

		function click_handler(event) {
			event.preventDefault();
			event.stopPropagation();
			component.pause();
		}

		function click_handler_1(event) {
			event.preventDefault();
			event.stopPropagation();
			component.volumeDown();
		}

		function click_handler_2(event) {
			event.preventDefault();
			event.stopPropagation();
			component.volumeUp();
		}

		return {
			c: function create() {
				div2 = createElement("div");
				div0 = createElement("div");
				a0 = createElement("a");
				a0.textContent = "✖";
				text1 = createText("\n    ");
				div1 = createElement("div");
				a1 = createElement("a");
				a1.textContent = "▼";
				text3 = createText("\n      ");
				text4 = createText(text4_value);
				text5 = createText("\n      ");
				a2 = createElement("a");
				a2.textContent = "▲";
				addListener(a0, "click", click_handler);
				a0.href = "#";
				a0.className = "svelte-g6kxch";
				addLoc(a0, file$6, 3, 6, 151);
				div0.className = "pause svelte-g6kxch";
				addLoc(div0, file$6, 2, 4, 125);
				addListener(a1, "click", click_handler_1);
				a1.href = "#";
				a1.className = "volume_down svelte-g6kxch";
				addLoc(a1, file$6, 6, 6, 261);
				addListener(a2, "click", click_handler_2);
				a2.href = "#";
				a2.className = "volume_up svelte-g6kxch";
				addLoc(a2, file$6, 8, 6, 383);
				div1.className = "volume svelte-g6kxch";
				addLoc(div1, file$6, 5, 4, 234);
				div2.id = "play_controls";
				div2.className = "svelte-g6kxch";
				addLoc(div2, file$6, 1, 2, 96);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div0, a0);
				append(div2, text1);
				append(div2, div1);
				append(div1, a1);
				append(div1, text3);
				append(div1, text4);
				append(div1, text5);
				append(div1, a2);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text4_value !== (text4_value = ctx.$player.volume)) {
					setData(text4, text4_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}

				removeListener(a0, "click", click_handler);
				removeListener(a1, "click", click_handler_1);
				removeListener(a2, "click", click_handler_2);
			}
		};
	}

	function VolumeWidget(options) {
		this._debugName = '<VolumeWidget>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<VolumeWidget> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["player"]), options.data);
		this.store._add(this, ["player"]);
		if (!('$player' in this._state)) console.warn("<VolumeWidget> was created without expected data property '$player'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$6(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$5.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(VolumeWidget.prototype, protoDev);
	assign(VolumeWidget.prototype, methods$5);

	VolumeWidget.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/ActionBar.html generated by Svelte v2.16.1 */



	var methods$6 = {
	  handleKeypress(event) {
	    if(util.isInputElementActive()) {
	      return
	    }

	    if(event.key && !event.altKey && !event.metaKey && !event.shiftKey) {
	      if(event.keyCode == 9) {
	        event.preventDefault();
	        this.store.switchToggle();
	      }
	      if(event.key == 't') {
	        this.store.switch();
	      }
	      if(event.key == 'f') {
	        console.log("implement device filter / find (in nearby list or just in the middle of screen)!!");
	      }
	      if(event.key == 'p') {
	        this.select('player');
	      }
	      if(event.key == 'o') {
	        this.select('clock');
	      }
	      if(event.key == 'd') {
	        this.select('device');
	      }
	    }
	  },
	  select(view) {
	    this.fire('select', { view });
	  }
	};

	function oncreate$6() {
	  // adds thisDeviceName, selectedDeviceKey and selectedDeviceName to the component store
	  this.store.entangle(this);

	  this.store.set({ nearbyDevicesMenuVisible: true });
	}
	const file$7 = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/ActionBar.html";

	function create_main_fragment$7(component, ctx) {
		var if_block_anchor, current;

		function onwindowkeydown(event) {
			component.handleKeypress(event);	}
		window.addEventListener("keydown", onwindowkeydown);

		var if_block = (ctx.loaded) && create_if_block$7(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$7(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				window.removeEventListener("keydown", onwindowkeydown);

				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (3:0) {#if loaded}
	function create_if_block$7(component, ctx) {
		var text, if_block_anchor, current;

		var connectionindicator = new ConnectionIndicator({
			root: component.root,
			store: component.store
		});

		connectionindicator.on("escape", function(event) {
			component.select('home');
		});

		var if_block = (ctx.$connected) && create_if_block_1$5(component, ctx);

		return {
			c: function create() {
				connectionindicator._fragment.c();
				text = createText("\n\n  ");
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				connectionindicator._mount(target, anchor);
				insert(target, text, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$connected) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$5(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 2);

				if (connectionindicator) connectionindicator._fragment.o(outrocallback);

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				connectionindicator.destroy(detach);
				if (detach) {
					detachNode(text);
				}

				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (7:2) {#if $connected}
	function create_if_block_1$5(component, ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block_2$3,
			create_else_block$1
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.$view == 'home') return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index !== previous_block_index) {
					if_block.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block.c();
					}
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (16:4) {:else}
	function create_else_block$1(component, ctx) {
		var current;

		var escape = new Escape({
			root: component.root,
			store: component.store
		});

		escape.on("escape", function(event) {
			component.select('home');
		});

		return {
			c: function create() {
				escape._fragment.c();
			},

			m: function mount(target, anchor) {
				escape._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (escape) escape._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				escape.destroy(detach);
			}
		};
	}

	// (9:4) {#if $view == 'home'}
	function create_if_block_2$3(component, ctx) {
		var div, text, current;

		var volumewidget = new VolumeWidget({
			root: component.root,
			store: component.store
		});

		var peerlist = new PeerList({
			root: component.root,
			store: component.store
		});

		var tilebar = new TileBar({
			root: component.root,
			store: component.store,
			slots: { default: createFragment() }
		});

		tilebar.on("select", function(event) {
			component.select(event.view);
		});

		return {
			c: function create() {
				div = createElement("div");
				volumewidget._fragment.c();
				text = createText("\n          ");
				peerlist._fragment.c();
				tilebar._fragment.c();
				div.className = "selector svelte-12e3beu";
				addLoc(div, file$7, 9, 6, 173);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				volumewidget._mount(tilebar._slotted.default, null);
				append(tilebar._slotted.default, text);
				peerlist._mount(tilebar._slotted.default, null);
				tilebar._mount(div, null);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 3);

				if (volumewidget) volumewidget._fragment.o(outrocallback);
				if (peerlist) peerlist._fragment.o(outrocallback);
				if (tilebar) tilebar._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				volumewidget.destroy();
				peerlist.destroy();
				tilebar.destroy();
			}
		};
	}

	function ActionBar(options) {
		this._debugName = '<ActionBar>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<ActionBar> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","view"]), options.data);
		this.store._add(this, ["connected","view"]);
		if (!('loaded' in this._state)) console.warn("<ActionBar> was created without expected data property 'loaded'");
		if (!('$connected' in this._state)) console.warn("<ActionBar> was created without expected data property '$connected'");
		if (!('$view' in this._state)) console.warn("<ActionBar> was created without expected data property '$view'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$7(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$6.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(ActionBar.prototype, protoDev);
	assign(ActionBar.prototype, methods$6);

	ActionBar.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/Time.html generated by Svelte v2.16.1 */

	const file$8 = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/Time.html";

	function create_main_fragment$8(component, ctx) {
		var div, text_value = ctx.time || '', text, current;

		return {
			c: function create() {
				div = createElement("div");
				text = createText(text_value);
				div.id = "time";
				addLoc(div, file$8, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((changed.time) && text_value !== (text_value = ctx.time || '')) {
					setData(text, text_value);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function Time(options) {
		this._debugName = '<Time>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({}, options.data);
		if (!('time' in this._state)) console.warn("<Time> was created without expected data property 'time'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$8(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}

		this._intro = true;
	}

	assign(Time.prototype, protoDev);

	Time.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/Calendar.html generated by Svelte v2.16.1 */

	function oncreate$7() {
	  this.store.entangle(this);
	}
	const file$9 = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/Calendar.html";

	function create_main_fragment$9(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$connected && ctx.holiday) && create_if_block$8(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$connected && ctx.holiday) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$8(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $connected && holiday}
	function create_if_block$8(component, ctx) {
		var div2, div1, div0, span, text;

		return {
			c: function create() {
				div2 = createElement("div");
				div1 = createElement("div");
				div0 = createElement("div");
				span = createElement("span");
				text = createText(ctx.holiday);
				span.className = "svelte-17pmi5h";
				addLoc(span, file$9, 4, 24, 136);
				div0.id = "today";
				div0.className = "svelte-17pmi5h";
				addLoc(div0, file$9, 4, 8, 120);
				div1.id = "calendar";
				div1.className = "svelte-17pmi5h";
				addLoc(div1, file$9, 3, 4, 92);
				div2.id = "calendar_wrapper";
				div2.className = "svelte-17pmi5h";
				toggleClass(div2, "main", ctx.$view == 'home');
				addLoc(div2, file$9, 2, 2, 31);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				append(div1, div0);
				append(div0, span);
				append(div0, text);
			},

			p: function update(changed, ctx) {
				if (changed.holiday) {
					setData(text, ctx.holiday);
				}

				if (changed.$view) {
					toggleClass(div2, "main", ctx.$view == 'home');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}
			}
		};
	}

	function Calendar(options) {
		this._debugName = '<Calendar>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Calendar> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","view"]), options.data);
		this.store._add(this, ["connected","view"]);
		if (!('$connected' in this._state)) console.warn("<Calendar> was created without expected data property '$connected'");
		if (!('holiday' in this._state)) console.warn("<Calendar> was created without expected data property 'holiday'");
		if (!('$view' in this._state)) console.warn("<Calendar> was created without expected data property '$view'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$9(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$7.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Calendar.prototype, protoDev);

	Calendar.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/TimeAndDate.html generated by Svelte v2.16.1 */



	function oncreate$8() {
	  this.store.entangle(this);

	  // doing this in oncreate -- we have to be careful
	  // elements that we're manipulating have to be permanent... we cannot remove and re-add them based on some criteria (for example $connected)
	  const el = document.getElementById("clock");
	  if(el && el.offsetWidth <= 300) {
	    document.getElementById("time").style.fontSize = "4.5em";
	    document.getElementById("date").style.fontSize = "2.5em";
	    document.getElementById("date").style.marginTop = "5px";
	  }
	}
	const file$a = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/TimeAndDate.html";

	function create_main_fragment$a(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.loaded && ctx.$thisDeviceState && ctx.$thisDeviceState.time) && create_if_block$9(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded && ctx.$thisDeviceState && ctx.$thisDeviceState.time) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$9(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if loaded && $thisDeviceState && $thisDeviceState.time}
	function create_if_block$9(component, ctx) {
		var div2, div0, current_block_type_index, if_block0, text0, div1, text1, text2, current;

		var if_block_creators = [
			create_if_block_4$3,
			create_if_block_5$3,
			create_else_block$2
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.$thisDeviceState.connected && !ctx.$thisDeviceState.device.serverMode) return 0;
			if (ctx._demoTime) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		var if_block1 = (ctx.$thisDeviceState.connected && !ctx.$thisDeviceState.device.serverMode) && create_if_block_3$3(component, ctx);

		var if_block2 = (ctx.$thisDeviceState.connected == false) && create_if_block_2$4(component, ctx);

		var if_block3 = (!ctx.$guiNotifications || (ctx.$guiNotifications && ctx.$guiNotifications.length == 0)) && create_if_block_1$6(component);

		return {
			c: function create() {
				div2 = createElement("div");
				div0 = createElement("div");
				if_block0.c();
				text0 = createText("\n\n    ");
				div1 = createElement("div");
				if (if_block1) if_block1.c();
				text1 = createText("\n\n      ");
				if (if_block2) if_block2.c();
				text2 = createText("\n\n    ");
				if (if_block3) if_block3.c();
				div0.id = "time";
				div0.className = "svelte-9zktqa";
				addLoc(div0, file$a, 4, 4, 83);
				div1.id = "date";
				div1.className = "svelte-9zktqa";
				addLoc(div1, file$a, 16, 4, 427);
				div2.id = "clock";
				div2.className = "svelte-9zktqa";
				addLoc(div2, file$a, 2, 2, 61);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				if_blocks[current_block_type_index].m(div0, null);
				append(div2, text0);
				append(div2, div1);
				if (if_block1) if_block1.m(div1, null);
				append(div1, text1);
				if (if_block2) if_block2.m(div1, null);
				append(div2, text2);
				if (if_block3) if_block3.m(div2, null);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block0.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block0 = if_blocks[current_block_type_index];
					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block0.c();
					}
					if_block0.m(div0, null);
				}

				if (ctx.$thisDeviceState.connected && !ctx.$thisDeviceState.device.serverMode) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_3$3(component, ctx);
						if_block1.c();
						if_block1.m(div1, text1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$thisDeviceState.connected == false) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_2$4(component, ctx);
						if_block2.c();
						if_block2.m(div1, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (!ctx.$guiNotifications || (ctx.$guiNotifications && ctx.$guiNotifications.length == 0)) {
					if (!if_block3) {
						if_block3 = create_if_block_1$6(component);
						if_block3.c();
					}
					if_block3.i(div2, null);
				} else if (if_block3) {
					if_block3.o(function() {
						if_block3.d(1);
						if_block3 = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 2);

				if (if_block0) if_block0.o(outrocallback);
				else outrocallback();

				if (if_block3) if_block3.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}

				if_blocks[current_block_type_index].d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
			}
		};
	}

	// (11:8) {:else}
	function create_else_block$2(component, ctx) {
		var current;

		var time_initial_data = { time: ctx.$localBrowserTime };
		var time = new Time({
			root: component.root,
			store: component.store,
			data: time_initial_data
		});

		return {
			c: function create() {
				time._fragment.c();
			},

			m: function mount(target, anchor) {
				time._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var time_changes = {};
				if (changed.$localBrowserTime) time_changes.time = ctx.$localBrowserTime;
				time._set(time_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (time) time._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				time.destroy(detach);
			}
		};
	}

	// (9:8) {#if _demoTime}
	function create_if_block_5$3(component, ctx) {
		var text, current;

		return {
			c: function create() {
				text = createText(ctx._demoTime);
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed._demoTime) {
					setData(text, ctx._demoTime);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (6:6) {#if $thisDeviceState.connected && !$thisDeviceState.device.serverMode}
	function create_if_block_4$3(component, ctx) {
		var current;

		var time_initial_data = { time: ctx.timeDate.time };
		var time = new Time({
			root: component.root,
			store: component.store,
			data: time_initial_data
		});

		return {
			c: function create() {
				time._fragment.c();
			},

			m: function mount(target, anchor) {
				time._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var time_changes = {};
				if (changed.timeDate) time_changes.time = ctx.timeDate.time;
				time._set(time_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (time) time._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				time.destroy(detach);
			}
		};
	}

	// (18:6) {#if $thisDeviceState.connected && !$thisDeviceState.device.serverMode}
	function create_if_block_3$3(component, ctx) {
		var span, text0_value = (ctx.timeDate.dow) || '', text0, text1, text2_value = (ctx.timeDate.date) || '', text2;

		return {
			c: function create() {
				span = createElement("span");
				text0 = createText(text0_value);
				text1 = createText(" ");
				text2 = createText(text2_value);
				span.className = "svelte-9zktqa";
				addLoc(span, file$a, 18, 8, 581);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				append(span, text0);
				insert(target, text1, anchor);
				insert(target, text2, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.timeDate) && text0_value !== (text0_value = (ctx.timeDate.dow) || '')) {
					setData(text0, text0_value);
				}

				if ((changed.timeDate) && text2_value !== (text2_value = (ctx.timeDate.date) || '')) {
					setData(text2, text2_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
					detachNode(text1);
					detachNode(text2);
				}
			}
		};
	}

	// (22:6) {#if $thisDeviceState.connected == false}
	function create_if_block_2$4(component, ctx) {
		var div0, text1, div1, text2, span0, text4, span1, text5_value = ctx.$thisDeviceState.device.deviceName, text5, text6;

		return {
			c: function create() {
				div0 = createElement("div");
				div0.textContent = "disconnected";
				text1 = createText("\n        ");
				div1 = createElement("div");
				text2 = createText("(");
				span0 = createElement("span");
				span0.textContent = "dmt-proc";
				text4 = createText(" on ");
				span1 = createElement("span");
				text5 = createText(text5_value);
				text6 = createText(" is down)");
				div0.className = "disconnected svelte-9zktqa";
				addLoc(div0, file$a, 22, 8, 710);
				span0.className = "svelte-9zktqa";
				addLoc(span0, file$a, 24, 11, 809);
				span1.className = "svelte-9zktqa";
				addLoc(span1, file$a, 24, 36, 834);
				div1.className = "disconnected_explain svelte-9zktqa";
				addLoc(div1, file$a, 23, 8, 763);
			},

			m: function mount(target, anchor) {
				insert(target, div0, anchor);
				insert(target, text1, anchor);
				insert(target, div1, anchor);
				append(div1, text2);
				append(div1, span0);
				append(div1, text4);
				append(div1, span1);
				append(span1, text5);
				append(div1, text6);
			},

			p: function update(changed, ctx) {
				if ((changed.$thisDeviceState) && text5_value !== (text5_value = ctx.$thisDeviceState.device.deviceName)) {
					setData(text5, text5_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div0);
					detachNode(text1);
					detachNode(div1);
				}
			}
		};
	}

	// (30:4) {#if !$guiNotifications || ($guiNotifications && $guiNotifications.length == 0)}
	function create_if_block_1$6(component, ctx) {
		var current;

		var calendar = new Calendar({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				calendar._fragment.c();
			},

			m: function mount(target, anchor) {
				calendar._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (calendar) calendar._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				calendar.destroy(detach);
			}
		};
	}

	function TimeAndDate(options) {
		this._debugName = '<TimeAndDate>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<TimeAndDate> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["thisDeviceState","localBrowserTime","guiNotifications"]), options.data);
		this.store._add(this, ["thisDeviceState","localBrowserTime","guiNotifications"]);
		if (!('loaded' in this._state)) console.warn("<TimeAndDate> was created without expected data property 'loaded'");
		if (!('$thisDeviceState' in this._state)) console.warn("<TimeAndDate> was created without expected data property '$thisDeviceState'");
		if (!('timeDate' in this._state)) console.warn("<TimeAndDate> was created without expected data property 'timeDate'");
		if (!('_demoTime' in this._state)) console.warn("<TimeAndDate> was created without expected data property '_demoTime'");
		if (!('$localBrowserTime' in this._state)) console.warn("<TimeAndDate> was created without expected data property '$localBrowserTime'");
		if (!('$guiNotifications' in this._state)) console.warn("<TimeAndDate> was created without expected data property '$guiNotifications'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$a(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$8.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(TimeAndDate.prototype, protoDev);

	TimeAndDate.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/DeviceInfo.html generated by Svelte v2.16.1 */



	function oncreate$9() {
	  this.store.entangle(this);
	}
	const file$b = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/DeviceInfo.html";

	function create_main_fragment$b(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$device && ctx.viewDef && ctx.viewDef.sidebar) && create_if_block$a(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$device && ctx.viewDef && ctx.viewDef.sidebar) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$a(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $device && viewDef && viewDef.sidebar}
	function create_if_block$a(component, ctx) {
		var div1, div0, text0, text1_value = ctx.$device.deviceName || '', text1, text2, span0, text3_value = ctx.$device.devPanel ? '[DΞV]' : '', text3, text4, span1, text5_value = ctx.$device.apMode ? '(AP)' : '', text5, text6, text7, text8, text9, text10, current;

		var if_block0 = (ctx.$device.connectivityProblem || ctx.$device.localConnectivityProblem) && create_if_block_10$1();

		var if_block1 = (ctx.$device.localConnectivityProblem || ctx.$device.localConnectivityResumed) && create_if_block_7$2(component, ctx);

		var if_block2 = (ctx.$device.connectivityProblem || ctx.$device.connectivityResumed) && create_if_block_4$4(component, ctx);

		var if_block3 = (ctx.viewDef.showIp != 'false') && create_if_block_2$5(component, ctx);

		var if_block4 = (ctx.$device.wifiAP || ctx.$device.apssid) && create_if_block_1$7(component, ctx);

		var timeanddate_initial_data = { timeDate: ctx.timeDate };
		var timeanddate = new TimeAndDate({
			root: component.root,
			store: component.store,
			data: timeanddate_initial_data
		});

		return {
			c: function create() {
				div1 = createElement("div");
				div0 = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText("\n\n      ");
				text1 = createText(text1_value);
				text2 = createText(" ");
				span0 = createElement("span");
				text3 = createText(text3_value);
				text4 = createText(" ");
				span1 = createElement("span");
				text5 = createText(text5_value);
				text6 = createText("\n\n    ");
				if (if_block1) if_block1.c();
				text7 = createText("\n\n    ");
				if (if_block2) if_block2.c();
				text8 = createText("\n\n    ");
				if (if_block3) if_block3.c();
				text9 = createText("\n\n    ");
				if (if_block4) if_block4.c();
				text10 = createText("\n\n  ");
				timeanddate._fragment.c();
				span0.className = "dev svelte-1sb2bme";
				addLoc(span0, file$b, 10, 33, 946);
				span1.className = "ap_mode svelte-1sb2bme";
				addLoc(span1, file$b, 10, 92, 1005);
				div0.className = "deviceName svelte-1sb2bme";
				toggleClass(div0, "connectivity_resumed", ctx.$device.connectivityResumed);
				addLoc(div0, file$b, 5, 4, 732);
				div1.className = "deviceInfo svelte-1sb2bme";
				toggleClass(div1, "foreign", !ctx.homebase);
				toggleClass(div1, "connectivity_problem", ctx.$device.connectivityProblem == true);
				toggleClass(div1, "local_connectivity_problem", ctx.$device.localConnectivityProblem == true);
				addLoc(div1, file$b, 3, 2, 535);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				if (if_block0) if_block0.m(div0, null);
				append(div0, text0);
				append(div0, text1);
				append(div0, text2);
				append(div0, span0);
				append(span0, text3);
				append(div0, text4);
				append(div0, span1);
				append(span1, text5);
				append(div1, text6);
				if (if_block1) if_block1.m(div1, null);
				append(div1, text7);
				if (if_block2) if_block2.m(div1, null);
				append(div1, text8);
				if (if_block3) if_block3.m(div1, null);
				append(div1, text9);
				if (if_block4) if_block4.m(div1, null);
				insert(target, text10, anchor);
				timeanddate._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$device.connectivityProblem || ctx.$device.localConnectivityProblem) {
					if (!if_block0) {
						if_block0 = create_if_block_10$1();
						if_block0.c();
						if_block0.m(div0, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if ((!current || changed.$device) && text1_value !== (text1_value = ctx.$device.deviceName || '')) {
					setData(text1, text1_value);
				}

				if ((!current || changed.$device) && text3_value !== (text3_value = ctx.$device.devPanel ? '[DΞV]' : '')) {
					setData(text3, text3_value);
				}

				if ((!current || changed.$device) && text5_value !== (text5_value = ctx.$device.apMode ? '(AP)' : '')) {
					setData(text5, text5_value);
				}

				if (changed.$device) {
					toggleClass(div0, "connectivity_resumed", ctx.$device.connectivityResumed);
				}

				if (ctx.$device.localConnectivityProblem || ctx.$device.localConnectivityResumed) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_7$2(component, ctx);
						if_block1.c();
						if_block1.m(div1, text7);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$device.connectivityProblem || ctx.$device.connectivityResumed) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_4$4(component, ctx);
						if_block2.c();
						if_block2.m(div1, text8);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (ctx.viewDef.showIp != 'false') {
					if (if_block3) {
						if_block3.p(changed, ctx);
					} else {
						if_block3 = create_if_block_2$5(component, ctx);
						if (if_block3) if_block3.c();
					}

					if_block3.i(div1, text9);
				} else if (if_block3) {
					if_block3.o(function() {
						if_block3.d(1);
						if_block3 = null;
					});
				}

				if (ctx.$device.wifiAP || ctx.$device.apssid) {
					if (if_block4) {
						if_block4.p(changed, ctx);
					} else {
						if_block4 = create_if_block_1$7(component, ctx);
						if_block4.c();
						if_block4.m(div1, null);
					}
				} else if (if_block4) {
					if_block4.d(1);
					if_block4 = null;
				}

				if (changed.homebase) {
					toggleClass(div1, "foreign", !ctx.homebase);
				}

				if (changed.$device) {
					toggleClass(div1, "connectivity_problem", ctx.$device.connectivityProblem == true);
					toggleClass(div1, "local_connectivity_problem", ctx.$device.localConnectivityProblem == true);
				}

				var timeanddate_changes = {};
				if (changed.timeDate) timeanddate_changes.timeDate = ctx.timeDate;
				timeanddate._set(timeanddate_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 2);

				if (if_block3) if_block3.o(outrocallback);
				else outrocallback();

				if (timeanddate) timeanddate._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
				if (if_block4) if_block4.d();
				if (detach) {
					detachNode(text10);
				}

				timeanddate.destroy(detach);
			}
		};
	}

	// (7:6) {#if $device.connectivityProblem || $device.localConnectivityProblem}
	function create_if_block_10$1(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("✖");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (14:4) {#if $device.localConnectivityProblem || $device.localConnectivityResumed}
	function create_if_block_7$2(component, ctx) {
		var div;

		function select_block_type(ctx) {
			if (ctx.$device.localConnectivityProblem) return create_if_block_8$2;
			if (ctx.$device.localConnectivityResumed) return create_if_block_9$1;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type && current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.className = "deviceConnectivityStatus svelte-1sb2bme";
				toggleClass(div, "local_connectivity_problem", ctx.$device.localConnectivityProblem);
				toggleClass(div, "local_connectivity_resumed", ctx.$device.localConnectivityResumed);
				addLoc(div, file$b, 14, 6, 1162);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type !== (current_block_type = select_block_type(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(component, ctx);
					if (if_block) if_block.c();
					if (if_block) if_block.m(div, null);
				}

				if (changed.$device) {
					toggleClass(div, "local_connectivity_problem", ctx.$device.localConnectivityProblem);
					toggleClass(div, "local_connectivity_resumed", ctx.$device.localConnectivityResumed);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (19:50) 
	function create_if_block_9$1(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Router connection resumed");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (17:8) {#if $device.localConnectivityProblem}
	function create_if_block_8$2(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Router unreachable");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (25:4) {#if $device.connectivityProblem || $device.connectivityResumed}
	function create_if_block_4$4(component, ctx) {
		var div;

		function select_block_type_1(ctx) {
			if (ctx.$device.connectivityProblem) return create_if_block_5$4;
			if (ctx.$device.connectivityResumed) return create_if_block_6$2;
		}

		var current_block_type = select_block_type_1(ctx);
		var if_block = current_block_type && current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.className = "deviceConnectivityStatus svelte-1sb2bme";
				toggleClass(div, "connectivity_problem", ctx.$device.connectivityProblem);
				toggleClass(div, "connectivity_resumed", ctx.$device.connectivityResumed);
				addLoc(div, file$b, 25, 6, 1634);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(component, ctx);
					if (if_block) if_block.c();
					if (if_block) if_block.m(div, null);
				}

				if (changed.$device) {
					toggleClass(div, "connectivity_problem", ctx.$device.connectivityProblem);
					toggleClass(div, "connectivity_resumed", ctx.$device.connectivityResumed);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (30:45) 
	function create_if_block_6$2(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Internet connection resumed");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (28:8) {#if $device.connectivityProblem}
	function create_if_block_5$4(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Internet unreachable");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (36:4) {#if viewDef.showIp != 'false'}
	function create_if_block_2$5(component, ctx) {
		var div, text0_value = ctx.$device.ip || '', text0, text1, if_block_anchor, current;

		var if_block = (ctx.$device.apMode && ctx.$device.apInfo) && create_if_block_3$4(component);

		return {
			c: function create() {
				div = createElement("div");
				text0 = createText(text0_value);
				text1 = createText("\n\n      ");
				if (if_block) if_block.c();
				if_block_anchor = createComment();
				div.className = "device_ip svelte-1sb2bme";
				addLoc(div, file$b, 37, 6, 2046);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text0);
				insert(target, text1, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((!current || changed.$device) && text0_value !== (text0_value = ctx.$device.ip || '')) {
					setData(text0, text0_value);
				}

				if (ctx.$device.apMode && ctx.$device.apInfo) {
					if (!if_block) {
						if_block = create_if_block_3$4(component);
						if_block.c();
					}
					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
					detachNode(text1);
				}

				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (40:6) {#if $device.apMode && $device.apInfo}
	function create_if_block_3$4(component, ctx) {
		var div, current;

		var apwificredentials = new ApWifiCredentials({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				div = createElement("div");
				apwificredentials._fragment.c();
				div.className = "ap_wifi_credentials svelte-1sb2bme";
				addLoc(div, file$b, 40, 8, 2148);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				apwificredentials._mount(div, null);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (apwificredentials) apwificredentials._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				apwificredentials.destroy();
			}
		};
	}

	// (48:4) {#if $device.wifiAP || $device.apssid}
	function create_if_block_1$7(component, ctx) {
		var div, text_value = ctx.$device.wifiAP || ctx.$device.apssid, text;

		return {
			c: function create() {
				div = createElement("div");
				text = createText(text_value);
				div.className = "wifi_ap svelte-1sb2bme";
				addLoc(div, file$b, 48, 6, 2302);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$device) && text_value !== (text_value = ctx.$device.wifiAP || ctx.$device.apssid)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function DeviceInfo(options) {
		this._debugName = '<DeviceInfo>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<DeviceInfo> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["device"]), options.data);
		this.store._add(this, ["device"]);
		if (!('$device' in this._state)) console.warn("<DeviceInfo> was created without expected data property '$device'");
		if (!('viewDef' in this._state)) console.warn("<DeviceInfo> was created without expected data property 'viewDef'");
		if (!('homebase' in this._state)) console.warn("<DeviceInfo> was created without expected data property 'homebase'");
		if (!('timeDate' in this._state)) console.warn("<DeviceInfo> was created without expected data property 'timeDate'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$b(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$9.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(DeviceInfo.prototype, protoDev);

	DeviceInfo.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/dynamics/src/Notifications.html generated by Svelte v2.16.1 */

	// disabled transitions for now because they were causing a big issue for some reason (mixup of 'views' -- home component rendered on top of player and others... ')
	// import { fade, fly } from 'svelte-transitions';

	function styles(el) {
		return getStyles(el);
	}

	const getStyles = ({ color = 'black', bgColor = 'white' }) => (
`
  color: ${color};
  background-color: ${bgColor};
`
	);

	const file$c = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/dynamics/src/Notifications.html";

	function get_each_context$2(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.notification = list[i];
		return child_ctx;
	}

	function create_main_fragment$c(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$guiNotifications) && create_if_block$b(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$guiNotifications) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$b(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $guiNotifications}
	function create_if_block$b(component, ctx) {
		var div;

		var if_block = (ctx.$device) && create_if_block_1$8(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.id = "notifications";
				div.className = "svelte-2nzizy";
				toggleClass(div, "move_down", ctx.$view == 'home' && !ctx.$connected);
				addLoc(div, file$c, 4, 4, 73);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if (ctx.$device) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$8(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if ((changed.$view || changed.$connected)) {
					toggleClass(div, "move_down", ctx.$view == 'home' && !ctx.$connected);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (6:6) {#if $device}
	function create_if_block_1$8(component, ctx) {
		var each_anchor;

		var each_value = ctx.$guiNotifications.slice().reverse();

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$2(component, get_each_context$2(ctx, each_value, i));
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insert(target, each_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.$guiNotifications) {
					each_value = ctx.$guiNotifications.slice().reverse();

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$2(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$2(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d: function destroy(detach) {
				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	// (10:14) {#if notification.title}
	function create_if_block_5$5(component, ctx) {
		var div, text_value = ctx.notification.title, text;

		return {
			c: function create() {
				div = createElement("div");
				text = createText(text_value);
				div.className = "title svelte-2nzizy";
				addLoc(div, file$c, 10, 16, 361);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$guiNotifications) && text_value !== (text_value = ctx.notification.title)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (20:45) 
	function create_if_block_3$5(component, ctx) {
		var div;

		function select_block_type_1(ctx) {
			if (ctx.notification.relativeTimeAdded) return create_if_block_4$5;
			return create_else_block$3;
		}

		var current_block_type = select_block_type_1(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if_block.c();
				div.className = "time svelte-2nzizy";
				addLoc(div, file$c, 20, 16, 670);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(div, null);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if_block.d();
			}
		};
	}

	// (16:14) {#if notification.replaceTtl}
	function create_if_block_2$6(component, ctx) {
		var div, text_value = ctx.notification.replaceTtl, text;

		return {
			c: function create() {
				div = createElement("div");
				text = createText(text_value);
				div.className = "time svelte-2nzizy";
				addLoc(div, file$c, 16, 16, 522);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$guiNotifications) && text_value !== (text_value = ctx.notification.replaceTtl)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (24:18) {:else}
	function create_else_block$3(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("now");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: noop,

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (22:18) {#if notification.relativeTimeAdded}
	function create_if_block_4$5(component, ctx) {
		var text0_value = ctx.notification.relativeTimeAdded, text0, text1;

		return {
			c: function create() {
				text0 = createText(text0_value);
				text1 = createText(" ago");
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, text1, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$guiNotifications) && text0_value !== (text0_value = ctx.notification.relativeTimeAdded)) {
					setData(text0, text0_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(text1);
				}
			}
		};
	}

	// (8:10) {#each $guiNotifications.slice().reverse() as notification}
	function create_each_block$2(component, ctx) {
		var div, text0, text1_value = ctx.notification.msg, text1, text2, text3, div_style_value;

		var if_block0 = (ctx.notification.title) && create_if_block_5$5(component, ctx);

		function select_block_type(ctx) {
			if (ctx.notification.replaceTtl) return create_if_block_2$6;
			if (!ctx.notification.omitTtl) return create_if_block_3$5;
		}

		var current_block_type = select_block_type(ctx);
		var if_block1 = current_block_type && current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText("\n\n              ");
				text1 = createText(text1_value);
				text2 = createText("\n\n              ");
				if (if_block1) if_block1.c();
				text3 = createText("\n\n            ");
				div.className = "notification svelte-2nzizy";
				div.style.cssText = div_style_value = styles(ctx.notification);
				addLoc(div, file$c, 8, 12, 250);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, text0);
				append(div, text1);
				append(div, text2);
				if (if_block1) if_block1.m(div, null);
				append(div, text3);
			},

			p: function update(changed, ctx) {
				if (ctx.notification.title) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_5$5(component, ctx);
						if_block0.c();
						if_block0.m(div, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if ((changed.$guiNotifications) && text1_value !== (text1_value = ctx.notification.msg)) {
					setData(text1, text1_value);
				}

				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
					if_block1.p(changed, ctx);
				} else {
					if (if_block1) if_block1.d(1);
					if_block1 = current_block_type && current_block_type(component, ctx);
					if (if_block1) if_block1.c();
					if (if_block1) if_block1.m(div, text3);
				}

				if ((changed.$guiNotifications) && div_style_value !== (div_style_value = styles(ctx.notification))) {
					div.style.cssText = div_style_value;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	function Notifications(options) {
		this._debugName = '<Notifications>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Notifications> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["guiNotifications","view","connected","device"]), options.data);
		this.store._add(this, ["guiNotifications","view","connected","device"]);
		if (!('$guiNotifications' in this._state)) console.warn("<Notifications> was created without expected data property '$guiNotifications'");
		if (!('$view' in this._state)) console.warn("<Notifications> was created without expected data property '$view'");
		if (!('$connected' in this._state)) console.warn("<Notifications> was created without expected data property '$connected'");
		if (!('$device' in this._state)) console.warn("<Notifications> was created without expected data property '$device'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$c(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}

		this._intro = true;
	}

	assign(Notifications.prototype, protoDev);

	Notifications.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/TemperatureReading.html generated by Svelte v2.16.1 */

	function styles$1(el) {
		return getStyles$1(el);
	}

	const getStyles$1 = ({ color = 'black', bgColor = 'white' }) => (
	  `
    color: ${color};
    background-color: ${bgColor};
  `
	);

	const file$d = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/TemperatureReading.html";

	function create_main_fragment$d(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.tempData) && create_if_block$c(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.tempData) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$c(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if tempData}
	function create_if_block$c(component, ctx) {
		var div3, text0, div2, div0, span, text1_value = ctx.tempData.tempDirection && ctx.tempData.tempDirection.symbol ? ctx.tempData.tempDirection.symbol : '', text1, text2_value = ctx.tempData.temperature, text2, text3, text4_value = ctx.tempData.tempUnit, text4, div0_style_value, text5, div1, text6_value = ctx.tempData.humidity, text6, text7;

		var if_block = (ctx.tempData.sensorId) && create_if_block_1$9(component, ctx);

		return {
			c: function create() {
				div3 = createElement("div");
				if (if_block) if_block.c();
				text0 = createText("\n\n    ");
				div2 = createElement("div");
				div0 = createElement("div");
				span = createElement("span");
				text1 = createText(text1_value);
				text2 = createText(text2_value);
				text3 = createText("°");
				text4 = createText(text4_value);
				text5 = createText("\n      ");
				div1 = createElement("div");
				text6 = createText(text6_value);
				text7 = createText("%");
				span.className = "direction svelte-w874ux";
				addLoc(span, file$d, 9, 8, 238);
				div0.id = "temp";
				div0.style.cssText = div0_style_value = styles$1(ctx.tempData);
				div0.className = "svelte-w874ux";
				addLoc(div0, file$d, 8, 6, 188);
				div1.id = "humidity";
				div1.className = "svelte-w874ux";
				addLoc(div1, file$d, 11, 6, 425);
				div2.id = "environment";
				div2.className = "svelte-w874ux";
				addLoc(div2, file$d, 7, 4, 159);
				div3.id = "environment_wrapper";
				div3.className = "svelte-w874ux";
				toggleClass(div3, "big", ctx.big);
				addLoc(div3, file$d, 1, 2, 17);
			},

			m: function mount(target, anchor) {
				insert(target, div3, anchor);
				if (if_block) if_block.m(div3, null);
				append(div3, text0);
				append(div3, div2);
				append(div2, div0);
				append(div0, span);
				append(span, text1);
				append(div0, text2);
				append(div0, text3);
				append(div0, text4);
				append(div2, text5);
				append(div2, div1);
				append(div1, text6);
				append(div1, text7);
			},

			p: function update(changed, ctx) {
				if (ctx.tempData.sensorId) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$9(component, ctx);
						if_block.c();
						if_block.m(div3, text0);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if ((changed.tempData) && text1_value !== (text1_value = ctx.tempData.tempDirection && ctx.tempData.tempDirection.symbol ? ctx.tempData.tempDirection.symbol : '')) {
					setData(text1, text1_value);
				}

				if ((changed.tempData) && text2_value !== (text2_value = ctx.tempData.temperature)) {
					setData(text2, text2_value);
				}

				if ((changed.tempData) && text4_value !== (text4_value = ctx.tempData.tempUnit)) {
					setData(text4, text4_value);
				}

				if ((changed.tempData) && div0_style_value !== (div0_style_value = styles$1(ctx.tempData))) {
					div0.style.cssText = div0_style_value;
				}

				if ((changed.tempData) && text6_value !== (text6_value = ctx.tempData.humidity)) {
					setData(text6, text6_value);
				}

				if (changed.big) {
					toggleClass(div3, "big", ctx.big);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div3);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (4:4) {#if tempData.sensorId}
	function create_if_block_1$9(component, ctx) {
		var div, text_value = ctx.tempData.sensorId, text;

		return {
			c: function create() {
				div = createElement("div");
				text = createText(text_value);
				div.className = "title svelte-w874ux";
				addLoc(div, file$d, 4, 6, 99);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
			},

			p: function update(changed, ctx) {
				if ((changed.tempData) && text_value !== (text_value = ctx.tempData.sensorId)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function TemperatureReading(options) {
		this._debugName = '<TemperatureReading>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({}, options.data);
		if (!('tempData' in this._state)) console.warn("<TemperatureReading> was created without expected data property 'tempData'");
		if (!('big' in this._state)) console.warn("<TemperatureReading> was created without expected data property 'big'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$d(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}

		this._intro = true;
	}

	assign(TemperatureReading.prototype, protoDev);

	TemperatureReading.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/Sidebar.html generated by Svelte v2.16.1 */



	var methods$7 = {
	  action(action) {
	    //console.log(`sending: ${action}`);
	    const [ placeId, blindsId, blindsDirection ] = action.split('-');
	    const payload = { placeId, blindsId, blindsDirection, blindsAction: "move" };
	    this.store.signal('action', { action: 'command', scope: 'blinds', payload });
	  },
	  sleepComputer(deviceName) {
	    //console.log(`sending: ${action}`);
	    this.store.signal('action', { action: 'sleep', scope: 'nearbyDevices', payload: deviceName }); // <!-- warning: name of computer is duplicate, see above  -->
	  },
	  sleepingProgram() {
	    //console.log(`sending: ${action}`);
	    this.store.signal('action', { action: 'sleeping_program', scope: 'iot', payload: 'otroska' }); // <!-- warning: name of computer is duplicate, see above  -->
	  }
	};

	function oncreate$a() {
	  this.store.entangle(this);
	}
	const file$e = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/Sidebar.html";

	function get_each_context_1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.tempData = list[i];
		return child_ctx;
	}

	function get_each_context$3(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.tempData = list[i];
		return child_ctx;
	}

	function create_main_fragment$e(component, ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block$d,
			create_else_block$4
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.$device && ctx.viewDef && ctx.viewDef.sidebar) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block.c();
					}
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (71:0) {:else}
	function create_else_block$4(component, ctx) {
		var div1, div0, text, current;

		var notifications = new Notifications({
			root: component.root,
			store: component.store
		});

		var if_block = (ctx.$connected && ctx.environment && (!ctx.$guiNotifications || (ctx.$guiNotifications && ctx.$guiNotifications.length <= 5))) && create_if_block_9$2(component, ctx);

		return {
			c: function create() {
				div1 = createElement("div");
				div0 = createElement("div");
				notifications._fragment.c();
				text = createText("\n\n    ");
				if (if_block) if_block.c();
				div0.className = "notifications svelte-10kw9ls";
				addLoc(div0, file$e, 76, 4, 2704);
				div1.className = "sidebar svelte-10kw9ls";
				addLoc(div1, file$e, 74, 2, 2677);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				notifications._mount(div0, null);
				append(div1, text);
				if (if_block) if_block.m(div1, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$connected && ctx.environment && (!ctx.$guiNotifications || (ctx.$guiNotifications && ctx.$guiNotifications.length <= 5))) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_9$2(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(div1, null);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 2);

				if (notifications) notifications._fragment.o(outrocallback);

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				notifications.destroy();
				if (if_block) if_block.d();
			}
		};
	}

	// (1:0) {#if $device && viewDef && viewDef.sidebar}
	function create_if_block$d(component, ctx) {
		var text0, div0, slot_content_sidebar_bottom = component._slotted.sidebar_bottom, text1, div3, div1, text2, slot_content_sidebar_menu = component._slotted.sidebar_menu, slot_content_sidebar_menu_before, slot_content_sidebar_menu_after, text3, text4, div2, text5, current;

		var if_block0 = (ctx.viewDef.sidebar != 'top-only' && ctx.viewDef.sidebar != 'top-only-transparent') && create_if_block_8$3();

		var deviceinfo = new DeviceInfo({
			root: component.root,
			store: component.store
		});

		var if_block1 = (ctx.$thisDeviceState && ctx.$thisDeviceState.device && (['turbine', 'tablica', 'andreja', 'epanel', 'eclipse'].includes(ctx.$thisDeviceState.device.deviceName))) && create_if_block_2$7(component, ctx);

		var notifications = new Notifications({
			root: component.root,
			store: component.store
		});

		var if_block2 = (ctx.$connected && ctx.environment && (!ctx.$guiNotifications || (ctx.$guiNotifications && ctx.$guiNotifications.length == 0))) && create_if_block_1$a(component, ctx);

		return {
			c: function create() {
				if (if_block0) if_block0.c();
				text0 = createText("\n\n  ");
				div0 = createElement("div");
				text1 = createText("\n\n  ");
				div3 = createElement("div");
				div1 = createElement("div");
				deviceinfo._fragment.c();
				text2 = createText("\n\n    ");
				text3 = createText("\n\n    \n    ");
				if (if_block1) if_block1.c();
				text4 = createText("\n\n    ");
				div2 = createElement("div");
				notifications._fragment.c();
				text5 = createText("\n\n    ");
				if (if_block2) if_block2.c();
				div0.className = "sidebar_bottom svelte-10kw9ls";
				addLoc(div0, file$e, 6, 2, 181);
				div1.className = "sidebar_top_info svelte-10kw9ls";
				toggleClass(div1, "top_only_with_background", (ctx.viewDef.sidebar == 'top-only' || ctx.viewDef.protectVisibility) && ctx.$connected);
				addLoc(div1, file$e, 11, 4, 347);
				div2.className = "notifications svelte-10kw9ls";
				addLoc(div2, file$e, 56, 4, 2294);
				div3.className = "sidebar svelte-10kw9ls";
				addLoc(div3, file$e, 10, 2, 321);
			},

			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, text0, anchor);
				insert(target, div0, anchor);

				if (slot_content_sidebar_bottom) {
					append(div0, slot_content_sidebar_bottom);
				}

				insert(target, text1, anchor);
				insert(target, div3, anchor);
				append(div3, div1);
				deviceinfo._mount(div1, null);
				append(div3, text2);

				if (slot_content_sidebar_menu) {
					append(div3, slot_content_sidebar_menu_before || (slot_content_sidebar_menu_before = createComment()));
					append(div3, slot_content_sidebar_menu);
					append(div3, slot_content_sidebar_menu_after || (slot_content_sidebar_menu_after = createComment()));
				}

				append(div3, text3);
				if (if_block1) if_block1.m(div3, null);
				append(div3, text4);
				append(div3, div2);
				notifications._mount(div2, null);
				append(div3, text5);
				if (if_block2) if_block2.m(div3, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.viewDef.sidebar != 'top-only' && ctx.viewDef.sidebar != 'top-only-transparent') {
					if (!if_block0) {
						if_block0 = create_if_block_8$3();
						if_block0.c();
						if_block0.m(text0.parentNode, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if ((changed.viewDef || changed.$connected)) {
					toggleClass(div1, "top_only_with_background", (ctx.viewDef.sidebar == 'top-only' || ctx.viewDef.protectVisibility) && ctx.$connected);
				}

				if (ctx.$thisDeviceState && ctx.$thisDeviceState.device && (['turbine', 'tablica', 'andreja', 'epanel', 'eclipse'].includes(ctx.$thisDeviceState.device.deviceName))) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_2$7(component, ctx);
						if_block1.c();
						if_block1.m(div3, text4);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$connected && ctx.environment && (!ctx.$guiNotifications || (ctx.$guiNotifications && ctx.$guiNotifications.length == 0))) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_1$a(component, ctx);
						if (if_block2) if_block2.c();
					}

					if_block2.i(div3, null);
				} else if (if_block2) {
					if_block2.o(function() {
						if_block2.d(1);
						if_block2 = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 3);

				if (deviceinfo) deviceinfo._fragment.o(outrocallback);
				if (notifications) notifications._fragment.o(outrocallback);

				if (if_block2) if_block2.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block0) if_block0.d(detach);
				if (detach) {
					detachNode(text0);
					detachNode(div0);
				}

				if (slot_content_sidebar_bottom) {
					reinsertChildren(div0, slot_content_sidebar_bottom);
				}

				if (detach) {
					detachNode(text1);
					detachNode(div3);
				}

				deviceinfo.destroy();

				if (slot_content_sidebar_menu) {
					reinsertBetween(slot_content_sidebar_menu_before, slot_content_sidebar_menu_after, slot_content_sidebar_menu);
					detachNode(slot_content_sidebar_menu_before);
					detachNode(slot_content_sidebar_menu_after);
				}

				if (if_block1) if_block1.d();
				notifications.destroy();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (81:4) {#if $connected && environment && (!$guiNotifications || ($guiNotifications && $guiNotifications.length <= 5))}
	function create_if_block_9$2(component, ctx) {
		var div, current;

		var each_value_1 = ctx.environment.slice(1);

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1(component, get_each_context_1(ctx, each_value_1, i));
		}

		function outroBlock(i, detach, fn) {
			if (each_blocks[i]) {
				each_blocks[i].o(() => {
					if (detach) {
						each_blocks[i].d(detach);
						each_blocks[i] = null;
					}
					if (fn) fn();
				});
			}
		}

		return {
			c: function create() {
				div = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				div.id = "environment_widget";
				addLoc(div, file$e, 81, 6, 2890);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].i(div, null);
				}

				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.environment) {
					each_value_1 = ctx.environment.slice(1);

					for (var i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1(component, child_ctx);
							each_blocks[i].c();
						}
						each_blocks[i].i(div, null);
					}
					for (; i < each_blocks.length; i += 1) outroBlock(i, 1);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				each_blocks = each_blocks.filter(Boolean);
				const countdown = callAfter(outrocallback, each_blocks.length);
				for (let i = 0; i < each_blocks.length; i += 1) outroBlock(i, 0, countdown);

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (83:8) {#each environment.slice(1) as tempData}
	function create_each_block_1(component, ctx) {
		var current;

		var temperaturereading_initial_data = { tempData: ctx.tempData };
		var temperaturereading = new TemperatureReading({
			root: component.root,
			store: component.store,
			data: temperaturereading_initial_data
		});

		return {
			c: function create() {
				temperaturereading._fragment.c();
			},

			m: function mount(target, anchor) {
				temperaturereading._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var temperaturereading_changes = {};
				if (changed.environment) temperaturereading_changes.tempData = ctx.tempData;
				temperaturereading._set(temperaturereading_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (temperaturereading) temperaturereading._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				temperaturereading.destroy(detach);
			}
		};
	}

	// (3:2) {#if viewDef.sidebar != 'top-only' && viewDef.sidebar != 'top-only-transparent'}
	function create_if_block_8$3(component, ctx) {
		var div;

		return {
			c: function create() {
				div = createElement("div");
				div.className = "sidebar_vertical_space svelte-10kw9ls";
				addLoc(div, file$e, 3, 4, 132);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (21:4) {#if $thisDeviceState && $thisDeviceState.device && (['turbine', 'tablica', 'andreja', 'epanel', 'eclipse'].includes($thisDeviceState.device.deviceName))}
	function create_if_block_2$7(component, ctx) {
		var text0, text1, if_block2_anchor;

		var if_block0 = (ctx.$thisDeviceState && ctx.$thisDeviceState.device && ctx.$thisDeviceState.device.network == 'zaboric') && create_if_block_7$3(component);

		var if_block1 = (ctx.$nearbyDevices && ctx.$nearbyDevices.length > 0 && ctx.$nearbyDevices.find(({ deviceName }) => ['andreja', 'eclipse'].includes(deviceName))) && create_if_block_4$6(component, ctx);

		var if_block2 = (ctx.$nearbyDevices && ctx.$nearbyDevices.length > 0 && ctx.$nearbyDevices.find(({ deviceName }) => deviceName == 'otroska')) && create_if_block_3$6(component);

		return {
			c: function create() {
				if (if_block0) if_block0.c();
				text0 = createText("\n\n      ");
				if (if_block1) if_block1.c();
				text1 = createText("\n\n      ");
				if (if_block2) if_block2.c();
				if_block2_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, text0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, text1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.$thisDeviceState && ctx.$thisDeviceState.device && ctx.$thisDeviceState.device.network == 'zaboric') {
					if (!if_block0) {
						if_block0 = create_if_block_7$3(component);
						if_block0.c();
						if_block0.m(text0.parentNode, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.$nearbyDevices && ctx.$nearbyDevices.length > 0 && ctx.$nearbyDevices.find(({ deviceName }) => ['andreja', 'eclipse'].includes(deviceName))) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_4$6(component, ctx);
						if_block1.c();
						if_block1.m(text1.parentNode, text1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$nearbyDevices && ctx.$nearbyDevices.length > 0 && ctx.$nearbyDevices.find(({ deviceName }) => deviceName == 'otroska')) {
					if (!if_block2) {
						if_block2 = create_if_block_3$6(component);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},

			d: function destroy(detach) {
				if (if_block0) if_block0.d(detach);
				if (detach) {
					detachNode(text0);
				}

				if (if_block1) if_block1.d(detach);
				if (detach) {
					detachNode(text1);
				}

				if (if_block2) if_block2.d(detach);
				if (detach) {
					detachNode(if_block2_anchor);
				}
			}
		};
	}

	// (23:6) {#if $thisDeviceState && $thisDeviceState.device && $thisDeviceState.device.network == 'zaboric'}
	function create_if_block_7$3(component, ctx) {
		var div, h2, text1, button0, text3, button1, text5, br, text6, button2, text8, button3;

		function click_handler(event) {
			component.action('ap1-blinds2-up');
		}

		function click_handler_1(event) {
			component.action('ap1-blinds1-up');
		}

		function click_handler_2(event) {
			component.action('ap1-blinds2-down');
		}

		function click_handler_3(event) {
			component.action('ap1-blinds1-down');
		}

		return {
			c: function create() {
				div = createElement("div");
				h2 = createElement("h2");
				h2.textContent = "Rolete";
				text1 = createText("\n          ");
				button0 = createElement("button");
				button0.textContent = "Leva ↑";
				text3 = createText("\n          ");
				button1 = createElement("button");
				button1.textContent = "Desna ↑";
				text5 = createText("\n          ");
				br = createElement("br");
				text6 = createText("\n          ");
				button2 = createElement("button");
				button2.textContent = "Leva ↓";
				text8 = createText("\n          ");
				button3 = createElement("button");
				button3.textContent = "Desna ↓";
				h2.className = "svelte-10kw9ls";
				addLoc(h2, file$e, 24, 10, 939);
				addListener(button0, "click", click_handler);
				button0.className = "svelte-10kw9ls";
				addLoc(button0, file$e, 25, 10, 965);
				addListener(button1, "click", click_handler_1);
				button1.className = "svelte-10kw9ls";
				addLoc(button1, file$e, 26, 10, 1035);
				addLoc(br, file$e, 27, 10, 1106);
				addListener(button2, "click", click_handler_2);
				button2.className = "svelte-10kw9ls";
				addLoc(button2, file$e, 28, 10, 1121);
				addListener(button3, "click", click_handler_3);
				button3.className = "svelte-10kw9ls";
				addLoc(button3, file$e, 29, 10, 1193);
				div.className = "blinds svelte-10kw9ls";
				addLoc(div, file$e, 23, 8, 908);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h2);
				append(div, text1);
				append(div, button0);
				append(div, text3);
				append(div, button1);
				append(div, text5);
				append(div, br);
				append(div, text6);
				append(div, button2);
				append(div, text8);
				append(div, button3);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(button0, "click", click_handler);
				removeListener(button1, "click", click_handler_1);
				removeListener(button2, "click", click_handler_2);
				removeListener(button3, "click", click_handler_3);
			}
		};
	}

	// (34:6) {#if $nearbyDevices && $nearbyDevices.length > 0 && $nearbyDevices.find(({ deviceName }) => ['andreja', 'eclipse'].includes(deviceName))}
	function create_if_block_4$6(component, ctx) {
		var div, h2, text1, text2;

		var if_block0 = (ctx.$nearbyDevices.find(({ deviceName }) => deviceName == 'eclipse')) && create_if_block_6$3(component);

		var if_block1 = (ctx.$nearbyDevices.find(({ deviceName }) => deviceName == 'andreja')) && create_if_block_5$6(component);

		return {
			c: function create() {
				div = createElement("div");
				h2 = createElement("h2");
				h2.textContent = "Ugasni računalnik";
				text1 = createText("\n\n          ");
				if (if_block0) if_block0.c();
				text2 = createText("\n\n          ");
				if (if_block1) if_block1.c();
				h2.className = "svelte-10kw9ls";
				addLoc(h2, file$e, 35, 10, 1533);
				div.className = "family_computer svelte-10kw9ls";
				addLoc(div, file$e, 34, 8, 1493);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h2);
				append(div, text1);
				if (if_block0) if_block0.m(div, null);
				append(div, text2);
				if (if_block1) if_block1.m(div, null);
			},

			p: function update(changed, ctx) {
				if (ctx.$nearbyDevices.find(({ deviceName }) => deviceName == 'eclipse')) {
					if (!if_block0) {
						if_block0 = create_if_block_6$3(component);
						if_block0.c();
						if_block0.m(div, text2);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.$nearbyDevices.find(({ deviceName }) => deviceName == 'andreja')) {
					if (!if_block1) {
						if_block1 = create_if_block_5$6(component);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (38:10) {#if $nearbyDevices.find(({ deviceName }) => deviceName == 'eclipse')}
	function create_if_block_6$3(component, ctx) {
		var button;

		function click_handler(event) {
			component.sleepComputer('eclipse');
		}

		return {
			c: function create() {
				button = createElement("button");
				button.textContent = "■ eclipse";
				addListener(button, "click", click_handler);
				button.className = "svelte-10kw9ls";
				addLoc(button, file$e, 38, 12, 1654);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (42:10) {#if $nearbyDevices.find(({ deviceName }) => deviceName == 'andreja')}
	function create_if_block_5$6(component, ctx) {
		var button;

		function click_handler(event) {
			component.sleepComputer('andreja');
		}

		return {
			c: function create() {
				button = createElement("button");
				button.textContent = "■ andreja";
				addListener(button, "click", click_handler);
				button.className = "svelte-10kw9ls";
				addLoc(button, file$e, 42, 12, 1827);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (48:6) {#if $nearbyDevices && $nearbyDevices.length > 0 && $nearbyDevices.find(({ deviceName }) => deviceName == 'otroska')}
	function create_if_block_3$6(component, ctx) {
		var div, h2, text_1, button;

		function click_handler(event) {
			component.sleepingProgram();
		}

		return {
			c: function create() {
				div = createElement("div");
				h2 = createElement("h2");
				h2.textContent = "Otroška soba";
				text_1 = createText("\n          ");
				button = createElement("button");
				button.textContent = "😴 SPANJE";
				h2.className = "svelte-10kw9ls";
				addLoc(h2, file$e, 49, 10, 2163);
				addListener(button, "click", click_handler);
				button.className = "svelte-10kw9ls";
				addLoc(button, file$e, 50, 10, 2195);
				div.className = "family_computer svelte-10kw9ls";
				addLoc(div, file$e, 48, 8, 2123);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h2);
				append(div, text_1);
				append(div, button);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (61:4) {#if $connected && environment && (!$guiNotifications || ($guiNotifications && $guiNotifications.length == 0))}
	function create_if_block_1$a(component, ctx) {
		var div, current;

		var each_value = ctx.environment;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$3(component, get_each_context$3(ctx, each_value, i));
		}

		function outroBlock(i, detach, fn) {
			if (each_blocks[i]) {
				each_blocks[i].o(() => {
					if (detach) {
						each_blocks[i].d(detach);
						each_blocks[i] = null;
					}
					if (fn) fn();
				});
			}
		}

		return {
			c: function create() {
				div = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				div.id = "environment_widget";
				addLoc(div, file$e, 61, 6, 2480);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].i(div, null);
				}

				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.environment) {
					each_value = ctx.environment;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$3(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$3(component, child_ctx);
							each_blocks[i].c();
						}
						each_blocks[i].i(div, null);
					}
					for (; i < each_blocks.length; i += 1) outroBlock(i, 1);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				each_blocks = each_blocks.filter(Boolean);
				const countdown = callAfter(outrocallback, each_blocks.length);
				for (let i = 0; i < each_blocks.length; i += 1) outroBlock(i, 0, countdown);

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (63:8) {#each environment as tempData}
	function create_each_block$3(component, ctx) {
		var current;

		var temperaturereading_initial_data = { tempData: ctx.tempData };
		var temperaturereading = new TemperatureReading({
			root: component.root,
			store: component.store,
			data: temperaturereading_initial_data
		});

		return {
			c: function create() {
				temperaturereading._fragment.c();
			},

			m: function mount(target, anchor) {
				temperaturereading._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var temperaturereading_changes = {};
				if (changed.environment) temperaturereading_changes.tempData = ctx.tempData;
				temperaturereading._set(temperaturereading_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (temperaturereading) temperaturereading._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				temperaturereading.destroy(detach);
			}
		};
	}

	function Sidebar(options) {
		this._debugName = '<Sidebar>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Sidebar> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["device","connected","thisDeviceState","nearbyDevices","guiNotifications"]), options.data);
		this.store._add(this, ["device","connected","thisDeviceState","nearbyDevices","guiNotifications"]);
		if (!('$device' in this._state)) console.warn("<Sidebar> was created without expected data property '$device'");
		if (!('viewDef' in this._state)) console.warn("<Sidebar> was created without expected data property 'viewDef'");
		if (!('$connected' in this._state)) console.warn("<Sidebar> was created without expected data property '$connected'");
		if (!('$thisDeviceState' in this._state)) console.warn("<Sidebar> was created without expected data property '$thisDeviceState'");
		if (!('$nearbyDevices' in this._state)) console.warn("<Sidebar> was created without expected data property '$nearbyDevices'");
		if (!('environment' in this._state)) console.warn("<Sidebar> was created without expected data property 'environment'");
		if (!('$guiNotifications' in this._state)) console.warn("<Sidebar> was created without expected data property '$guiNotifications'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._slotted = options.slots || {};

		this._fragment = create_main_fragment$e(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$a.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Sidebar.prototype, protoDev);
	assign(Sidebar.prototype, methods$7);

	Sidebar.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/IotActions.html generated by Svelte v2.16.1 */

	var methods$8 = {
	  action(action) {
	    this.store.signal('action', { action, scope: 'light-lab' });
	    // handled in user engine labLight.js
	  }
	};

	function oncreate$b() {
	  this.store.entangle(this);
	}
	const file$f = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/IotActions.html";

	function create_main_fragment$f(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.isDevUser) && create_if_block$e(component);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.isDevUser) {
					if (!if_block) {
						if_block = create_if_block$e(component);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if isDevUser}
	function create_if_block$e(component, ctx) {
		var div2, div0, text_1, div1;

		function click_handler(event) {
			component.action('on');
		}

		function click_handler_1(event) {
			component.action('off');
		}

		return {
			c: function create() {
				div2 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "ON";
				text_1 = createText("\n    ");
				div1 = createElement("div");
				div1.textContent = "OFF";
				addListener(div0, "click", click_handler);
				div0.className = "action svelte-10pk42a";
				addLoc(div0, file$f, 2, 4, 53);
				addListener(div1, "click", click_handler_1);
				div1.className = "action svelte-10pk42a";
				addLoc(div1, file$f, 3, 4, 110);
				div2.id = "iot_actions_wrapper";
				div2.className = "svelte-10pk42a";
				addLoc(div2, file$f, 1, 2, 18);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div2, text_1);
				append(div2, div1);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}

				removeListener(div0, "click", click_handler);
				removeListener(div1, "click", click_handler_1);
			}
		};
	}

	function IotActions(options) {
		this._debugName = '<IotActions>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({}, options.data);
		if (!('isDevUser' in this._state)) console.warn("<IotActions> was created without expected data property 'isDevUser'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$f(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$b.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(IotActions.prototype, protoDev);
	assign(IotActions.prototype, methods$8);

	IotActions.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/home/src/SidebarMenu.html generated by Svelte v2.16.1 */

	function oncreate$c() {

	}
	function create_main_fragment$g(component, ctx) {

		return {
			c: noop,

			m: noop,

			p: noop,

			i: noop,

			o: run,

			d: noop
		};
	}

	function SidebarMenu(options) {
		this._debugName = '<SidebarMenu>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({}, options.data);
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$g(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$c.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(SidebarMenu.prototype, protoDev);

	SidebarMenu.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/device/src/SidebarMenu.html generated by Svelte v2.16.1 */

	var methods$9 = {
	  select(view) {
	    this.set({ deviceView: view, touchInfo: view });
	    setTimeout(() => this.set({ touchInfo: undefined }), 50);

	    setTimeout(() => this.store.fire('select_device_view', { view }), 0);
	    //this.store.fire('select_device_view', { view });
	  }
	};

	function oncreate$d() {
	  this.set({ deviceView: 'device' }); // default, duplicate in Debug.html

	  this.store.entangle(this);
	}
	const file$g = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/device/src/SidebarMenu.html";

	function create_main_fragment$h(component, ctx) {
		var div, h30, text1, button0, text3, button1, text5, h31, text7, button2, text9, button3, text11, button4, text13, h32, text15, button5, text17, current;

		function click_handler(event) {
			component.select('device_log');
		}

		function click_handler_1(event) {
			component.select('frontend_log');
		}

		function click_handler_2(event) {
			component.select('device_state');
		}

		function click_handler_3(event) {
			component.select('time_state');
		}

		function click_handler_4(event) {
			component.select('player_state');
		}

		function click_handler_5(event) {
			component.select('nearby_sensors_state');
		}

		var if_block = (ctx.$connected && ctx.loaded && ctx.$device) && create_if_block$f(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				h30 = createElement("h3");
				h30.textContent = "Logs";
				text1 = createText("\n\n  ");
				button0 = createElement("button");
				button0.textContent = "dmt-proc";
				text3 = createText("\n\n  \n\n  ");
				button1 = createElement("button");
				button1.textContent = "Frontend";
				text5 = createText("\n\n  ");
				h31 = createElement("h3");
				h31.textContent = "Process state";
				text7 = createText("\n\n  ");
				button2 = createElement("button");
				button2.textContent = "Device";
				text9 = createText("\n\n  ");
				button3 = createElement("button");
				button3.textContent = "Time";
				text11 = createText("\n\n  ");
				button4 = createElement("button");
				button4.textContent = "Player";
				text13 = createText("\n\n  ");
				h32 = createElement("h3");
				h32.textContent = "Nearby sensors";
				text15 = createText("\n\n  ");
				button5 = createElement("button");
				button5.textContent = "Sensor data";
				text17 = createText("\n\n  ");
				if (if_block) if_block.c();
				addLoc(h30, file$g, 2, 2, 41);
				addListener(button0, "click", click_handler);
				button0.className = "svelte-1wgl8y8";
				toggleClass(button0, "active", ctx.deviceView == 'device_log');
				toggleClass(button0, "touch_pressed", ctx.touchInfo == 'device_log');
				addLoc(button0, file$g, 4, 2, 58);
				addListener(button1, "click", click_handler_1);
				button1.className = "svelte-1wgl8y8";
				toggleClass(button1, "active", ctx.deviceView == 'frontend_log');
				toggleClass(button1, "touch_pressed", ctx.touchInfo == 'frontend_log');
				addLoc(button1, file$g, 8, 2, 375);
				addLoc(h31, file$g, 10, 2, 532);
				addListener(button2, "click", click_handler_2);
				button2.className = "svelte-1wgl8y8";
				toggleClass(button2, "active", ctx.deviceView == 'device_state');
				toggleClass(button2, "touch_pressed", ctx.touchInfo == 'device_state');
				addLoc(button2, file$g, 12, 2, 558);
				addListener(button3, "click", click_handler_3);
				button3.className = "svelte-1wgl8y8";
				toggleClass(button3, "active", ctx.deviceView == 'time_state');
				toggleClass(button3, "touch_pressed", ctx.touchInfo == 'time_state');
				addLoc(button3, file$g, 14, 2, 713);
				addListener(button4, "click", click_handler_4);
				button4.className = "svelte-1wgl8y8";
				toggleClass(button4, "active", ctx.deviceView == 'player_state');
				toggleClass(button4, "touch_pressed", ctx.touchInfo == 'player_state');
				addLoc(button4, file$g, 16, 2, 860);
				addLoc(h32, file$g, 18, 2, 1015);
				addListener(button5, "click", click_handler_5);
				button5.className = "svelte-1wgl8y8";
				toggleClass(button5, "active", ctx.deviceView == 'nearby_sensors_state');
				toggleClass(button5, "touch_pressed", ctx.touchInfo == 'nearby_sensors_state');
				addLoc(button5, file$g, 20, 2, 1042);
				div.id = "menu";
				div.className = "svelte-1wgl8y8";
				toggleClass(div, "nonRPi", !ctx.atRPi);
				addLoc(div, file$g, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h30);
				append(div, text1);
				append(div, button0);
				append(div, text3);
				append(div, button1);
				append(div, text5);
				append(div, h31);
				append(div, text7);
				append(div, button2);
				append(div, text9);
				append(div, button3);
				append(div, text11);
				append(div, button4);
				append(div, text13);
				append(div, h32);
				append(div, text15);
				append(div, button5);
				append(div, text17);
				if (if_block) if_block.m(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.deviceView) {
					toggleClass(button0, "active", ctx.deviceView == 'device_log');
				}

				if (changed.touchInfo) {
					toggleClass(button0, "touch_pressed", ctx.touchInfo == 'device_log');
				}

				if (changed.deviceView) {
					toggleClass(button1, "active", ctx.deviceView == 'frontend_log');
				}

				if (changed.touchInfo) {
					toggleClass(button1, "touch_pressed", ctx.touchInfo == 'frontend_log');
				}

				if (changed.deviceView) {
					toggleClass(button2, "active", ctx.deviceView == 'device_state');
				}

				if (changed.touchInfo) {
					toggleClass(button2, "touch_pressed", ctx.touchInfo == 'device_state');
				}

				if (changed.deviceView) {
					toggleClass(button3, "active", ctx.deviceView == 'time_state');
				}

				if (changed.touchInfo) {
					toggleClass(button3, "touch_pressed", ctx.touchInfo == 'time_state');
				}

				if (changed.deviceView) {
					toggleClass(button4, "active", ctx.deviceView == 'player_state');
				}

				if (changed.touchInfo) {
					toggleClass(button4, "touch_pressed", ctx.touchInfo == 'player_state');
				}

				if (changed.deviceView) {
					toggleClass(button5, "active", ctx.deviceView == 'nearby_sensors_state');
				}

				if (changed.touchInfo) {
					toggleClass(button5, "touch_pressed", ctx.touchInfo == 'nearby_sensors_state');
				}

				if (ctx.$connected && ctx.loaded && ctx.$device) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$f(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.atRPi) {
					toggleClass(div, "nonRPi", !ctx.atRPi);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(button0, "click", click_handler);
				removeListener(button1, "click", click_handler_1);
				removeListener(button2, "click", click_handler_2);
				removeListener(button3, "click", click_handler_3);
				removeListener(button4, "click", click_handler_4);
				removeListener(button5, "click", click_handler_5);
				if (if_block) if_block.d();
			}
		};
	}

	// (23:2) {#if $connected && loaded && $device}
	function create_if_block$f(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.$device.devMachine || ctx.isRPi) && create_if_block_1$b(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.$device.devMachine || ctx.isRPi) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$b(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (25:4) {#if $device.devMachine || isRPi}
	function create_if_block_1$b(component, ctx) {
		var h3, text_1, button;

		function click_handler(event) {
			component.select('wifi_setup');
		}

		return {
			c: function create() {
				h3 = createElement("h3");
				h3.textContent = "Wifi setup";
				text_1 = createText("\n\n      ");
				button = createElement("button");
				button.textContent = "Wifi setup or reboot";
				addLoc(h3, file$g, 26, 6, 1310);
				addListener(button, "click", click_handler);
				button.className = "svelte-1wgl8y8";
				toggleClass(button, "active", ctx.deviceView == 'wifi_setup');
				toggleClass(button, "touch_pressed", ctx.touchInfo == 'wifi_setup');
				addLoc(button, file$g, 28, 6, 1337);
			},

			m: function mount(target, anchor) {
				insert(target, h3, anchor);
				insert(target, text_1, anchor);
				insert(target, button, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.deviceView) {
					toggleClass(button, "active", ctx.deviceView == 'wifi_setup');
				}

				if (changed.touchInfo) {
					toggleClass(button, "touch_pressed", ctx.touchInfo == 'wifi_setup');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(h3);
					detachNode(text_1);
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	function SidebarMenu$1(options) {
		this._debugName = '<SidebarMenu>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<SidebarMenu> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","device"]), options.data);
		this.store._add(this, ["connected","device"]);
		if (!('atRPi' in this._state)) console.warn("<SidebarMenu> was created without expected data property 'atRPi'");
		if (!('deviceView' in this._state)) console.warn("<SidebarMenu> was created without expected data property 'deviceView'");
		if (!('touchInfo' in this._state)) console.warn("<SidebarMenu> was created without expected data property 'touchInfo'");
		if (!('$connected' in this._state)) console.warn("<SidebarMenu> was created without expected data property '$connected'");
		if (!('loaded' in this._state)) console.warn("<SidebarMenu> was created without expected data property 'loaded'");
		if (!('$device' in this._state)) console.warn("<SidebarMenu> was created without expected data property '$device'");
		if (!('isRPi' in this._state)) console.warn("<SidebarMenu> was created without expected data property 'isRPi'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$h(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$d.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(SidebarMenu$1.prototype, protoDev);
	assign(SidebarMenu$1.prototype, methods$9);

	SidebarMenu$1.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/SidebarMenus.html generated by Svelte v2.16.1 */

	function create_main_fragment$i(component, ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block$g,
			create_if_block_1$c
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.$view == 'home') return 0;
			if (ctx.$view == 'device') return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
		}

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index !== previous_block_index) {
					if (if_block) {
						if_block.o(function() {
							if_blocks[previous_block_index].d(1);
							if_blocks[previous_block_index] = null;
						});
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];
						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
							if_block.c();
						}
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (~current_block_type_index) if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (6:27) 
	function create_if_block_1$c(component, ctx) {
		var current;

		var devicesidebarmenu = new SidebarMenu$1({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				devicesidebarmenu._fragment.c();
			},

			m: function mount(target, anchor) {
				devicesidebarmenu._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (devicesidebarmenu) devicesidebarmenu._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				devicesidebarmenu.destroy(detach);
			}
		};
	}

	// (2:0) {#if $view == 'home'}
	function create_if_block$g(component, ctx) {
		var current;

		var homesidebarmenu = new SidebarMenu({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				homesidebarmenu._fragment.c();
			},

			m: function mount(target, anchor) {
				homesidebarmenu._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (homesidebarmenu) homesidebarmenu._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				homesidebarmenu.destroy(detach);
			}
		};
	}

	function SidebarMenus(options) {
		this._debugName = '<SidebarMenus>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<SidebarMenus> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["view"]), options.data);
		this.store._add(this, ["view"]);
		if (!('$view' in this._state)) console.warn("<SidebarMenus> was created without expected data property '$view'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$i(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(SidebarMenus.prototype, protoDev);

	SidebarMenus.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	const img$2 = 'data:image/png;base64,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';

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/SidebarBottom.html generated by Svelte v2.16.1 */

	function oncreate$e() {
	  this.set({ alienImgInline: img$2 });

	  this.store.entangle(this);
	}
	const file$h = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/SidebarBottom.html";

	function create_main_fragment$j(component, ctx) {
		var text, if_block1_anchor, current;

		var if_block0 = (false && (ctx.$view == 'player' && ctx.$player && ctx.$player.currentMedia)) && create_if_block_1$d(component, ctx);

		var if_block1 = (ctx.alienImgInline && (!ctx.$guiNotifications || ctx.$guiNotifications.length <= 2)) && create_if_block$h(component, ctx);

		return {
			c: function create() {
				if (if_block0) if_block0.c();
				text = createText("\n\n\n\n");
				if (if_block1) if_block1.c();
				if_block1_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, text, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.alienImgInline && (!ctx.$guiNotifications || ctx.$guiNotifications.length <= 2)) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block$h(component, ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block0) if_block0.d(detach);
				if (detach) {
					detachNode(text);
				}

				if (if_block1) if_block1.d(detach);
				if (detach) {
					detachNode(if_block1_anchor);
				}
			}
		};
	}

	// (1:0) {#if false && ($view == 'player' && $player && $player.currentMedia)}
	function create_if_block_1$d(component, ctx) {
		var if_block_anchor;

		function select_block_type(ctx) {
			if (ctx.$player.isStream) return create_if_block_2$8;
			if (ctx.$player.currentMedia.artist) return create_if_block_6$4;
			if (ctx.$playlist) return create_if_block_11$1;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type && current_block_type(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(component, ctx);
					if (if_block) if_block.c();
					if (if_block) if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (53:23) 
	function create_if_block_11$1(component, ctx) {
		var div2, div1, text0, div0, text1_value = ctx.$playlistMetadata.playlistLength, text1, text2;

		var if_block = (ctx.$playlistMetadata.metadataReadCount && ctx.$playlistMetadata.playlistLength != ctx.$playlistMetadata.metadataReadCount) && create_if_block_12$1(component, ctx);

		return {
			c: function create() {
				div2 = createElement("div");
				div1 = createElement("div");
				text0 = createText("Playlist length ");
				div0 = createElement("div");
				text1 = createText(text1_value);
				text2 = createText(" items\n          \n          ");
				if (if_block) if_block.c();
				div0.className = "property svelte-oiqzh8";
				toggleClass(div0, "warning", ctx.$playlistMetadata.playlistLength >= 5000);
				addLoc(div0, file$h, 56, 26, 2143);
				div1.className = "media_info svelte-oiqzh8";
				addLoc(div1, file$h, 54, 8, 2061);
				div2.className = "speech-bubble svelte-oiqzh8";
				addLoc(div2, file$h, 53, 6, 2025);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				append(div1, text0);
				append(div1, div0);
				append(div0, text1);
				append(div0, text2);
				if (if_block) if_block.m(div0, null);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlistMetadata) && text1_value !== (text1_value = ctx.$playlistMetadata.playlistLength)) {
					setData(text1, text1_value);
				}

				if (ctx.$playlistMetadata.metadataReadCount && ctx.$playlistMetadata.playlistLength != ctx.$playlistMetadata.metadataReadCount) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_12$1(component, ctx);
						if_block.c();
						if_block.m(div0, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.$playlistMetadata) {
					toggleClass(div0, "warning", ctx.$playlistMetadata.playlistLength >= 5000);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (27:41) 
	function create_if_block_6$4(component, ctx) {
		var div4, div3, div0, text0_value = ctx.$player.currentMedia.song, text0, text1, div1, text2_value = ctx.$player.currentMedia.artist, text2, text3, div2, text4_value = ctx.$player.currentMedia.album, text4, text5, text6, text7;

		var if_block0 = (ctx.$player.currentMedia.year) && create_if_block_10$2(component, ctx);

		var if_block1 = (ctx.$player.bitrate) && create_if_block_9$3(component, ctx);

		var if_block2 = (ctx.$playlist) && create_if_block_7$4(component, ctx);

		return {
			c: function create() {
				div4 = createElement("div");
				div3 = createElement("div");
				div0 = createElement("div");
				text0 = createText(text0_value);
				text1 = createText(" is a song by\n          ");
				div1 = createElement("div");
				text2 = createText(text2_value);
				text3 = createText("\n          from album ");
				div2 = createElement("div");
				text4 = createText(text4_value);
				text5 = createText("\n          ");
				if (if_block0) if_block0.c();
				text6 = createText("\n          ");
				if (if_block1) if_block1.c();
				text7 = createText("\n          ");
				if (if_block2) if_block2.c();
				div0.className = "property song svelte-oiqzh8";
				addLoc(div0, file$h, 30, 10, 876);
				div1.className = "property artist svelte-oiqzh8";
				addLoc(div1, file$h, 31, 10, 960);
				div2.className = "property svelte-oiqzh8";
				addLoc(div2, file$h, 32, 21, 1046);
				div3.className = "media_info svelte-oiqzh8";
				addLoc(div3, file$h, 29, 8, 841);
				div4.className = "speech-bubble svelte-oiqzh8";
				addLoc(div4, file$h, 27, 6, 804);
			},

			m: function mount(target, anchor) {
				insert(target, div4, anchor);
				append(div4, div3);
				append(div3, div0);
				append(div0, text0);
				append(div3, text1);
				append(div3, div1);
				append(div1, text2);
				append(div3, text3);
				append(div3, div2);
				append(div2, text4);
				append(div3, text5);
				if (if_block0) if_block0.m(div3, null);
				append(div3, text6);
				if (if_block1) if_block1.m(div3, null);
				append(div3, text7);
				if (if_block2) if_block2.m(div3, null);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text0_value !== (text0_value = ctx.$player.currentMedia.song)) {
					setData(text0, text0_value);
				}

				if ((changed.$player) && text2_value !== (text2_value = ctx.$player.currentMedia.artist)) {
					setData(text2, text2_value);
				}

				if ((changed.$player) && text4_value !== (text4_value = ctx.$player.currentMedia.album)) {
					setData(text4, text4_value);
				}

				if (ctx.$player.currentMedia.year) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_10$2(component, ctx);
						if_block0.c();
						if_block0.m(div3, text6);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.$player.bitrate) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_9$3(component, ctx);
						if_block1.c();
						if_block1.m(div3, text7);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$playlist) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_7$4(component, ctx);
						if_block2.c();
						if_block2.m(div3, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div4);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (4:4) {#if $player.isStream}
	function create_if_block_2$8(component, ctx) {
		var div2, div1, text0, div0, text1_value = ctx.$player.currentMedia.song, text1, text2, text3;

		var if_block0 = (!ctx.$player.paused) && create_if_block_5$7();

		var if_block1 = (ctx.$player.bitrate) && create_if_block_4$7(component, ctx);

		var if_block2 = (ctx.$playlist) && create_if_block_3$7(component, ctx);

		return {
			c: function create() {
				div2 = createElement("div");
				div1 = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText("\n          ");
				div0 = createElement("div");
				text1 = createText(text1_value);
				text2 = createText("\n\n          ");
				if (if_block1) if_block1.c();
				text3 = createText("\n\n          ");
				if (if_block2) if_block2.c();
				div0.className = "property svelte-oiqzh8";
				addLoc(div0, file$h, 10, 10, 273);
				div1.className = "media_info svelte-oiqzh8";
				addLoc(div1, file$h, 6, 8, 170);
				div2.className = "speech-bubble svelte-oiqzh8";
				addLoc(div2, file$h, 4, 6, 133);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				if (if_block0) if_block0.m(div1, null);
				append(div1, text0);
				append(div1, div0);
				append(div0, text1);
				append(div1, text2);
				if (if_block1) if_block1.m(div1, null);
				append(div1, text3);
				if (if_block2) if_block2.m(div1, null);
			},

			p: function update(changed, ctx) {
				if (!ctx.$player.paused) {
					if (!if_block0) {
						if_block0 = create_if_block_5$7();
						if_block0.c();
						if_block0.m(div1, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if ((changed.$player) && text1_value !== (text1_value = ctx.$player.currentMedia.song)) {
					setData(text1, text1_value);
				}

				if (ctx.$player.bitrate) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_4$7(component, ctx);
						if_block1.c();
						if_block1.m(div1, text3);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$playlist) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_3$7(component, ctx);
						if_block2.c();
						if_block2.m(div1, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	// (59:10) {#if $playlistMetadata.metadataReadCount && $playlistMetadata.playlistLength != $playlistMetadata.metadataReadCount}
	function create_if_block_12$1(component, ctx) {
		var text0, text1_value = ctx.$playlistMetadata.metadataReadCount, text1;

		return {
			c: function create() {
				text0 = createText("/ ");
				text1 = createText(text1_value);
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, text1, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlistMetadata) && text1_value !== (text1_value = ctx.$playlistMetadata.metadataReadCount)) {
					setData(text1, text1_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(text1);
				}
			}
		};
	}

	// (34:10) {#if $player.currentMedia.year}
	function create_if_block_10$2(component, ctx) {
		var text0, div, text1_value = ctx.$player.currentMedia.year, text1;

		return {
			c: function create() {
				text0 = createText("released ");
				div = createElement("div");
				text1 = createText(text1_value);
				div.className = "property svelte-oiqzh8";
				addLoc(div, file$h, 34, 21, 1166);
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, div, anchor);
				append(div, text1);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text1_value !== (text1_value = ctx.$player.currentMedia.year)) {
					setData(text1, text1_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(div);
				}
			}
		};
	}

	// (37:10) {#if $player.bitrate}
	function create_if_block_9$3(component, ctx) {
		var text0, div, text1_value = ctx.$player.bitrate, text1;

		return {
			c: function create() {
				text0 = createText("bitrate ");
				div = createElement("div");
				text1 = createText(text1_value);
				div.className = "property svelte-oiqzh8";
				addLoc(div, file$h, 37, 20, 1290);
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, div, anchor);
				append(div, text1);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text1_value !== (text1_value = ctx.$player.bitrate)) {
					setData(text1, text1_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(div);
				}
			}
		};
	}

	// (40:10) {#if $playlist}
	function create_if_block_7$4(component, ctx) {
		var br, text0, div, text1_value = ctx.$playlistMetadata.playlistLength, text1, text2;

		var if_block = (ctx.$playlistMetadata.metadataReadCount && ctx.$playlistMetadata.playlistLength != ctx.$playlistMetadata.metadataReadCount) && create_if_block_8$4(component, ctx);

		return {
			c: function create() {
				br = createElement("br");
				text0 = createText("\n            \n            Playlist length ");
				div = createElement("div");
				text1 = createText(text1_value);
				text2 = createText(" items\n            \n            ");
				if (if_block) if_block.c();
				addLoc(br, file$h, 40, 12, 1390);
				div.className = "property svelte-oiqzh8";
				toggleClass(div, "warning", ctx.$playlistMetadata.playlistLength >= 5000);
				addLoc(div, file$h, 42, 28, 1456);
			},

			m: function mount(target, anchor) {
				insert(target, br, anchor);
				insert(target, text0, anchor);
				insert(target, div, anchor);
				append(div, text1);
				append(div, text2);
				if (if_block) if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlistMetadata) && text1_value !== (text1_value = ctx.$playlistMetadata.playlistLength)) {
					setData(text1, text1_value);
				}

				if (ctx.$playlistMetadata.metadataReadCount && ctx.$playlistMetadata.playlistLength != ctx.$playlistMetadata.metadataReadCount) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_8$4(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.$playlistMetadata) {
					toggleClass(div, "warning", ctx.$playlistMetadata.playlistLength >= 5000);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(br);
					detachNode(text0);
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (45:12) {#if $playlistMetadata.metadataReadCount && $playlistMetadata.playlistLength != $playlistMetadata.metadataReadCount}
	function create_if_block_8$4(component, ctx) {
		var text0, text1_value = ctx.$playlistMetadata.metadataReadCount, text1;

		return {
			c: function create() {
				text0 = createText("/ ");
				text1 = createText(text1_value);
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, text1, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlistMetadata) && text1_value !== (text1_value = ctx.$playlistMetadata.metadataReadCount)) {
					setData(text1, text1_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(text1);
				}
			}
		};
	}

	// (8:10) {#if !$player.paused}
	function create_if_block_5$7(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Playing");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (13:10) {#if $player.bitrate}
	function create_if_block_4$7(component, ctx) {
		var br, text0, div, text1_value = ctx.$player.bitrate, text1;

		return {
			c: function create() {
				br = createElement("br");
				text0 = createText("\n            bitrate ");
				div = createElement("div");
				text1 = createText(text1_value);
				addLoc(br, file$h, 13, 12, 374);
				div.className = "property svelte-oiqzh8";
				addLoc(div, file$h, 14, 20, 399);
			},

			m: function mount(target, anchor) {
				insert(target, br, anchor);
				insert(target, text0, anchor);
				insert(target, div, anchor);
				append(div, text1);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text1_value !== (text1_value = ctx.$player.bitrate)) {
					setData(text1, text1_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(br);
					detachNode(text0);
					detachNode(div);
				}
			}
		};
	}

	// (18:10) {#if $playlist}
	function create_if_block_3$7(component, ctx) {
		var br, text0, div, text1, text2_value = ctx.$playlistMetadata.playlistLength, text2, text3;

		return {
			c: function create() {
				br = createElement("br");
				text0 = createText("\n            \n              Non-streaming playlist length ");
				div = createElement("div");
				text1 = createText("(");
				text2 = createText(text2_value);
				text3 = createText(" items)");
				addLoc(br, file$h, 18, 12, 500);
				div.className = "property svelte-oiqzh8";
				toggleClass(div, "warning", ctx.$playlistMetadata.playlistLength >= 5000);
				addLoc(div, file$h, 20, 44, 582);
			},

			m: function mount(target, anchor) {
				insert(target, br, anchor);
				insert(target, text0, anchor);
				insert(target, div, anchor);
				append(div, text1);
				append(div, text2);
				append(div, text3);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlistMetadata) && text2_value !== (text2_value = ctx.$playlistMetadata.playlistLength)) {
					setData(text2, text2_value);
				}

				if (changed.$playlistMetadata) {
					toggleClass(div, "warning", ctx.$playlistMetadata.playlistLength >= 5000);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(br);
					detachNode(text0);
					detachNode(div);
				}
			}
		};
	}

	// (72:0) {#if alienImgInline && (!$guiNotifications || $guiNotifications.length <= 2)}
	function create_if_block$h(component, ctx) {
		var img;

		return {
			c: function create() {
				img = createElement("img");
				img.src = ctx.alienImgInline;
				img.className = "alien svelte-oiqzh8";
				toggleClass(img, "nonRPi", !ctx.atRPi);
				addLoc(img, file$h, 72, 2, 2705);
			},

			m: function mount(target, anchor) {
				insert(target, img, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.alienImgInline) {
					img.src = ctx.alienImgInline;
				}

				if (changed.atRPi) {
					toggleClass(img, "nonRPi", !ctx.atRPi);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(img);
				}
			}
		};
	}

	function SidebarBottom(options) {
		this._debugName = '<SidebarBottom>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<SidebarBottom> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["view","player","playlist","playlistMetadata","guiNotifications"]), options.data);
		this.store._add(this, ["view","player","playlist","playlistMetadata","guiNotifications"]);
		if (!('$view' in this._state)) console.warn("<SidebarBottom> was created without expected data property '$view'");
		if (!('$player' in this._state)) console.warn("<SidebarBottom> was created without expected data property '$player'");
		if (!('$playlist' in this._state)) console.warn("<SidebarBottom> was created without expected data property '$playlist'");
		if (!('$playlistMetadata' in this._state)) console.warn("<SidebarBottom> was created without expected data property '$playlistMetadata'");
		if (!('alienImgInline' in this._state)) console.warn("<SidebarBottom> was created without expected data property 'alienImgInline'");
		if (!('$guiNotifications' in this._state)) console.warn("<SidebarBottom> was created without expected data property '$guiNotifications'");
		if (!('atRPi' in this._state)) console.warn("<SidebarBottom> was created without expected data property 'atRPi'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$j(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$e.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(SidebarBottom.prototype, protoDev);

	SidebarBottom.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/navigation/src/SidebarBottoms.html generated by Svelte v2.16.1 */

	function create_main_fragment$k(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$view == 'player') && create_if_block$i(component);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$view == 'player') {
					if (!if_block) {
						if_block = create_if_block$i(component);
						if_block.c();
					}
					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $view == 'player'}
	function create_if_block$i(component, ctx) {
		var current;

		var playersidebarbottom = new SidebarBottom({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				playersidebarbottom._fragment.c();
			},

			m: function mount(target, anchor) {
				playersidebarbottom._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (playersidebarbottom) playersidebarbottom._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				playersidebarbottom.destroy(detach);
			}
		};
	}

	function SidebarBottoms(options) {
		this._debugName = '<SidebarBottoms>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<SidebarBottoms> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["view"]), options.data);
		this.store._add(this, ["view"]);
		if (!('$view' in this._state)) console.warn("<SidebarBottoms> was created without expected data property '$view'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$k(this, this._state);

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(SidebarBottoms.prototype, protoDev);

	SidebarBottoms.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	const img$3 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAYAAAB5fY51AAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+Gkqr6gAAAYFpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHfK4NRGMc/24iYprhwoSyNq9FQixtl0qilNVOGm+3dL7XN2/tuablVbhUlbvy64C/gVrlWikjJjRvXxA16Pe+22pI9p+c8n/M953k65zlgDWeUrN7ggWwur4X8PudCZNHZ9IKNHhx4GI0qujoRDAaoa5/3WMx4O2DWqn/uX2uNJ3QFLM3C44qq5YWnhQNredXkHeFOJR2NC58JuzW5oPCdqcfK/GpyqszfJmvh0CRY24WdqRqO1bCS1rLC8nJc2UxBqdzHfIk9kZufk9gr3o1OCD8+nMwwxSRehhiT2csAwwzKijr5nlL+LKuSq8isUkRjhRRp8rhFLUj1hMSk6AkZGYpm///2VU+ODJer233Q+GwY733QtA0/W4bxdWQYP8dge4LLXDV/9RBGP0TfqmquA3BswPlVVYvtwsUmdD2qUS1akmzi1mQS3k6hLQIdN9CyVO5ZZZ+TBwivy1ddw94+9Mt5x/IvwaxoDzsejVUAAAAJcEhZcwAALiMAAC4jAXilP3YAACAASURBVHic7L15tG7JVR/2q8sQMxvMfMFiFpMN5AnHgES/llBLLT2EhMYGTBJnrWCzAAPBMbZX4tgxOCywjUPMAi8vg4XxZXQMXEYHDWC9FpjBAiEkoUbjwwGEwjxJ6sofp/bevz3UubfV97vfHc7uvu873zk17KpT9avf3rXP+YBNNtlkk0022WSTTTbZZJNNNtlkk0022WSTTTbZZJNNNtlkk0022WSTTTbZZJNNNtlkk0022WSTTTbZZJNNNtlkk0022WSTTTbZZJNNNtlkk0022WSTTTbZZJNNNtlkk0022WSTTTbZZJNNNtlkk0022WSTTTbZZJNNNtlkk0022WSTTTbZZJNNNtlkk0022WSTHUvbtwKbXD45PDo+APAuAN7thL8/A+APAfzeCX9/eOe+W/18W7HJZZQNsDZxcnh0/HYA/jyAR4a/D4IB0buecbUPAvh9LOD1uwBeC+AV4e/XNlDbZAOsayqHR8fvgQxKjwTwkViY0UWT3wfwSizg9XIYkL3yzn23/nCfim1yfrIB1jWQw6PjBuDjANwN4LEA/jKA99+rUmckrTX03l8H4D+21p7Xe3/enftuvXrfem2yG9kA6wrKAKgPxwJOj8UCVO+7V6XOQQZ4obX2WgDPG3/Pf8Nznnxnz6ptckayAdYVkcOj4w+GMajHAvjg/Wp0PiIgJccABLRscLf2ChiAveD1z37SG/eg6iZnIBtgXVIZLOovAfg8AE/A4nu6NlIB1SwdYCAGAA14CYAfAvBtr3v2k35517pucnayAdYlk8Oj40dgAanPB/BRe1bn3IXMPgUsOZ/SLheWL70Dg3X1cW18/gyA5wL4jtc9+0m/uWv9N3l4sgHWJZDDo+N3B/AMLCB1157VuVByErtiZgXYgO90PIDsLR344baA1/Frn3XvH+9I5U0ehmyAdUHl8Oj47QE8HgtIPRUXM9Rg7xLBqMu5wahW8/WODuCA0g0g+20A34kFvO5/7bPu3eK/LohsgHXB5PDo+OMA/FUAnwvg/faszoWUNVaV0hXApeeXL/UksDQPoLVva8C3vOaZT3zdw9F7k4cvG2BdEDk8Ov5kAH8XwGftW5eLLhGwol9qLY0rQ8CMwEvSyvnW2pKv97cAeG5r7f94zTOf+Ctn26JNTisbYO1ZDo+OPx0LUN2zb10uiyQwIvMupimc7Oa/WnPUe7DiMh/EYi5+9Wue+cSXnlmjNjmVbIC1BxkhCfdgAarH7FmdSyEPyQwkCeEMHqSIYbndRyx+reiwd2Ut17+vtfZVr37GE/7Tw2nbJqeXDbDOUcZbDp6CBagetWd1Lo2cFHOV2NOMOcGzq3gu7hwyy2p6ugSwHwPwVa9+xhN+4m1s4ianlA2wzkHGGxCeBeDvAPj4PatzKSWGKAjo9N4Tc+q9LwxJ8lohVh4CQFGa0nwsdJFjKvMnO/BVAH7s1c94wrazuAPZAGvHcnh0/CQAX49rFom+C1lzpM9MxpSGdg2nYFUEpApwVZHzoQj0jp9urX3xrz79np8+bds2OZ1sgLUjGRHpX48lhmqThyEnmXiaZgJGzsnOYQ4xqDRE0Vfm4Mw0dcC4JOgAvhnA3/3Vp9/zpofc6E1K2QDrjOXw6PgdAXw5gP8VwDvtWZ1LKzMmk8ITUEatL3lhrEjzVPFXFNpQgWPvHQcHB3rM6crIeThf2huB/jcb2nMfePo9D57c8k3WZAOsM5TDo+O7AXwjgI/ety6XXU7zcPMsNMFd94VmZkbXYpBpVXLtSxtlanYuq6OhoQMvag1f+MBn3/MLU4U3OVE2wDoDOTw6/gAAXwfgc/aty1WRCFiJaU2eEwxmWQ5dwGTQU5pKB/kO5FCJNT/acl1rfWsD/k8Af++Bp9/ze6fti01MNsB6GDKe9/tCAP87gHffszpXQk6Kt+LHaqrnBp2JFnxVU7BaCrbDUN+a38oOBECXyqOznmIuAODXGvBlHf27H/jse7bdxIcgG2C9jXJ4dPzfAPgmAJ+4b10uu8yCM6fpl0x6PA1BmKRx52hncGp6nobNwfBomICpbodwC8j+Pw34wld99uO3R31OKRtgPUQZwZ//M4B/CODt9qzOlZJTAdWSsH6oOVxfCxJdMxOds/6079yi920VDRvXJcdSw0j7BwC+4FWf/fhvX238JgA2wHpIcnh0/D5YXjnyxH3rcl0kvctqJcSBMqVnAbWc4NeSc5UZWDGrWA0ARbjea1Bz7aDy+nDID/mXaO1LXvW0z/ijsoBNAGyAdWo5PDp+DIDvAPCB+9blKsvqhA9vVdBr41zlDJ8NcGZWpfl2Kp1OAKnpCds9DNdfCuCZr3ra418+UfvaywZYJ8gwAb8Si2P9YM/qXEk5zfOBa+mAdaBZ821V109iVrFu9bSjMD25zELHiJIN7Q868Ndf9bTP+LbVyq+pbIC1IodHx+8L4NuwvfplZzIDB35lzMwUxOQagxx/jwAisnqNfoHHP2Cttc+ZXfM1Jz8ZFcaO/9Hqf9UavvhXnvoZ24/EkmyANZHDo+O7ABwB+IB963KV5WQ/0fx6dLKrk3zmZI/5TtBret4Bqe0KLvgTTL2RaLXOWZqGX2poz3rlUx/3slOofC1kA6wg480KfxvA38dmAu5EZk7tKdPCCtNZEpXXnWNdzhdxW/L+q5kOqov+YznNrVYCDgSIJHKs8Fs5wCva/oe99y/8lad9xr8ulbpmsgEWyeHR8bsC+C4A9+5bl+siDEj8Shh3nd4mGl6gtxxb4lUfEibXOM2Ju4Kdg1J9Sc5cNIVP8FsJoHkwK0D8mwF80Suf+ri3lMpdE9kAa8gIWfhBAJ+8b12uskR2JeeAExzslalX7AyCr4eyZmzutD4rZVOgEwOdSpZUxGc5lhf6ZbmeWRjp9+8BfM4rn/q4axv6sAEWgMOj4w8B8KO4hj9Mum9ZDcac5UGe+GkXLoLCLKgz6HHS7iA7ypM+hZJlWeRk57prezd5t34SwFNe+dTH/fZKc66sXHvAOjw6/gsAfgRbfNW5y/QVMieA1UnBo2smX/y+5tD3D1KPf1zEeq472IP5+kSXstJ5jNcvAnjiK5/6uF+rLl5ludZO5REM+pPYwGrnEs2vGUAJiOgjMfIK5Ci9G7vyFaV65S8XMWdTma1FXRe9XHYHVkt+h22N04VzUmlQoAfTcWT/CwBe9FH//sevnUVwbQHr8Oj4KVh+POA99q3LdZPZWw8aoOEJcrx8eNCS0AWZ+D1cUxYWHO2VHg4cg3SfmM4tUNRNRamcMpW8ysxBaUdd9eiDhoODCmgBAB8C4EWP/L7nXasfM7mWgHV4dPw/APi/sf38+7nJDBRE8k5a0z99JrBIy85s+S6+LefodkWbKcrfK50W0iSl93SNHfumgznQWQEG4VRvaFRXsKZyIIxRu+a9ATz/kd/3vMeXDbiCcq18WOP3AL8SwFfvW5frJKfySU2eE+R01S7crOTpYzmFTqs7jQ26A5jCGMqYriLWSgueh11wmdMyJvq3hjf3js9/xWc99jtWM10BuTYMa4DVP8EGVhdC2D/UR5xVabZRWudwn+y+iXi3NycpHOwhXx8ZExMzY87YkjAwjX7PsWTssO+9l2Dl30rxEMBqUfodABx99Pc//4tWM14BuTaAheX34r5030pcN8mTfhHdvSefFQNTjBxfQMRPVO/iRoptqoJQT/W6GFeC+MI6BYw2jzjNPlyUvaGyYpaYdFYWAdAEgxmjo+6hxd/wMd///P+ubNwVkWthEh4eHf8NLD+5tckepAzWRAzMNPMqnbOCzASbhSOcIp5q/dEbX0cMroomKQeNgk052TEsIt4pyN3LPIxhgBa3jX1lzD77WwE87eVPeewPlAVdcrnygHV4dHwfgH+7bz2uq0TzJZpqVWR7TOcnpM+PAuhivlNFsoeC5T1X8brThd6uUD0jKActnu/G9qwZ60BVPXtpwJ566o8BPO7lT7n7dlnoJZYrDViHR8f3ADgG8A771uW6yYnmlyWcX+M0kX2FaynSfaJTrCexPBH3HE72K+XIenj7TMqqdiIDaJ0UWc8PWDOja7EzxsmBX/9f73jMy59y9y9NC7+EcmUB6/Do+JMBPB/Au+xbl+sq1ZsWgMCyCmYVfVcxHbAycCc7hyfuVMJAKz6IXTEkDJOMfyHa2lTV0VaoYwZE0Vl/iafoHdcvxRsoGnAHDZ/6y5959+umjb9kciUB6/Do+JEA/iOA9963LtdVZsGh5e4eTTZNS9SijFJHHrzrTGXO9MoYryLMQdBoybMSekAAMwMinFCGx6H1adroH29CAwBe0Tse/fKn3P3G1UIuiVy5XcLDo+MPxPIg8wZWe5DpYzDLxRHdLQGVHpAaCCAoLkujwlGws9VdM9MnvYqG0oufK5fZfXkjtF3CF4rGk3ZLqirw/cQg2mQG5iq0JmV3man2JQLjka3hBz/mB15wJSyNKwVYh0fHfxYLWD1i37pcRzmJ4XQCIRWKS7LJ3VK6KrBTotkZJHkiV88rVlChUJhYYdBDwWzyOA/HZSECsNdreYSoJcLJVVkVPaRpzvQ135YHdDIZ/1IDvudjf+AFl96Xe2UA6/Do+J0A/ACAj9+3LtdVZswhBTrahdJEZN+MTDwGM45fkvOx7uoZwdK3JfopJfEXmwBQCLGYvTZGaxkorIGorBv4vVwJv7VyOz/i1FxHeJ+VlFs2domueCKAb/nYH3jBpZ7zl1r5IN8I4NH7VuI6SmQzbrt+OVGyq2xAQU1Am4Q+bSUxCJP/1h5uNleT7QiyToo2zGYwMwfZ/zXa2T3LMhYYzNhu2G0OdlVO2+iflW4uRdP/RBfqQdPtcwH8rbIzLomse/MuiRweHf+3AL5133pcV3E+orxTxQldCEIqZ6RhsFoboGuBoSeGC/hKYeECPe/ouQa1mM3pPNVHCjvBie4BK1Zd9UzwqDFOab3unry1AXe/7DNv/uSKyhdWLj1gHR4dfyyA/wTgnfety3WUE3ew4vUqDMASu3grzcLpKl/WKXVyE99FsU9CLk4oTxJKeIPYbOb7Qoq36r1bHvTx4xdLwtmOoGDY1BEP6iMC2pUHqe+g4RNfduvmpds5vNQm4eHR8Ttj+dGIDazOUdgEZJOr8hm5a9VO31KgmYrNR6yndFzOym6b6MVpDPiE75iBVzqr1XE0qUvdVRxnxg6p5WsfZpmlM9Nwac5gSeSk8kBu+ComNpuaoO7TctbXkcOG9tyPO37hpZv/l07hIN8A4OP2rcR1lmonTqTHcwRMaT6FUAfJ7/JGs7NiI8GXJXX5XUIPDlxPrD2bY6yPll6W4JKbh8kVwZ+Sciml2zVhXgKg0aQOnv2u7TJ2papK8t7vBfA3S2UvsFxak/Dw6PivAHjuvvW4bnLqZ+AsQXmtMvNcvrryqX+r8lvxxl6uy/usxD0l56SC5CCHgQibdksd83dZsXkmfirz+1mvxNfTMLCaX8r3YTIHo0+NTVOv61sB3PWyWzdflBS+oHIpAevw6PhjAPwMNlNwr3Li84ITIHI7glX+eI6c9amMSX1cpwMZwCFOpTmzsekEGQghZm9mYHAgseaWz452NhHhwyqqTQ02B4FcX1gh+I2oDe0NAD7xl27d9VtTBS+QXDqTcPNb7Vc4ZEC+V2ncd3irha8esKknf2w6CluIzC7UNYuuZ7BSs6izN8spPm13ahC1q8Ii2WnMP5Aa0pUga0AlTnpAQHG0SrpInfYjPecXoUbqBsE4bg0f1Br+9WXxZ10KJYP8M2zBoXuTteDQ+BgMO9mjp4evpyj0wKg0/ykApXwER8y34DQSnZwL6KQ6nIVmE9/pP/SoWBWHo1l7rFAjgfRGBm/8YjEnqcCuDURMLWUZptErcWyteHJr+PL1hl8MuVQm4eHR8ecC+Df71uO6ykMOYZDzMMe1+wWcyryBTVYGtOnvB9Iu3jQkYBxUry8mt8/4Hn1I4yBvbYJ9Tuwcdz8aMZliVUxV1CVU6PxUPZzjN0e4wuDvi//Fa7fH8dbW8JiXPvmu+0uFL4hcGsA6PDr+AAAvB/Du+9blushJPqryB1BDRLv3tZxw3Veu10/SrdLRXD40c0Npjf9xcVITmGkegLKz2y7M/XqxCyoQBoFffU2+LF/rn7e3pwvkY1KXgh0eANrHv/TJn/7HpfIXQC6TSfiPsYHVuQoDQoy1EhMt+rQWn84EZuKDc0MqEyaeixN3Day0KleDzXTn+umj9OFvQgv6GO0DBptS3xhcsdDHY0om6I/Xd1fb0Mdr30CMqC16y9ZB12/WP6HZU6F3bn04LvijO5eCYR0eHT8WwI/vW4/rKtHs8ou8OkdQ7fr5yU+sKvivmNWssZzKvKmsNuf/KfxhoVCfr+yE+LV4w2kwzbLD3dcg7Ei4T9R5xug4Yn5mdFp7vZ9NmjuLmgfwJwA+7qVP/vQHqm7Yt1x4hnV4dPyOAP75vvW4rlL5iNyCTZHnDUhgpYwrAA3EQU/lVLuArAObOVGfCB7mIhpACjGdaGePWQ+VYdfVljL2BI5U98rqeQXAFpruqU6nPB51jB46Rqdrg3PvO2bF9asOAdJmjwAN+a8AfMPH/+BPXEgyc+EBC8CXA/jofStxHWUtit0ma0uAFLCgBLXIZqooectOQDbzWXGeJrtoXi/3vQ+wqHQRBU54gNrVP/XzsWPb94xnVUHVDsatUb63VyOASrrltw9rO5Bv1axpreHe1tpT66v7lQuJoiKHR8ePAPDLAN5p37pcR1kLCHUmXaff7COPchufAEpne9ym4u/ZiZ7fCBGzJbMKAchAJpVeyw8ru4JOfBhbzMPwtoeg+8zYjCbgmsM+Ubqgsrs0KccAvy6Hvr8erX3sLz7pMb9fK7MfuegM659hA6u9SHS2s7DjPb1WpjU/wZlixJ0/Mg25XjHh5DuzqjXGo6ApAMDtsQogvzOd2ubAiuqndrqyQGbgFIy44HA9fTH6I7V585tyVfoQ6rjHcIK52ZSBWrvUP2aqfDDQ/5ek9J7lwjKsw6PjW1jeILrJOcpJoQxAMAcfSpq1kAGq/7R6OWxxjME/k+eve9f89Pm/wa5W+4Ec2+vxViuAVbCm1L5melfOfhfiUTjZQ5OIXRXPLnKdvb8FrX3CLz7pMS8rG7cHuZCANV53/EsAPnTfulwXqUyualdQ0y8J8zkrkGfHNB2bZ6fRqSwrgFUsrcKEddiEmnqrSSoQLazcqIkH2vGNnFnZzOO2kV4xYTdm9RB2BZ3VHk1FAC8E+t2/+KRPr51i5ywX1ST829jA6lzFvTdqmIJTsJqAEDu93SeCuVHU27sYaus61cprovr6ROp3XInZaaZZ9a50ZwJTGpn0fh8itJxN296dv6lRDp+t53LIbpRnF5dssZfte/3jGarW0oXe3LwLaJ+TM+1HLhzDOjw6/kgALwXwjvvW5TrJ7PENIHCX4Igu3D5SYMof6zv5V49PNjl7SOe5SK57yugSI+wOBJQESaHBqW3Zl4sTtpI2JrwsNTicM2debk8AqNrhn8MY4g/FJt1yv/86gEf+4pMe8zvxwnnLRWRYfw8bWJ27nPiOK/E90YBOjmGZBHFnMKSR77YF/zboq2W40h1QJVOwMcDmWpn16MSnAg9aC1QyM6uFCUpZBci4EPyuf0tq36/DLlUQTPg3sq/1oN0uf3+d36o1SxNt2kXerwFfMq3kHOVCMazDo+MPB/BKXEwgvfJSBn3Ssfpc1ME7pHe0gwM99v4Zny/WFaPa3fmgU9I3N6A+z+XG9owMay/uU2Ps1KxwyjuJxXhNWZd8+eS4tXVdfF053fw6qfAmAI/4hXv3G+Zw0YDhK3HxdLqywn6YWeBmMvMoctzl5fgrKk8tKorVmgWhcihFVYa6xlBMXDZ5SH8MVpTeNx+YSu/m+HamYGjD2hLfUj05sZbRCZRBLEkYkYBIdp/pAb8KuYp2F7aXCZPVayEOMVHXPhpX3gvAX6vafZ5yYRjW4dHxBwN4AMCl/3Xaiy68+8bfZ9Hj1a4hM6bKfzVjOdVzglGfmIeKhVRo5qDnHo0Tx13PlNo1cjoZYvjCaX1FdTkV62JW5Rmsa2KhEwvrFXdYYxG+6+ZMjPscrf2/QP/QX7j3MXt7m8NFYjNfgQ2sdipr5taq3yrmhzEmwCZaDBpVphN8XnHJr/xnJesTttBkEgpINe+zGrW1UG8Ln5JXJuzME6Ssj+pj8Wo6D5SxwgmQMXtk1up0IYxbN5GF3eZ7rGZtqthp69rU+NpS6PsD+KtTBc5BLgTDOjw6fj8ArwHwZ/asyrWR0/hjJF0M+PQMRewGc8YHa2vZkZpcn9YpxwjMIM24il0BcReP9clEx9oQQfzEOLDErDyDmjGvOrVrYDi/ABKblGs6SSa7x0tNzSWwc4lfpaK1j18H4CNecu+j31xWvmO5KAzry7CB1bnKqcBKDwLTAjEnoT0TMGrwjnX9rkV7RlX50iRfUxoSp5jtoJnvShhe8O0APhEdZUbXtXL3FtEIPvq1kz9ovBlCgCWyyqhbcx8lqMvvGooO2W8lICslFL+XKB3QDSq5FGXFld+rd3T0P9/RP69Q71xk7wzr8Oj4vQC8FsC77luX6ybMshLpWBI4MNLTfI3SzhhYBK1KD0gaZEDQOusD0gnKPKr3rZeMJZUUr7NfyLojx1kFZsVnGx/Y9ew+slxOt0Az46M4rF/VN5Yv6l8Ab9EhrMtQ41ca8DEvuffRby0r2qFcBIb1xdjA6lxk5h/i+aDMyZwviV25iUd+K1mdG1+DBytv3nmg4nNcXzqTiYmjJhZYUT8ALDFS9n6syFTaIBTd1SVqxs+Cjqgua+1RtmfUEwmsuPiU2QBZ9Ik6uf7r1vZ4Txk4PRn0zHk05yMBPLNu9G5lrwzr8Oj43bCwq/fcpx5XXeIu39oPOuiPRBTsyi3A7LviOsaxsKqTds1m72NHL8AtBSiRX0br9syofH1M1BcLaB20A8tXMBjfn2vR7Fbw1H/l/EikfGodlO0B8z6dsaak3eT63IdFrM/tDOCl6PiEl9z76AdTgTuUfTOsv44NrHYuOQZpMmjjIyMzsKJzYTtpsIaOHsAOyACU9OKELTO1aB/JGz2FRgQuYHAWGGFkl1JW9TbT2ohlkPa8UYlS1D3RQuOjsrvHvrjY3O7qLDRyTNDxZXdUvi5IdUUksOC+ZlRraB+Phs8sldmh7A2wDo+O3x7A39hX/ddJ2BQ8lcxiopDNvip9DPgE5YmgxTrxNFPsTOUHZ7FeykBkAOgnLgdaMhCctp8yOFB6MaEJeRj6GKs6NbRzrzpsW9fFW+/LwUHRjjbsvgzWZjoa+xxnOtXfXCYBvv9pVbkdyD4Z1uMAfOAe678WwkwmvvFAyQkN8IPAmKggM/fioK921+ABSFLIZJoGilJartt2tZpOUqfFsoNV5KXPriXA/ERZn/o5Q/n0b3OwXTgC16YfqR86Fbi0Q8xwBrrlU03SZjFnM+FbYGwqXvTAT1BVMCsUN0JON9HpMZ/4Iy/6sFXFzlj2CVifv8e6r42sAYM62Ml8W1iLBzV33OmHHGKaibM+jvs1BuPNEymva3nCBDiAVK4vl3pdIDGwyBIduypmqeKlFKmBpJ41KiANdaa+crUbDfSCr/xUYv6z5hhpa7GPWRM2RdMtC3kanEU9sodHgc41xOGUNsLZynC2/zq21x/vVNz29yRkoPkMSI+FFNcZjLKzVm0Gl67SKRUP9j3HdF4jY3ZmbJYsRAmE35o34LB0U2c96WRCgMOXupWVtA4bFbEfo05zp39uZFxETC+/IDl9O/e3NaJqT2w26fQqAB/1n5/4aQ8Bat922RfDejo2sNqZCGNwzmPHIixdHP282rP5Yr6ZDHhuQobn17hcACVYNapXNexdzUdJJXXZ2ZLnBcm2Tqu+KEPJTItNQNU3wkgfVyht6euTuLfJwmEOeK+P6aLFVK3xInS0WBwi8a7AfvbqHxdKgf4RAP7yXImzlX0B1mYO7lD4jQdR3ErMu3nNT7Jo7qB3d835Y6hsDkI97ZLbIUBGZwjAFAIMaYNyK9PWhSdUFUuRGbh9MQbj3DYG8UhEqupkIWG2F9PGDYHQnJTaEcUmf2zHZT3iJe5rOXHQDkp3Jus5wOvc5vOKOruR8dNdrznveq+LxHCBags/m0Y1sGnaUEYvrjegjGaPZmllnmazyM7rLyNHm4eA0Vk0YuO4mC16e2gvwGjYRjPf2qli1whRs8UWznBZDm0oSzE11V9HLe+94+CgOSBzyQpzkX1yLdRZ/yCH16lzfy4nfrs1vP/PP+HT/iQpfcayD4b1uXuo89pINAP97heJmCUzE4/KoMI1jcjBGP0MXGv6pDJFr5YnVtrqbyB9w65gCWjBvBtl8A+N8lsY1qRiYIw5+tmdQ5oaI1zK/7pN9KE5fa0poy66l+NwebDcusWIFZttRkpzmawi9XeLBncAq1HwAK4/2ztu5UafvZwrYB0eHTcAf+U867xuUvmuQgIAwGz3kE1A91mVJeUQaMVyZmYps6uFEVSbAsy0aCLr5LZJlDHCv94uKdZF9zEJmUU2AaTiYWztW5vcXcpDzcKY7TlQYqTrvh09gFPyOTV/zGEUdMW1Wx3s1AeNdHKFMghi/vNhsmi0dj7z+rwZ1qOw/ez8mcuMUVVS/cCETf3anFnlH5PrAkprkdXuxFCCdWF9PES0cK3WoMVrCbubsQRWRxCIWJjIwZjxHPRpTNXHdrHy0UlfgSw73A8q4IuFworQe9rlmi9cwYqvNIFzQ7Am2WVROIl8WjVP/qQffdF7n5D6Yct5A9bmbN+BzHYDozhfE+dHNMVgNgM5iEsPbLErWO1SOj3Cp33zDyub8WeJJf6phGWHE/yCQW8SOgyb+KW4pAgeFpCpZ6gFnNDKivoq02r2aE5kVV4nqcFvHiRCSqwoLUTJb9UopQAvq28ctfRrNWlf0ftBTgAAIABJREFUA9DeHmjPwY7l3ADr8Oj4HQHcd171XVdZCxQF2BU0ARJmTNGJXpQ9m5AzHYJFMtfUu1NcfT2cc3nDhM2X19mohV/IGWMgrPuBTlSpLTfBx1EVrRWGI36v1U4UVlm8jdSlsfuRLlF6M02FfTXLRKbiNLatc03S3t0TkvNkWDcB/LlzrO/aSNx5i5HYccL7XbhwPm03of5OTK6aZxW7srrkTw48E0hua51MBhxJr2Z8AQg+IMoU396QHeSZCwFNVdBuCimqIvj1NMlMBIGCbBCsdHelXfP/FLr7S7EfJAezLxkwbCrGANqwD8y1ffIn/ejtD8lKnJ2cJ2A99hzrulaS/FJiknEaOk5WhABVxTh8RVJBOh/n1vTxG0FJBaBlyjDrMvOSQHRRtC6TTBf7JRrqD/1s4XxLk1GZTOGbWzNvTQsqLK4WXE5kV1FnaXbz9eoi5ECzuw/vf8sAy9Du8I7AzQGsMsYxTCDjzfPl0fV35xafnWyAdYllzV9FiZYPOpVCHULw6GqZKxOZo9m5rjgftF5nVrF+pGflB3NMT/4Zf8r6yCEOMaX6tJgsYdczETECBUhYh88vgGgPg3f3XViVmam++BhhLzp12C3zlM3aGiFbwjDYt8X++cp8VLaq+oP09f1Leux0np8w2s9GDo+O3wPAm7D/929dGVlzasd06Vyd0DGoGVDwmqpDteVg0PjqZa67UzoOIkp60cSZvlOd7czoHG5+0q31FTMaZVkQiJCFYRyP8hx4u/7jlkYTqmhDzN4srwEX9R24D3u4ElRwZxZk4roj0EaT2u8+BlAt2tYafg1oH/Rz93zKqkfubZXzApBPP8e6roWcBqxiej1G4e2QCRhZVvjkH/+MupTANdI0Odck4FK9u95yogXbJo8wg8EPlBoMRtUMYjIR8r69ef9kENF6yVRiaawK6BlBsWDZ5GzSfi6/WzkBEMRCz+BC33sn5jcB/dAaBFeB3l7S1ZmocpscblHrMsH7QKB/1FSNhynnBSKbOXhOwqyn0UzwgZqeGZh5FtZpzi/nKW+cPPGczyele77FK3RXBZqyqvkuFW8qrDELKXv+amEzras3NFiB5K1RwqKMrEOfEVz6NKBbp0WDQAIozE0Fv6yr9TPrzYnqPuDA0tQL3RvAHA/m8reWe8J5E7SGnc33DbAuoaz6rpgJ8TMbMMPBMY0ikBRFOoGayKxYp1mQqPhc/JQxs0fSmR7B6AyPu0SQUx8Sl9j8xCtMl0JiP8jsN5CwXmjWLvLxNMj3wPaIRlb+NCuf+WbQR27n5N4nIqgk1jZhlOlyhqo4Mk+NGcYREAFXr+9svs8Z5BnJ4dHx+wD4jV3Xcx2kMrlE2CyLQAVEeEACqTgUKaFUcIIPKJfH360s8gMtBTs/iQ+gJNajWdl+gpa1ps+aeJ8blaf96Frg9Jc2LaoVHp3QET4uC4lBrvZvOHC+raCq3n6xAmMPpa8rfdXsbsUW5qGmlb6xAe/3s/d8ypn/QMV5MKyb51DHtRAHSkEqJ3YlusJSGMNJYMWrcgV6kV0l7sCkAREgDaxAJo9lI7CShFpe1on1mknVh7Ijp1VpPxJAjhR+fnY3ldNziw3Od5V2CbV+JIba6JrYXcJUnWP+wRD97g6aMtDUTwScGnfVxHzmsrpLXYtbjN4bwMdPEj4sOQ/A2szBcxD1L0TTrIiRGhkysA2zQfwwbGLMnO3rOgk4cs7g9IVaUBizGwEWyAprauJIXsbCKqyikvhu+zgJDaeizykWFNrBbDCmIT9RDagMop3+Fbxc7ozPO/rhIEBJpGPw/aRhI7DQC3a6aziFAp6UbqV4duXrGal3Mu/PA7DuPoc6rrTMmAwQGFNIP76Y/4lZGBhCoOcblsdOmAUxwzrpk/WSMpWxyKSTS5xWTJpePCsok6ILAxhMhctwbUYpcUdr5t9yhXRvwir20p/oQk2meqx/ZqaX+cZyA7jvkXrOgMPXPctPpXTfbreRAANre4VPvQkAd7ealtN2BFiTW3s2cnh0fAjgDbus47rISf4j9wOo8MMopmUwEjGS05K/itOu+dG43tkKnL+JzslIrJSnKZv9P7NdRef2cpMsMwNK5EX6xJneYMRMNcdYOWU0LYKa18BDAC824X3zVGH2BJSsB1xVjFnjd4Opjs3g2hhsBVZW4sj2u2j4cz/7+E95C85Qds2wbu64/CsrlVO9ut7ybLQ0/MeTPZpMBGKxbhnkPeStdhYzWHlG0FAMcdUrgFVziRIgVM5q8Q+lt1EMXSqwaqKv6DVjoZXPS9rIujU43X0/xQmfGxvByuNS057sINDrsYRG993Yk90nCxuxTuIxZRUzBIW4YnA/cvXDonx3dHwSzlh2DVh/ccflX3mZmVzmiFhGv4/+pqEY7SAqSydpsClKZlboxI9sVMzK3mAZAdEO4mv/uh0SwnXVsX7PeXgmL4I9Ioh5QBay1KQvwgZCBFnVgk30RiAWTC0OEDWdQ18Ev5WqyR1SuAN6NzNVQMS1vpteDKYzf1tz5TR3P63WkGmc5/Vp3Pozn/+7BqxH7rj8Kyurbw0FjePKfCFA0u/EGNwKTqK/GExp4rugHGMIfiPlOTLIqQ431dzCbCmSl2dMfmeKxWyjEvERsfklTT9oPMzrZxutrCaN89UYovlyhF117/eRT40WB4NUCwBQN63LCqCAU9xrztc8c1J3FqNuH3q5+wjtQzM/Fx0f7D10yVJIBLAFPG3BaAs7O/P5vwHWJZVlbnlDIB47xkAg1mIa2GCNE7UMBg1ml1vpRw38C9Jcl7K68W35Nz8DOK9LKQKZLHKqSCf1LOgy9PS6O+VArNY1WkolAIppuG7SLYKDf6TGazxdUNLCERhrR+rL4BrUQrkN/tPuByCLTmRUrJndQ26nvNur72D+7wywDo+O3wHAh++q/OsgJ/5qs4BR73hwtvNHPpmK8UhMUg/Xy3onjK+76/IzVt7EUTaijEQcyFXDh966shcBmZq0AqmkuabWLftgXLJ5lMyyxO6IC7KOZJrPdPEsK/ejI1Ktvh8Cvgt7bDnhpBvKncqm5psuJMbSjKV6S9k5AXw5Tsl+eQALwIcCeIcdln+lpQxuHJ/Jr8JpWwABYVfNfg+vh7LWHqQ+MVAVzNiGuTDOVgDJzpvqPVACVGpoVHoFdlCxrOjw97zSQFAAgn8xxqUUU68JkyzY2TjPpmAlaipx4ePTm11N/U5WUlhQnPnJrMqzp8qvZiXKD0hkRhnTe73Dshh0p/vy4Y/6Dy8+UwzYJWBt5uAZi5pzzHTiKt3tp+ZllDHbSgAyzq+/LvihvBlCdCrd41puYoLWAAUJA2ZfkkSOR8bQGk80/q3A4HeCsYrEROsWOd+Pm5dsYwcAdS4+WTASS7FeUPYXAlblS2J+oxhlqkR6RFcB29Smwc4WuJv91FmMvfINrcgnp+zob98X4nJmsgHWBZMZo5FrM6ewEwEYWYULc7GFMmZ1VmDVYh4135h15RVaMndKU3MRKLh6zaGTUfXj43lh+ilOZW05gZqbgI5uNAeOAlRNi2jGZki8PvxYFQMtOcTS1qEBX9HFpL+Bqn1vClouRzPd+D7ERue1sKVjYecupszpD+CMcWADrAskMye6SIoxohCExLp4LzoN2tOyJV+3HsN8aDZ0A7zEKsx+dazJpdXPsIqXCllp0RRbmEWlhD/jzUCZyVQ+z+7YDKdKT5+lJVuES2CYf+YxKhpJFzu1W6BPmhrJmwsyRcjf2GTnRg/ORT6rImyPQJQXWFsA6fnKDbCuqvCArpzoukILcPGsGODRaZWuyILUowysCLRkqRzty2C11d2yGytKYU/Jp8QK0fVmEzErk/UCpT1oB9CIcAY9YiHCCkB9yWoERNPMzFIbHzgAMPDLcVZiXgXQWm7axLdF/TnqFJBIDzSLqr3uGw0eVVy2JcNjtGf4PZTHylvgqiFbD7qjne3vkG6AdUGkjKQGrcQEMGjNxUfxCp3ISviElDU+4+5W1KV6drE78wUOHFydjFE64S1a20lf+cl4KqeRORWDMhddme0J2LBOwS8TgT10oiwUwmCazXgFBwcKgAMfP+E9X9RbmhpK/S+5CFuNNZEZS7eAH7GRPhKz1UBG7qWdEKAVnZ0pWog1y1YE579bDi8+wzo8On5PAO+7i7KvgkRwWAsQHRdstQ9m4zLJ2BnsSX7w/LrrnkywOdX1XLlDyEcFu7I0BowFzdOZyIBQNh91/zjwIj1y65iJFD4XOGOI6vJMpdF1STN9sWAgwKlNBECeWfWcjuqzlF3r79Tp2pe0QPhdWFe6Aq4DqObvZCTLqmn3aUvT84yDR3fFsDZ2tSLxV2UqceOqGP19cix5bQ7QVfE59e7KT/kL1jVVTsCW8iobGdclhbArZS2BeTltiGzwe5o4fKAS9ksldYuFITPTwURSKZaBY9dKC5dBnMDI31MGh/jn1LVWjLap96lTHZF9FcqbychgO2C6G4H3bbC8oiqtNSFRefg+j/oPL37PrM3bJrsCrI/cUblXSnjgp8hxvl7ltUI8fqzUBZlkialgHaBQDc5xQnxneqGruaHfo34ERnKsQBZWdDEDuR2V6RjIp53j+qjtVUvnSwLClWgOW32mCzfSPpOe3UCj1kPSE4umhP7ee0bY6UYooxsd0pmWIcaHsf7dfaivrDGwB7NY7mvX72f2oxS7AqztF55PIf7ZK88x2CGs87rYqVMA0kBCuE8WBaaJLvktB7kU00idOFUCzd9Ar76JykxMswY2l4zJNMdY5HoFDjbJKnOK1XScRiZiy+lc8fo1lNlF3zlz9thk/jwKtBj3P1ZuJqu73qRfjMdWAbmd0tpPsIXr4NtJS4iwXJ9ABqU1qVM/E0VtaO9Vd8ZDl10B1rvtqNwrITOfVTJDiBH18d2tqGnF5RWWyiyY08wMjD8swRmanmM+NCkz+OncdWeHRT8QlDmI2cLsL+KAgQO/e2rRUauw2bR8hh1Y0dcbr56J6QQvgISbLO+Gr8hqwCosrMmuiZXs2RCCLqHPR/tXH1FqYaw4JmV/PhTEg5mFfcR6Mjvj7CPfmeHBBlh7EI1Gj6EL0fzj8AP4odSKdOk8lRmZl5uICgbziHYby+y3MVYXJ0TT9KQLH5A3OU2wxCyy36oyX7zu0cRt7nxqpTJMYQze7HOspeii5hqcEwgTVHMK/JdUMR8fjK25BU0Zk3zWv8QjN19BHfywstXHGWKvNVaz2f1ynD6ttk42wLoKEpmHAww+pnRpSIpvik45M6j7Z9CqMRVfylexOA7GNHAM/IoAwgByMokqnwzrTSt02ulCNGGYFcbC8teO0JehPp59DW2JiRMm48zy2LY6YFTXHHHSc2xBaJPzHQVkSTjX6RPxfkhWb0bzssZOdmFKC6jJmdQ8Wq+WL7JJEZsT7tmFB6x33VG5V0Zm72af/fqMW4+Jw1frtA75FcaElTRq8DWvpwGsG5lKvGSS6T4W+0kSakrwYwa02e4b6+D0obQUHkaOm+gfrFgqA3YLfSjFNMcw2KeWXVYcHmJ1G2VRLak9fD8iVIe0MF3ifcm3PPv+uE4Dfe4lO/KxWQtCimYOq+Z1XHjA2hjWRGYhA8t8J6YT2I5jAyNtBLiqnpKVBT1mZcj2tXl4jXfIAO2CAKIkT063VBMMOEeOAdoseDVo5U1Yx/iMEQoqsZlHRUglPn0lxLw4IFOLooncw6zV2KaTi0/fmmhdMTbkx5Hk/LzwDI7C/JhpCVQuZZveok8Mmxi3dglk7p5Z0Xu1NsC6jJKc2jlBuqZsh69zaMIKg5q946pyrtdva9CS4GwPLT8cBNDRhhQMIzHDbuyiChWoCmSfXwJmZ+bmfhVayG+FOFFWExVv8QzqsF/KcnE/iEnZXQIPHAb6zhwLZRKmFHqySb08NSH1cj8qD3TrCi06dD7+2IaUPWQDrMsmlWO4z66Tr0SnJ4NK8P3EyaoTOfi2NH0JTpndOPYEWdk90LQwqt1DzaJcAy3jdfsZ7HxgrelkJmpt4uh1ZU7WT8pyQsZVPxo8Y+CU+X42ZXPSOCKmel8rG9IRM80eGFS8ZbpeeZDgy4s5lzP6UDwNlAgtRLFa8ALR4yU97/sJwGYSXh6ZBYcCPOlpyZPR1Pxk03RD0ipI5Xbi+KdiDimdTXr2bTi4aQxWQlgoRQkoxqwSq+lkcrQQ6lA2oqVvasKSbyxxQ915XXIlnyGzCblvNexT/1h67ivtmNhP1KjcCn/sAJX7CKGPqvTwfcfHHKrgcoz7WutFr7QmE9DUc3al9kPbGNblk8pvJefR82tiphImmAcR80vxwI3sq/JdReY0DXx0o95/2rY9EId8YjacpMlEq9kMA4uBRDBPtcwKwr2eFjgZmCW3SdUWIPCsQuOfajeTr5Aa2t03B3fQhQK0C1vcBna4e+WNgUo6G1fMVr12rJP44SLcl/emFYxKdO70HW0DrIsuM4AKifSTwSUCDVP7WGZVQxzj/GYHZnqlfsHU4D0q9nPIUiyTR3mIDNYUYOj1Y3+OOLTTI0qNu8gDmO1Exn7oxVFooppRc3H9hCW0IZo6HDIgJbLOBa7qaWm+lMPsNO2eNvtLGxfN901kxeoAT0AM+NHG/d3prlO741oQzNeoqw2Is8ODtz+rgkQOj44btrCGdVCwRDZ5Gw+RYDr0Tq+zNdHxw76fwidzGl2a/0dyQoa8jL04Hi1FKExmY2FQtUKn6LB2O1ctGZBk4s10t7JUb+7DIpxDTdFQ3VIGMS21HZeEkR0rOBTdorp3ArZxUXrL6cWgPkG/vJtYLX8IrLpRC6g46qulhNm99XrpAtQNNHvTpBeaYb3zjsq9lFI6uCHzK7Cwyu8k4Qsxf8Ga1pjDWviCrzQER44RHP0ay8Se+H/IlZHmUpA6Dst0nijpFnvttWoHlop3TxYU4M1hEuyfiXFe7GjPetvCgx7SBIBaPlr+LJiZM0ddB0M7wViTfBrIKnMKflDFeWnzuIedrldePI7/iqYr77yOdl1owFpj2tdGYrxVYsqlT4cAR0ZZcM6Wk/8EM5FZTBmw6r4HEG0jvohZg4zqOOl1lJPezj46nbg4K8KhzP2goK/HVW3a+Xkjo5Jqi34Ub9dj8QLo7CiyDC6xJ1D+twBdofCgncGNkipm2NlcvUc4BvX8YxV2051PTa6KCc9wljpX78aZYcIuAOuPADy4g3IvlUyDMQHyWfjzIm7gx/NWwXIuAEN8A0TUJTqZ/WLOgDaMPZmIMgEnQy+xwtSmZgkV79rE1Ilt47Owc9SPYuZVuKqmCvJ9qcI5KpCIaR6kfupgM7AIuSBTkU1dZnEAsegEaKGfElOzDQtyi/KGc5AB935dCsBGgC2sy0eX6v1T3aQ+hTgt7/eiBm+rnDlg3bnvVgfw+2dd7mWSyuEurElZTlj+HPvSTMVrWUIdabVfAan14NChpY7jMeR0cnVzcASdfYH+MFpFBh5zUBCzy3a8MoNkgIjtZFLHRehD5xXqTjqaia6PCSMmA8JyB/jz8ljf1EpHyAw4qjEV1ZahxZ8+R1CRKm5C1cbFGHTr2gHf1wKWtnx09q1dXMAacmYKXhaZObTdXK2c35N8MrKrQSnn9XjG5oJjOenoENKoz6xOblF5fQzw1VCBxmBUS+VviSosSYQfEsuSg6HP0GjkNyg2HOa4rCzGiIp2UXW6Bumkt35StcOKJNNay0q3R9EA6icaZUhZgeepzlqGA1bfD13/sU+vedalWlwkuXMduPo2wLpwcqpdQUo7W7taOJYxLgxtFGBYU+x2nUZ4wKvZ5xy7pMBIbL6i9bJN39ywOGm4WZpfM/MM6GTWidLN2Fpko8QI+eEbKXoGElGMEXlEi6YnB6NyikQEM9KHdstZPu9RrhU3QaGZ2JLEiknG0At0ZB3C7dL2wf/GYYr/ov4U3ULM2gZYF01moNHpeuX8tonT4EZbLB9wI5rLfSg66XQak579Q+ZcLVbZMfglXZZOBdOpAFTL6fEfb7Fr08lsdmaHzQrnAxS2KWxU0Hd8lg5q6hsG0DqifYo0BN7Vfcvpo7XoCBlnmzEt0nv2YHQdb2VsR/sI1k1iN6f7Om4BPyaUYq5oEWETMsSLnZmLaAOsM5A1xzcgN7TnPIXJV+VpIY8C0YoD2enB54p0ijWxYWl3q/lUjYAzMCetIRSqoQOQXdRYaTZltTwygZyjytXX1UaLZoxf9Y19yW5XdrCPXGo7GeNrI4G/BtdnRAK9yk0c1b6P8m1xfqBRli0Z7NzOa10jAOEwA0nXzCSUzp3JhPm5s+UN1/eDbQzrIoqaegWglJyEzRje7UINLJy+FddZ3C5hzKPl0KtCwg6QmaCSfjZQmwMuF59FyopJkds0ctHszbt0StOIJ0SopP5QtT1nsvvCCki5zGK4b0O8Eci5XJnj9F2t0sC8HOxTH9Fen4Kr+K48t2HjjvuCVfAAy/2y6Gb3SHb7WB3X7XRd6tS1y2XQhih1HO3fAGtfEuOr4rU0F2SZPYWfyYERlTEKX76vOKuZ2WVGp4nIFmAfRtPLMkk1BZlLOdCVTDetq5FPB3E+OdNCTZbGjID6Q8C0RULZ/CGzhD4m+qzPBZC6n4z0/iZnkprezGTimzAyO7NujqMiq2xXeZEz9iTAZT299L0DdCmjsz7GZP0GgvV9NaQMz+xFi8xYeU1KprQfFsDGsPYn+Xm3elI0Sh/Pxc9RkN7jkmXJas4reKFDNE9lOIul5DI6dsI6sVNfyijYSTT/KF3soxjGYO9gMvHP70Ww9iVw2/icqWkbG8ruaMKJXvpG0VhDy21YdFRtXas5n7rY/A3WT+U9gV1FULB+0S6gnvGLJjM5AUspRd7g6s02XhIzI26FTqGpqk+eAWw2Ax19A6yLILNtbp5sq854YmtpHCCO9wocRlnsjA/LJS92TfTRGeUTNqmnn6y/oiD81DV1axbKBYgK8h4p53A3nLYDLTPWSO0hE4+NRn5NjGd4BTMqQN9XaeysopGkPufQ8vl7BVZazrgpcrtaGBkKZJRD7rSYih2hL5zvzzvjuRg2S4FiwarAuPnvlHQDrH0Km1x9MmkjCFVp0L0HIk1vBpZQX6prhemZb4deG6ImIa2uBELKsiYmqJlcTdNOFQhN4nZkH8/ydgnbBGw0M71p0rVA6sHKHyNCJmDFYFpj86hxNoOCCnGkP0DdFyb0gwSo5gPDWBwMSGM/aOnEnrhBprtUGpco7Ra67hVcNkDodIP2s/OnNZdN+BurM9I1M4mX0xcesK5cpHteifl38DwrWgbjYARr5QXzzi/iNlHdjmLjwcshALWeWnqbgU+zOW/LsE36MfLUhNGFVmabvEzOd4JOvkjkemyDnecMrmfCbDLwoAraOnBqXzETSmZd/as3ZUPceXnrBswcU0a0/Hsw889NqZjdEtOTNyeWRLamyU208chtWUisv2602pUYWhc3QfynB0GEcaZwe+EB67d2VO7eJfqLmGDLJ4NRnBLLQI0jqRi7gVmBrusjJjF8IoKq1D8GtF9TuU7PWLgUy480Z5us/C3qbmkrALW3S1jd1pcGfsZ4fB/5dlFdrh2kZ4stz8fcqrKxBbIQNDiiJ/XHHbxgjYVSPOtzWbuAwBRNSUd6u4ewOcF8BfVJOd0zK6cLQKy3rpfbFnrvzPBgV4D1yh2Vu1epdt96uD7za8W0y4n1KPXIwnzW2YofyuDaW7WnBGJyUV8fRqG2TBNTIQOHAlg0OUEMxDEmOyKCp0AloNZiWdSsCLKeeGXGwNJcQaPOoFuqlNwAXg8uk3veM5BqZ5ISm5+ryaJQLEbl0OisntI4bwV4wFYcHJ8RzBqvRhmIXMqUz86fGR7sCrBesaNy9yKRVZ0KLHp3A5oXV3nnuqyEWnoFTkXwp+hhO1dhEoqe+oWKQ308llfTcaZT84fBINDAUEsjDIqbwwwxT35zWjcglCaTpnOhKxKDRZPJ05nJLXVonBG30yFizWQtbCDAQjOnt7AlfptppZOAjfTMytoVwIyAUlcT6eNsMiu4F2DFxWkYSBrRct3SuUUS+I2feuwn/3at+UOXnQDWnftu/TaA39hF2ectdUxTvrGZJcsK6vMJmIBWPRvMPS2d6zttdZo+yrJYqAEt3Q9YB5Tdymn610in2BpiRNqmUU1lBlHznO5p4Df3ueQj8O+MwfWvRzum2/35KP6UTUZ3y1s6MN1gYGu3TnxlzXWbvQyx2CShhaViuhaEGsGfAbCZHq4c69P0SI/UifiOf1u91Lke7i2XMYgueC92FH6m5GWXbwZ9+Q7L3qlUDnaWkmFNQEwn85IRbL7whE/z4xRA5dLP9GmjXgS0aC2nU12IJtCg5/01zwxzijiw/W4gTyCbYMI+2Uyb9sVK/8jjNrphMN1ZZb/M/P65RhZp8kFmxTIO2BSs/ESWPkS7A6qv13kBP3lvv7yXqlM5TJ2boAvVGzeQJJ9hvmeDREYRireFztp2aQDrSpmFLAcnANqq9PoRWykngleVZimGV8NxzVcE4/o2jHTpFburm8/GDXJWZACe/RsnY/Um06bMAPCsIAbT9oFa2VeTfwfRt1WisIM4ttgUnGKiHFKxtDDWZZcj0zZmweaSTFjur4h3pU9K+l3baC3XW0Yszu6x3igtI2/A2PcOYnm6bvmFy7VfWboH0FB1OXBb2wDrQggHfKpPCvCDWnwXvJvnVjG4Y73nPb+xU2T6YPA4MEZnKymtvaB/IGDGdVpFrrF+kEadUG8eRGagA77RVBRspPiv5X/uR6fKojMBretHmoRORwJOZiZRX/YrKi7YrNaiG/ytlu5uiKDuEUBfK8zOLuqftQWrlTfIwNE6064Lk+MyD9rK7y26bjewV6O8WSIXmuI7jAs6Uxw481/NIbn0gDVjTm6C0+Tr4zsg99WbNM6M8hVZnuo76VK9d8vK5cnqzc/k6WkhZ+VT0ZWu5uZTAAAgAElEQVSVTJjgXxMTpG5YaiiZGaSmU6f5ZnBinQs+/q27S/OdV2Mp3eUUkOkDddqgTL3bVesHZlTQf9yCI+10aeyzMgUdgxqlyWYAX6OeHNnpAXaAWKNn4LyoqR+rpuZDH4m+97Utvx5EoOR082Nj6LMxrF1LjHMS0XEnQBBAI6ZT/s4MjNMG72mMno86Sd1RJ/b52B/r1v2g1MXdRS555WlBzfBJ5Z5SfH+umV6dUqQKCVCyyqTsdCeXY7v0c2RWApz6OgCAm+gMHIEFDX14J3AaA6X1mcOeQ/HYgd473eXAKA8GWHmPYxBPzry+2obuFixJ4N2QAvByIvXRm1vDq6cNfhtkl4D1agBv3mH5O5Vqpe6TY5HIkKqtHZeP7JRlsDefv9ApneNCpwy/uYluE0P0zu9m0okfSjKwtbyWVia6NYNXXvYr8TnbYVzOJ3eKXAuIUEKSdmkANQIybxJSecwoXcc6bbJppnFZ3VgVPFBVzwoaQPCupPzUmO/Huv6u+ym++d5/JtnZT1UCGt1cBcOgq4Rc8OLNLV6Yoer8wIvv/uQzxYCdAdad+269BcADuyp/V6K+qdkqPvnuzvOSKGwsxGU56R4MGLxYFx8PZgtk5xNuNbe0SzWLXuI+Z0DQOeHmcDYpVbduZUb2wMwA1DJmVBabNGYcTXSNw3INNPON+4DnivhcENIQyV0VZRbNwIyxUtugNzIAMSXkzYXOgEbtYhyKO6isr2eETmOGMeqnHPzawvGUHdNNiq9mjgnrZyAb6d7P3Mra9Q+eXprQBgGGmVnGKw6/GK6FNG6GsO+qVeEAbgkNqxacHjm0wjK4QQvvTG2gieqAiEw0x9AE8AIfiOSgtRIgrAtamZHZgdOb+oCSxEylmcjhAssp3wdGcpurn5vW3CmjLX3kl+5WEhbmcgwXMF+dvdom7q4pMLuSfAuZpZpvyhQQffJ4Ff/puA57cHzVlB+glxdt7q/5q3C47diBW2jXgHWp/FjVQ8TNJzAGFq+RLAPFw0gsl9NV5ZzkPF4S+XqsVANKGd7R/HG6cBld3c9++hT0cCVAI8RTmT5+MaZJHsI0FPzR3LWAFTpZq7AKLtaRhe7NMwUhpjwF+IABb6wE7u5FjG6TyUzXFzDsCmzG2uD6L44mNz4FtJUV1ru6q340YX2N+qPoF7Mq5Z6aGyAP13bpAOsXdlz+mUkZXDhPDLTmAIHzVOzL5ZXDou7uktaA4ImRMDl77XFqQyPgKtLIihpHnYM4atjsHei+vNwi5QduYpr/zpnErm6ZiNQmafqCCmEhyCDRlIXMzP1wF1UvJsu+FyMzFtYkOjg2w/ghjE/bL4x3NvGJMcn3aDZzmjggAa8LXwv1JbbIq1Yq3C8MHNc2Ps58/u8asF6w4/LPTCo/kbfM2ULJI6pxGvJJTUFvzARjP1RPwfT4+kzGWqcTTTK0sZSnX70hpdmv5fYOuWECDIE5MFFThz5lZtCLXZfMV6q3DwRwfZvQbMIYSDfRRXd3qVaLjesJx8UcVEtMq5VdOEsX+0JqUaDoReKkdy8ZIZcnuZq7yaaT1hH6h/1NcbHR8A1nolbWhoBTNlvtUyv/HQD/Obfi4clOAevOfbd+DZfAj1WGMAjF5k++Hj79OCxMRh5cxCpm+lSOf83bGJQavOPbK8Q7gK0VUztN0gAgtMLOTArfdWIiZJZTV+rB0XS0VT4xVtGHfY6Fecq7gd0tIo4FwLa+/MLh6hR/ZOeJb2mMOULTpf5yYFssesPkjGEM/GlWdCtRrUtfFIDH+ggIyzgSE75aar15n+8tg6ztrrYXvvjuR70la/HwZNcMCwCedw51PGTJE6qlAZd8IzJoQeOBmVnzq65bxSd+GB7oMTi0FLfdtZSUWYtTLX3p+r3B5hLNJsfOrA3TH7ZwLVt7BQ+xr5pCJErjgiBjx4legTHYxJe7MKZh98G+Tq2gLWtnznG5xykgIPXFnIVLTq+bq6v5PLFM7RNiPrIwaR1icyYrkBaIdNk2XFgBHZcOprOwHw07mvfXErB48lUgwUyk4kB+fOfJmdgX1SW+Gk7DO5Mz0FJG5lZpu8qOcmYi+tNjUT8BvsJujQ5b6a/Zymp+F2ongpC5YWZYwWS4xcEUYUoz81mxWWLxTc31vZrsadZKPiprqPFgAL9K+XW/XoTC+Ks7AlZ8t5rPQ2tVBEynTjG+I8tjliXnPRh1OupaRu0fbFW+SwtYLzyHOh6SyOSrbuxIYOcCOxLR1HHyUchDGpBSNzJAyuf0WcEGAxhdR02TaPrFslNZ+ufRj3VbK+ckibtHnc75jQdiTwLIrGsha6BgxXuG5vG9ER52vceVX85AublPWBUrLKZbPQoOtnQwm/Gg3/154mSqF4GIU6FRvSgc7aP4uBngYFIGCa9yrgc7pWOTUfX+TQC/hB3IzgHrzn233gjgJbuu522V2UTklbiwfXJecWgTeMVJ0vh6MD/lc835b6acfec6HAjTysdvKIJq5yd+QbRK+u99GTS4U4uZfpCpEExjZ7rILl5ot88wrjnAJ50NfyhbzcBcgY0Yj5DPZJ4V78kiMIr1xGAEP9Z8b3tnu4Esr1HWrkV/XQQ8zs8BPS0GDHZpxEIuMnvm3LmP9OD5L777UQ/WSjw8OQ+GBVwgs3DN5KJEg4mEH3ig66OQuo6YbqRV4OlrnoCsLxOBUYL+uXLIv+UYVwFFoofoqwSAGpD31CKG19ASpqI7x75CxaiQkeEElA+T7/E28Pa6akAADpn0K75Cb+q43nG6sj7s42E25PtJYq64Htbb51E8H43wS003EE03ES6ltZsP6f3tk/XGTNQMZiuhJDub79cKsNjkik5kYUcLONjIiYxnGTw9sR255iT4rnjSVu/UKn0/rp7AWkBGBY8rTwsm+rViZRa9bQICAn5rDlfPLLo7u8wizxItrQ56mmx+8SBdJtW3UJ43ZUe9nRYpzkCgrZccGC9aV7uwegdU77Bxg2qxaAoyDPqerUr+HtyMmU3pNTJdV31p0keuNT2BmYwwCXdJxYxKNYxF+wnAFQCsnwDw1nOqSyU7icNbFQtTj1lQyOxunez8VWyq0zl19MZ6Ch9WybyUd0ctI7uSyRGW2VigXj7pYVw3UwgeU0H+DLOEJmn8JoY0x3dxBlDRf/YYSP5tw6iTxTUpjgda51nC+FfT+AXN9XgTQAn3Jg0bAXqZ2PxwsGSIC5IXNZsRF4+CO3eK/eLFitaFrOzomGKg1k725Yp1oy3MHbjTGl5VNuQM5FwA6859t34XwM+cR10sawGYkwxjcW3T9I3LavFlb36E2HStJbOBlVUxgcXY5SFAjCZgghRZwY1G+Lq7/76sxJmtyOpq/hZvXqpuqpQr2KtDW3VuJ0tV9ZQt7eY23+2ubGIvViC0/Q5EVdWuN5Q5rMvBIB76iK+pjnQn1JiLqw3rLiyoNe1rwOpJiwfr2yyNgL3WR13poZj7hvrDhc9AyxG2yrrR/X/e/TcfNbe1H6acF8MCgOefY11JZs/mGRkYA6m47tKsAR+Zm+jddgSLpFVcU06TB1giWrABXpbhjlsygUz1OqQicj4LFYj4bGBgD1UL3bJ3t9u71nmChAlIjfY+xLyQmNvO91AHaMILQ7Hlg/FUdGt6wY8FPeVAmMCAzWW6lheZ0C3FNVVTGY9UnI3yaixEUf+UU593KCMI+3x+kZKx5heBYNrv1P1znoD14+dY10OXuJUfwabwV1UQ0U/B0jQdm5EVkCirzztnzTKO890Nba+sB9pKq2p3EfDvr08mXCyJzK0+UEAJzZiAtipL+ooFuglQKwxM+1f7ygVaWe9Q1aMcy8hxTnQDzEKkYiLjKYjrRO+51s4Qbf6MqyPU5X1nZA7aOuJ01XRBdFcS5tCPoBVgzZnm2LG/+jwB64UA3niO9QGQVbYGD+dfiuyJzD12zqYyOP+Qbsu+S1P51DC51sKg5Lly0pzgVTUlnkxy3YxA1DFmnb9FwtiKbSAIhplOTU/GdImONiR9YjOMFXo9tJ+CnyWyGUvTqDx6FUunXC0Xw/FM0k5zagsn4vsMX0BkV1JNn6SrKLdr+2BPoxO8CRoX3WadIJZwa9oG0TfntcVVoXSZPj91/81HvQ47lHMDrDv33XozgH97XvWJOPOGneQkJ5pnvMzM0pGdNAPIGGdVTvxhxtggWYaFm+suva2aHcWs5fzww87MOM7W3adL6wpPalu7QirNqehlbY9pqq3yyvHLu35m+tFtki/aBxENDaeMczX65Heam4LJrxeAxMe8UQto+HgTdjkW878xHSKGrekdczJwiYGkksXeUIFaOnUR3bkHh49Khr6fH9I/af177qSWM5PzZFjAOTSIxe2+DbDQeQwPYFXA53IPm94VW4GKhY7SoLjGAFWZgpJXducsiX8KP029LiBWbWU3zd+pLp2oneJwNIeBBIPA0oexh+w6t8smen7OMRIFJ933R+kjgkwidkjDWtHdLfMMSVlU0Fv/jeELjQANblGoHO0eV/wSwX4/H9+1fDomK7o16YM6TIH7JZl5wrAIccvXy4hunRepsQDqOIz6EpBbkW8G8J1JyTOW8wasnwPwsl0VvhbGkONjNFNiV85MDOVFXxODX+XnivliXQcB6GSgMkg5cBzXD2i2LafCgF7QLy3Mkl7HdfTdufZaJj/RYkJXA1zvuIU55094pqzIAML5iJyuBp6R2XiIMvbCKji/lMs/QHcA0JSdaEH2uea3tGtuBHqNFTh4h5KVXleFzTxZqIDCupBubtbnJSgq0PI8YXeJ9s/x/Tcf9Vvr2j18OVfAunPfrQ7g286zTsBYkRtMtASnIE7I4OnM4RF3Cd33AIiVDpUQJrjJxqDpwGyAQ9drRZyXpGtmLnTRIS6yle8sHbO5ZFVEAEjVV4USS3QZxmcnkF1OGSuKcT8+O//rEMTVzSo1p4jl1wWg0qNaGJqUFzsj3hkzN2OaapFkfqnfA7AkV4BrDTPd1Ot0j3rqm/rYlkaHvcvVc5nX582wAODbceI68bZJ9U4rvSbn6LyYiA8Sa/JsZnaDqb4iXKJiDWyW2nn7M4JmGsQhFreoHZDxieBc4AHuCc98RdWcbqCHcpShcF2UggBPfVsVbov5QuwgsV6HPfm+sDrZYe3L0TWoU+aC9VRFJN/eALaaSBrYxsBWBXwG2vL+N+0Xc22ZGeiCapUpaQ2pEQXQwO7zuNRDWtKnyAoAbwL6D+Ec5NwB6859t16PHWx9xgDMyqeEPm41xQml4M3wyec9x7B6qnWT0/SiHlWj02TMM84p0CtgFUZC5k1rlsLeMEntONHGqZhTvWGhOmhtogb5ZUTF7kHBWZLDFJIJenBQTDKqz4csWBqyKKft8sTYTK9MP4v8BEJz/fx5c7Jb+x9Un6AsOLbq+NADaqZvsumj9eS4v85H1EeyQMS3anCb4uJlQJna+h3333zUn+AcZB8MC9iB833mi4k3z93Q1tKYTGNiZuoJa4pluiTE5Ca7i3FdZ3+CTGhPGAyIEwsMJp9boal83YBwEz/olU5701P07NTOaO7JRBQA9TuI9jYCC2+oV/moS2v8LKZ9as+sIVYXPUX/4Lg23FD2VPl2hJXYIpJHkixEFTOUHzy1e8qLEbu/7SDtoCbKY5p4Z30aZdRbAxiDSSj3hdsTN5yozee2mbYvwPp3AP7wrAqLu3CzSbiMDc++0sAIaaR8d8urWQSkCX2alwK6yd78YzZNzqd6yKxwF7oCaQ4FyJNuGlrh0ifbyeqCDyw12uL7Na/LY8oM4Dnp3RXsH+JwiNSfyiybP89qu7axY9vILe+auQBW1YVYXj0UitqDTgSI6iMNWlXFSL8B0PqLFmq7XE8lukbmZ6wnKWBvhQh+rV8B8NNRi13JXgDrzn23fh8LaO1EKp+SCxId4sBq5DkIrCuuTy2k58FmzGLyhs5KWQo1cNvKeTYCsOnlIGQwGYRJ7asJ1KsQDwrcO1Y3JQYgb1Ews0KsHylCrs8moNPRcQvpx6x/MZdyW2ILhDURq0r3tvm0VWEMLeKDin5JvdYsrbVx/Ns5MdzgmIUf5DY2bYDozKPJ6aSgb3+Wtk1A17fYhoUsGh0AnrvLZwej7IthAWdIIzlkoGRXKxNZ7wF5dfU7pbGiCKii4U/6rPmJZJIwMzho3ngzd8+YEGFb2uWnVTrZhLGxEMArYqS4fZRZBqvX25tRyYzQCblc1ClU3R5Xl4G1PWDLk81ECEZ37V/uqE3GWKWAb3hVdQCPaEor21JEpsROJxmLohLXQr9K1MZ3MYVdt1E7e+4j0XO+2eP7iqcEg+EB9SkDrZ6jev3osnvfgH+Dc5R9AtbzANx5OAVEU1DOAX5or72sz5l65JRnE44lxmIlTJiYpm4V1+Uq69jjJYp8dK1gXDE7xQ9sxq4mkzQ/dlLpwYUwHtgCy6tsszksKELIKykLwkFl0OSQJhui+wyELYv5Lol9OXEsZDPZ2hTDKVxdA8DUBNSOoARangGAfScwdSowUybgCPdtqY7DG7oq0bTI2QLZ3FhugANV7uNO7Aloy8aAtAV2a0leePvmjddMKt6J7A2w7tx3660Avv7hlBEZVRXG4M4TKACZ5YRlRplBwfOTj6qS1bABAUcZcOwno4Gh5mWcbjxhJhsOvl4GzzpdDG7lFTauwImZkDrGCiyjsghhYQoWvayjabOMnWjx3O204xs5hk4wV5eo0RMwlkHGxT02M5BHEpPuuJQ1AxYHdFqLXmCiOPUvUn2OXMZR4ge4LS68pmneHtoEv7HRfF+Oxe8flwruUPbJsADgmwC86aFmyuEBNXAkBkSmlbs1k4Gh0cHsFCVzbxoMWpimak6pmeQHdiqJWVoLg5DSNP6kuiyJsdD68Z1cLTu2rUryq7FhEVddMgUdhATmYKcZHOyTzUv+1+tkdXEfxTRGUo3RNGVmBqZV/+h3j5uuhrjOSUJx5Sv4NmaohXgsGaA6WWj4sCqv8YLTIQy3k17cGN/3ge0H9jn0eAnQjict2ZnsFbCG8/1tZlkVcMwmfsxjg7bZDAHc8r0+tdf1qnSyYSBTOZxplE4GSVM+wGRKS5xZMX4V9aYS6wkYo3EA2qYYExjUklhZ0xjgabE4UWvTg3WLb2F1fVn4cFwfMpZ1Y1iAn4Cru5SMhY71+MlujNCuSa/zmsOgb1UMZtRN7wiU1ULTNB3pRIe9c9viwujvtWSyEBPfB+TLkOK/+v6bN9ZNjB3IvhkWAHwDgN99KBnWnNoKRJY4XQeMLT0Yrk/ZygqrWmNcLR7LiAz+JrvGE2Ss0DK4mM20BgccqV6b8OwHYfHvMWrhWihQTa4QCjFsEn0rANME/uygyeBNF+/vCe0IfigBkBmr4DKrcoBi8lfgFZpogJI4XgJZvu5AVO+9pXDNLtrlwhgEAl0aZkrcAdB+dyZjWsD9J4Ot3RMZh6rFKwB8L/YgewesO/fd+m0A//y06XOH51UWvCrTgA9rkeVf8f1UTvx4jQMxOS0zFL8LtSy5BgGkJ6VjXaf1d//GpTy480R1FqayBm8iGGayH8+HAmgO6iNnVpHi0j+V+c47apGl0Lyz0wqwpG+zcqq+YiAStqp9QseV7q6vSqD1OjNzkTNm4nYIg+oxW9A37VIOXZc28iijkRLA0Jv43S1EpruVJYu9LKDL/bL3xI96/9H9N2+c+280ABcAsIb8UwB/tJZA/TArjm6eXA4EkMdEGtR8o8xGAtbYHDm7PZOB+9S7Pyg1M0AyLHQyycRJznY1vQQagt521q3MWe+qJ6ymZiNd2ydpXJwU5V4AuPs0DAqajCZPATg8waR/En9QgG3ua732yBgQ8x/6ufQFvfAOmcUELkjl9sxCQ5oMDj2n9EXW0qs+5NXASmST2CB/8aPFh/yjvkubPOI5E3uR1wD93N9rJ3IhAOvOfbd+E8A3V9ecL6ObjS3nShEGM5ZcXiz9XG1uVLlrI+9JwZ9VkCjn0HrDcqrsavzDkyZlloTCUGhHjNvFE9Fqq/vI8Li7tDavdEYHcDdQ9pys+GWbkcABOwNqObl9GQ00BkTxIGkYNH+YWFP8pDwCbMZiJn7CVuu+sLCkRvhmv2rD/uwWxgEzwVwgfVmxCFlHWxC4HLmLzedKi5oC2dfcf/NRb8ae5EIA1pCvA/Cn8WR+ap9X5dnaB6Dn18ZIuhi35cdBm91ZVw8DZ9Sjg7I3+DQ9jIWOAar5FcV+4geuT7ro/BN7SLOtPaIjzuACAPSfOBe8mRaGeGVFQZzx7PjnoNUqls7aL/9wvJEAqAdsmfw+f/HqHaK/3N/eyS1vAM1Q5f1RTgMI6+qUTsmQMjcbM7ILbUPD0rAjPvVJfTI1s68ksA2WAems78hi42+5sw3tv/TevzXXdn5yYQDrzn237gD4lupaBJgqENStUgMtyhVZ8gezTCdesUs4f0A4n3fcR8gQvP6ugsZzqLtP0b1qR1x4GRB5EkYTxwN+1L7ZefFZNV6DA1KOdDqcCwVzeEenfrHrkaWqwch9WC3+rE5QQBljQlEo26tASUFnJNYNDNgDzdyippXQSOz+q5TkAJPaVG6MNAN8Xmhig9xGB4Tlid52/82gkPNUFwNw7GcD1K+9/+aj/jj213nKhQGsIV8D4K2zOKtVRiPpCjADPPHl8+6YlpkIglFWH7AeNYqZ5pkBpVFcagloRiU0fuTYBixrwOZDegMBtWNCHIPu0pdWgpt7NBmrolgvZQuj0oMJm8q5/T22o5ZSMwE1jRclE1tsPp0D4aYYTPV1nz4ykaBh2TEt3q9qoatiwHicdf0eQU1fqw3vY3THPNZoiZb2+jnk+3Do9cbW2r9Iip+zXCjAunPfrVcD+Pb0loOJz2pZ2Khrw2yMa1Kj0aYDfaSJ5kx6pWwh5cRTXW1w+CfbQkWW2KfRa/wZXvFCZenq7VZXZlZjsLtZGymABzeo/ijOL9ndHiVP5m4sBqkUXhuiD7BNtKtju/wtb6OPcvQ8RroICpJGJmpe81pIl9sg+pk+RFF0wbE+U0YUwNO3nurq9p3b0HwHBW1tqbE+ysu1A3tJR2OK4O2f3r7rxh9gz3KhAGvIPwCgLwNjkDqIYFRN8uBEF3Oqj2vqN0C8uXJApmJgdqcRNTd1dLOfxNdXsHCkcSUrfzJtLZ0LmUj6aLOoDAZjr1t23FsfmwrRYCImE8AqTsROk09rIL3s32hVySLDjMcSN/3iwUrHT7CAtIDRXDe2Greay/fCGyk6uRXw8uKpKkqjiFVHCS4m2CBpKZ2/tzYw5sM29GEulRYjAMB/QcP/NSvtPOXCAdad+249AOAfAXDsSkIWNLwBMABiMyMOEsofnbs67QoTE5T3wYLxRbOUB07vbhbphNNjd9n7SChDGtRu/BYDPu68VSLOVov6piolfq1ZfdzGYIn4crkgWqHX9PAASCAofSlnW9LEl6wEryl7cfeQJrRjeg7EOF1zDJmZFbM5Seti56hdSdMWqgug7s25fBDNV95hzK8Hz/r6frbFgXFQR5C/119++64bDym4e1dy4QBryNcAeIBP2NhOnD2n0RP+jJqBumNlZbLZyUAHmN8lshw34dkyajkNAyFaOvDfCZkEnMV3UTqJJ+e1VJ5wVJcMVjUZGq/P1kdsvsW+L60nhwl5IrlJ7xpM+QalM+YUG8V/NuFjcKTowy+7c0DqDu0uSWgDJ/Ds0PpHHh+K57Xy0H4rLz7t0PIQ0FNy0H2RPdbgAZbr4gZrgGjjNtkPlohtAOB5aLv/+a7TyvpyvEc5PDq+t7X2Q0CY7ENszNcg0uEbVzKrcF1u6sHBQbFi1S/lS3VHs3VSnzggxJyqMExDAOIEGxkaTqGTu9SKa1Sgfiv0Cjonfej73E90yn4UvUa6Hq7pRA9tc/1dFJ+c2syGgalOprsviSGAmaD0YdkTFWjS+chQp33VfLZ4H0VvFGXEdcW7Cmy5astvDf7F2zdvvDwrsB+5qAwLd+679cMA/p12JfmTZsAA+EFkCewm8C1NDn0xNwsTcG2S6SrYMrRGyq0UoxcTfxzEVddZLmQu2lP1/jNKZAryzRiBLbP8ChJtTePJyH3ZLXuTe0P9mXSQLqgXGc++lvvB99OYQws5RSMrx+h0DaCVjuFqoeFybABlKdmH5t+IUDHr4p65m0y1UH84M0/TCxfzFXA/HhTjUu6v6t3LZfXrLhJYARcYsIZ8aQf+oCO8ulhAxfmIihVyzABee+It4bzzNb9efQ1M45X8+l3JwEwqgSuDZyeApXylT86BQdCkFwDR/HVvLzY7L6DlwNGSSrgC+85mGxXi3yvNO621zS6XTM7Mr9p3p0GrayYl6RaeyiQA9W9n9U8EkO70yc/+Naor40ZzZTcdr9a2HkZSxYwsP8icNX1zB7oi/QK1fH0tgH+ICyYXGrDe8Jwnvx7A3weIWAwfFtNvQG5S/pkjuXMVGPGNL1/UtmK2+HSx0Hk+Nr5cNgEO8bU02JziwUe+mBSfhpaYjAeJwQA6XL7IVhUgHY75/mZ9TmNW1axosCY93T2toxzSbtFNmJbuUEasa2Q6IvS2Awg+7Ze0PCTyMmRgZKCQdk61H1vuQKkn3mzqA7fD2qpyPOj5FjX/Tevh+2HtpmK+5PbNG2f2QzFnJRcasACgLe/LeplMmhhrZaaSRDU393l60IkT6RT5yKTUMUQrpHyn6eyGCc/L5pDCT5xULWoT1e+q+hz22QwkUjubIQgxOTRfSqxTwGGqr05E7okMxqYDf7c1P5uVxD26dZ3fLSz0YgCpVHB6jyzBruvp/HI2+IDKTkuM0K2y4f7RZ2vw+ajepMfolLjzyKEYgqgy9Cj4+Pj2zRvfX1S0d7nwgPX65zz5zQC+kIEJKMaB59VL0lmhPLHTJV5hVyZhqiH8qIGuimROVOVVJgLrlRQcYFiYXPaA+ERnwYLCTDR9yG+irNXNKK9L6QD3dTVV6KwAAB6CSURBVEqxbmY2aYvoXjUWylTcOtVQjwOty0f6J/2GGvqoTam37RK6EAeus2VmIzuVDJ7jQnnftCuaqBWcF0yOYWZrSw3iKdDcn2NZbprEehp6xx+j4UuKLrkQcuEBCwDe8Jwnv7Ct/DrHMgmLSYw8zdhXtYx7n4KZy5rfKs8U8vHQOLDVvw225VmGVVy3jRM7p3ZcPXs1YCm7gEK+5HM0pEnsY4VMl5q8RB8W9yWVoyYdDBBo610xHtaHxrIsBqp6/MT6nm5CGghjKrPf0FrogF8WA1mUlIC6seOBoR53RZ9xs0v+ZC4C3eQI7RYdUz4HnJSGrM7Yz63hq27fdePVSY0LIpcCsIZ8BYDfiSdjuMJykJ/bW+6z/VpzfPVuLCvXY+XQemUJbFyp9cMs3wI1/cT3y6uAXvflKmPsymj0v7nKXhyripk8QjXSl0FSc3ab4HH3kHXyALp8Mqbk99VbD/G94TzMRES/WAvrwwU0uolxaTPnOjvbxznI5gIy05M2g8A63JeTQ2GisexsX73X4yuA/CaSzFAF0K24COhsMo7ifgUdXztV9gLIpQGs1z/nyb8O4AvSbFgBHr/+wWiIhDDAD6b45lAnqTBZGs1X5a9D/VLqhKWdtmbZwZNiAURZEqUae8lc7aOS854t5EWXUTQ1yE4PRijAnttFO5SltMRYfAVBp6hFahsI9Cc/puG6v77mQTbq3sJYoLagMrM9almPt6Lj5/1oeywRbFzucM38eXE8sPmurRS1mlw33QnE3wzg827fvKGPxV1EuTSABQCvf/aTvhO9f5OszgIU7Ihfu+16nszCaodLQKvcOdQjAb9wPtID+ur8ZjJQA4OxYrwJEcHUmRGkb8U4mR1q5TBdwinYIyOUWeps2RxdZ3l8UYBZQLvZ/SMVvHPd+qNGAgyMqIHCma6usVY+s6a0gxrawL44ARu2tIm8jA8DSRdzFdaIUpotHF4LY1oIYFqFQETw5VbRG0b/1u2bN87tJ+ffVrlUgAUAaO3LOvAShwtkAhbp9bOKtYogxecj7dbVCnBo4LgEj94CilwZgz25d0JBBpkHoBi8ahOsI5lnzPBI18okXIZ8d5NeWZ6U0SyXA1FE8DSdahBrOoFMt/xMo5h98Xw5tSfMylhRZbp6AJI/bW9Vc1iYDHjtQvcJko7VvTNQKhaATuw6AhFV1qcVL4WweavnYGy+A9+Ph/kboeclq2vjRZUP/s4f+qgG/CyAdxXTzvlGICurjUJmVPLoTYd/Sj8xlL74CnpVbgF+qgBA4ysMt5X8PCQZoKIJxE2Laavrco75gKs7IYalCGQgTTADttRw/W6TQxTxJs7gK1ba0P+g+Yks5bqmBP3LcAHRudsLCb1PKHcG6+SqiGVyk6gLdAGkvkRuOulVjKZW3zEaQlkp6pTGnRnSkk6vA/BJt++68ZB/H3QfcvkYFoDXP/tJr0Rr/yOQx4AK3VF3G4lJNdQmIX83Nk1DpvCR6Xdnh/kdSdPLdCK27sEKHBzr9cqWagTawVDU1zQq6Db0Xd1ai9UXsUDirZxzXSeF70dlNYXu6J18dzQJSa+lvmjeFEZhOJEmfWRFRBfFDGSGlUHeHO3uIGCiwwpSWc39oKOWx8yXVW/uo7z/c7Aava7lmxkqfUz1vQUdz74sYAVcUsACgNc9694jAP9iuSdx6g2pHLpBplHuLg0w7ni6znOP/S06NXhS6Xgv/BIl6s4l7mbxe764OOeAD74iPTfsNNm1i6+e4XKilPsTw5SRvolJWBeENBFzGLIDxrmMyVRN6Nb12sJqZiy0SwmBtFjPGvuUMgtQGf8lQgnxfYVNi2AieECq9KzExl2IuND7GpJ/5e2bN148K+0iyqUFLABAa18K4BfETKvu42wni+Nv1ui4H3CN/rU5oWlodS1fHJdmXKFns0mV09ixxAXZitqiCto2A0hillYS1PEtIMjMh5ziEyPY9aXoyeZpg29fNeNmE1T1JiQWgGC9vDPZ60+QHXjcrP4AJM7GtnJ4E4V9WXp9AGOkhTPAqcaaVySoQqzKkTRZyMICq0C75D9Gxz+pNbm4MsXqyyKP+K4ffmQHfrYB7yLnKgc6kL0rJ8ddLaOju7TFeqqrYvUKYxpho8xUKw1U9lmtA9fk8ZxJuWweRxrm6yzKgLUv6yEmSvCjgfqbnS5qz+THWCx9KqHWCXMQnaXxOheNlPpCHzEaLM0YbQ0dlu5bKDrf11in3TQ24DUEomXd020Og9BvRgANeD2AT7p988Zv4ZLJ5WZYAF77rHtfAeAL+JwtQE3vbGU6VlHuAIhSD/ZR5eU6Alg1TlGYq2l9T0y9ZjQx9ilG7btKxIdGfWDggTQRxdcyg3C3LS9qD8YYnwzwjKPRJ5vV4bU5ygoauJeUKBQNTQ520lWuR0YlpiCb77EzlvsNY0fmxBpjw4OV1VPoxV1WWdXJNDZdbEOoWiiMQrngT2oKh3TQ6bei4TmXEayAKwBYAPC6Z9377R34l3piwjx4YvHk1xf3MRgAgnLKsGTINirDAVJkdTbOS2oTx2/UZznHxQdHR/jXzXXzbNPQpjK0/QavMkEdAPWaxXjGaVqRNlYym8cBQLRkTWaGrTA+Pa1n/UQNaoDZm7CTrPvyF+OWVLvUPH56osFXbXFpzndF6cVMtvhBeHFMKI+DqHfMrOO1KNe0BAD8ndt33biNSypXArAAoAFfjNZeAAIivrURoNJL+mBjsLvMjUhJDwOgKzBZLBMVUqyobFAqiIZBluOp+LsHLeIEFo8j/qhQMJteobUe1GjyOUZH5cVX7hqwc0OIpXCDFPTptAIlaTLaGyd4fl4xCzOVesNgtLFTHfBz3jel+XERcKOF//w6Fvuz5Yp6AGBqn6yLXRchu3c6JhqS4t4ybGgN34p2sR+9OUnmd/wSyiO+64ffA8ALW2ufEK9lx/A8/mXqH3CJQIOuuev28jYZOfTOeM2a/RzMHGRVrrbaK3011EYHvwGx1cEX7XsyrZSE5bpMN9cBtT4uf81kmlPe+mH6+E0ot0pnJlPWyxfG+tJbJ5yqtZdMTWRKy/cztzz0MaQtVV+FnDQOpN/jTnNcLOJYQsMxOp52++aNtxQVXRq5UoAFAI/4rh9+/9baiwB82Fo6zxwWsXnsJzY7o12aCHgO3azU6FzmtOwbmjnYawdxcV1HrU0RU8e+MSDI2l/5y2ZOf2veFM4JiOLCUDurI5jl+kI/cdVFRq93NfE5k13XPvSdannq5nqAcP4tzlIDsBxXQJ1xLPSjnAsrVnC0324Nj79918V7Id9DlSsHWADwId/9Ix8B4EUA3jcyqSmrGv8YOEzSAA6MeIDQalavvEAapFKMMTBjVzlTwVDg/pm2i8GxBKFCl5Qk9E+5K0jXljwV+2FW4Q3VJff6D3MknVVvf9L7/yLIBhBKCwPpEdVMaTJL5RGS+lTvh5nMsZwIrtJfS9Ze6xb6aKT7JQCffvvm5QkOXZMrCVgA8CHf/SP/dQde0IB34zAHBq782A3o23Kc12nQgCvMymb5dAqOmVAulgVAZCawxnIyA0vkQdPXD9KyPp591Y8Erekk9VTmYsTgijkmTKEJXVc2kiUAXGMnLMSukmJ+QfJ1hrIcQo1TjhWSsk6TuPhx/nHFjZFJOEhSpwENr0fHp96+eeMNRcMvpVwZp3uU1zzziT/XgKcC+FMgg4KClQwgdfgC9cAeaYI5k9mIbX0v0nVl5KIloHNJIWA6cjhTR8CWGQgf8W6fDWTNG3SMKbLmA7R6zcR8P9lkbO561tIdaB9QGyCTr5t63fqpfue+gdWa+OuxL1suo3lVlTVzQ1MlsHHRrB90V7O12G2xNaltftGiDZYWwSq6/Bs68Kbe8YSrBFbAFQYsAHjNM5/4vNba5/Ux2plpuemfnMOGSDq8dQR1l3ImaeLOCIIMtsA4Gg/6ZpNa6l3GcFctS+7Q5WHfrvWbd2sucXeQtA3AUcHfDFzpqk+iEw+gfhsTX193rPrn+v0tNHblH7/hWnwRbFo1LgMUCFxkda/ZEaDCagZnfvrUHc21wwP6svhYx8m6IWAGX9wfAnjS/Tdv/HJW4nLLlQYsAHj1M57w3a21L+JzDp7cVrFM50bDJEw6HRvBz1TMb5c3sLLqd/smriMtK06BDuDBvjASfQMnpWXmwKEUiGUROLq0bvI09xl1Ux2DktqrjEPNelrrl7REHYTZGGsgHyEIvMLkR9CjNbnPzHpMQWbZzFxcH1DHNVcOrQTd11vGiYn6zV+XUAgPsKwJveQxAD6vRh14Sweefv/NGz+FKyhXHrAA4NXPeMI3AvgHgB+UMnlMwqCPp8fE1knbQ+Kx2sXTvfwSVmgYI4iOay5emVdruiILA+shLZoEw2aQOTjRRMkmyZp4hsTg59smAOReHeNJipqCYpa6uCs/h1dCAvhe0T2LjJfKc7F5riAoUJV1MTNikI/AL+p3aSu3jfWmTuHlh1lgVeEi//39N2/8SFbyasi1AKwh/xsQguYcbWlqYqUFzDi8DjBd1HniL8umG0L+B2A9U3ErdKFYDIDVeRqCNom80Vmovmny6ZxtBgInSs2s3LRpxaSn4hnnLcLcmzMaiDtmdWIpMncZJFin5j8duoFMTL5PjdlcaNyocy1IVZlVMyDi/uIFq0sbiaUtelH76TurY7edQEwKXtarv3b/zRvTH2u5CnKqoXqV5EO/50e/ogFfa04jWekWKYZC2D00EFEZAyjGNaXg0DAo2W+1vivoIck/FmP6MLOKZbgmUDnVVrrstkWzCsi7oi0V7OGytQP1pSnwE2BGsK30yg3hwwJIqV9TyoTe+aFvvefOjAv1hL40sPPtB/Wt9J+0kdOJqefvQWpyGo9Drz8F8Dm3b9743tQZV0yuHWABwId97499PtD/FdDeDoBOwghWAABiSNM3Gox00/AFoB70lI2/S4b0SuQxWmP8E9eRnTB1vTHPGoOIINpiPRO/Vg9pG7Wp7EtdPCbR9+46N7HuV9B1Xkhcmdq05q9Tk09efOh9qalvJmUgL1Rr5i3Xxe0C8HsAPuv2zRvPn2a8QnItAQsAPvR7fvRJDfgetPZOfD5zF7hB5xKGRLPO5HgcTpnHZrU62/NnjqlUbM8Bi06hWucOzJhMZCZlEePArfjFzkHlIyz7mJLMYpwaMnOaAb6Py6L0qr91hu/1/PzkrI9y1Dy3jtOWS+FKWVk3r7Pq9usduPf+mzd+viz4Csp18mE5efUznvBDaO2xADQCWHavAJr7ymQKsJLz4rR19pZ92mtrvM/KdoWqgUz7eryaU73RfbZcGz6r4AOBnJswrvQ2Snh/VGoX/NQZCroztjOYgZWJmfitpuxCfFe+iqRjBiupfQF802fkc+6x7iGi6j9YP6nPqtkLAqsstlits0BJ6xcpbcLI3XkMPQDg064TWAHXGLAA4Feffs+LATy6AW8gl9YiCg6FL2Uyj1s1m1dAQqrJXrMOd7bRjiHPJ3bC9nCtFVNk6NFdQ+WS7YAJiHpfWZABCqJ/dnYba7CuMDDlTa7VFxY2+sPY+qeOcA9CBx8hqZrKPNAdxK71RqKkfeVON9MnjI9K91nAq+jrfVdy71tWetzjcfrnG9qn3b5544FU+BWXaw1YAPCrT7/nlwF8Kjp+WVkV4GwPHTs0yTTqHbaK2ruQjDFwRPvppMExEvZhkRLOOOj0DnIUk7WofjbJ/O5b5FDd2Iszc1o2ywIhJdQZKnsT2YV3oACJ7r87AuJ05jp90+3XvuV+jdKY4RErtFcGNVeY6JM3HEgXwTX1jc6By3+axq5JNh6f14Gbt2/e+PVU4DWQaw9YAPDA0+95PYBHA7hfT44JGYMM5XPZGue3LjVlKZEprK2ycbKbA1f+oVV3WkZmFW6bPlQ/d+waAEkp/Ok9KnxdJqfXwLco6BuuO2d0xVSD7sre1q1WrVfBw5n4w3nPJj0dz9wAXgqTtNJBr3deC53Gvk9cJgG+72lLBPvvVppcB9kAa8gDT7/nTQA+A8D3+0E9H6fuGUE6n+k8HTZzFMeHp7VWJRQRMKgoIjiiRxsFO4BtIb1TVYAkOq+tEXFeaTqqR4pWn5yYSsRIHHAGBqZlZ1rmTM4IfI31IdZl/qiiHgEpZ8oF3VAwUO1rqbtpvf9/e+cWqtdRxfHfSgsiMa8itsWHNj3pJRjsyQ0Vcr4kilDQllLEu6CCqA9enqw+idUKig9e+iRYC7VFe0nbWEybpG3a9DQGKoIkplqhICiFKqd9MGjGh2/PzFprZn/npCZN0rP+kJz97bmtPd+e//6vNbPnK/oz29Gnq1Ku7etpnvK4sNIqX9OPEunD5/tPyZ9tjD1qVy0u//Vv1yDyNeBW4KLCC1pc+ME1oImduDVLqHrG4i1j9VW+0a+nDGcHA2d9mTPXNjm7WrWGulMK2+JPZ+jV+tne5PMaF1KqK136ZZqx2mx1S39mzaZZ23SjbvZNF3ffr98yyLflChlb/T5glVT1OdvnrV3yisDnnt5x3V0EgrDGcMW9+94N/DKRLvUxjOlhp+v0ja5uVrs4U6ePEIRSXq0wsnsh1TVGfkjagzEXTNsDdRcL8CTmOkDZ4W3vE0O7w6q3y6jGctgMYdVvnYLenpETug87Hu6y369pVmdRFVr7c3prc/97EyD9nsTNhxfm/9QaszoRLuEInr9x91PAJkEeBoxO90HiEhtJKl7lbn4byNYLQjtqRrlbp5zrpV2HHEurDsfIE8gPKkc8+jqa3RDSSJ1F5VWHx+pB1Yof6B2bTNHSheIShqLJKixTXOpXVYL/OqiOimMtR1Zi61zuGlqyrp97MUsdcpDmUtPtINuCrCxCYS2DK+7bt4bEVxD5DqSLR569U/Ruanruy5DZFq0HysXrKiYjDaZ/TdDaEc8sZ3HWosb6krd1AfWKJa/GKq26WrMadK/mtI32zi+vrrza63na9UEztDAYaVWvVVBiLn+kHyt3G1Vld48dYUf3gBCRJVL67OGF+bv7ja1uBGGtEFfcu287wt2CXObTxuJQK/2BhMoZdZhnl9G7fKqSoRE1yJxKGNumuIdZsbZlX9tRzGQnKnTcxpXr9EE7nJdp1+fuklmG2766k8WsBbMMpOy1C0zLw0hsea8Arfvv4nGUr/+5wQU8MXrhqxzhEq4Qz9+4+7AgmxI8mO/D6U0mdQcAh/w7h2U9lgnAKpQKhwB6SmZbmHqk8mUY8qr/SgxshIjsuXGKyLN04F1TO1hzip6h6y4JwZKVXjkuLs0ieZ6mDvX+BoaZOk291TgV6LaKqOQbyK+qykxVHTWaHzK5LqWoe7N+Ja0a+hMS24OsZiMU1mli/X2PSoIvC9wmIhfrmFWrGrTKKWddHutyjA/XfHOLVVW5ymTby+17WPfU2WLa8R9aSDHe1mBiQNmuHMvxddmshSS0xKlLCPzgV3mQrrmjM5SNGe13l+tuXbh+3vqQsIQ1ugvD9HAJ+MzhHfP3EFgWQVivEevve/Q6EbkdmJ+9XMDezJDMjZs9hEwzWZU1s2/kgd8Zcx3hZl5ZcbEU+xJ1H3a8tsTWM6IhBX39ro+065V1To5v+ZlBr6w6g348eC5U5SP1fHc1vaozdc4r/7DrBk/t6/dt3bAwx/4SIrI3Jb74zML8CwRWhHAJXyNO3LDraCJtS6TPC/JPn55dgTaOpGapoNz4+d02Pe5E1ZOzotLL5+K+SC1YkjRZVdt68O1VIzvQzGlZwhjqiUErLTNzhierbGvrYlHqsN4xRdnIUOc0qw/I20WjlVBLHajvphfwqlkbQqszkbkvB8VlyfdF4Ebg+iCr00MorDOAK+9/7K3AbcCn8jm/it2jPIXdrFkOVuuXYlUp9X9zutQxBr+lit6TqtqUs8y+NVq7VriXVMcmm95zuTpt5f4x5tbrqp9sUa2uxmYpMf2uFWI1xn4Tre71buFw/j/A9wW+dXhh/tVuhwRmIgjrDGL9/Y++R5CfinBtPSvGHbQE0R+knfHZdb10zKZxc5zrNNaeDkMl2jKNGR221KJK1AdPRr1dGbqzZlnINMRh/T5xp7K72L2Cjvum20u66hxz8vmlElXderpVWCMxq4PAF55ZmP9jz7zAyhAu4RnEiQ/tOiTCu1LiqynxSj6vB6UdcsOnwfUos0b5lAqmSMcBETUICwmk7G71hm0b6DFkNZxI5aVAw5OtC+ZI1reoCSqTarmWQkqVZpu4kuhfkvG2t1G+Yj921la/8qN31Zim2Wsqtac+uSWqm+/tsH1e3L+/Q/qowCTI6v9HKKyzhLkHHrsE5AfAzc2gUCzQC9IWghskzZQoUjnuwauZts2emrOv+ajcbf1Dpd7efJh/RssLpkKmA2lY5ZFJ3KqVWTNrjd34tmYo1G5d9pJnuYk+X2/L45yaUjolIj8W+Obhhfl/9RsNnC6CsM4y5h7Yvxv4IXC1Pq9duQwf3i3LARSjWIXVXxzaI8hmds1Xpo3ouGm5Hj96G1fRCZ+GIIT2QqE78HuLQD0Z6VUVo0s9MsH1Yoodgm2uXdnsJ0Ca2cWpzU+lxJcWJ5tX1W6grwfCJTzLOP7ByT4RNgrcBDxXYixSnagaBIay2DPPGKq4TDNYG7doCq+sxnYDILtbamatEmMdipLNVYPZp2sFkmcru8sPcPlQruJQkXXRXB26HkVWTQPKBcx//RsBDYEn36epw9012G8fHgA8BkxA3htkdXYQCut1xIY9+wX4APANEtsbF0/JlelhO5vlVdXYDNyYO1VdOHcs1qWyEwOpGbQdL8mJkkrG2h0ErZw6rl53dtR0jiGR2k4tr6prVKztI732qxNk980z6go+lBLfXpxsfqZfOHCmEIR1DrBhzwGBtEOQWxJpZ285QHVn6mBas8xSiVKFIbVaqffa6sDvEF5z0B/MJo6kVdYwsNeIcGp41UivsF/J3lx2jZRat+XaaWzp2J7bXUksqqQrwu/sy5VE+FVK3Lo42fxc90ICZxxBWOcYG/Yc2CZwC3A9tCRlpu493MBukmcS0VRa1QFp8yxHalqdmZ+dd/boeFq7RKH9a4LxbjmI6ZQiw5wuUkQzSooNNzV+X8nnW0ik/wrcCfLdxcnmY23lgbOJIKzzBFftObAJ+DoiNwnI2J7iM9/Ly1ld4EV7X4Y8lDzyvGiTFWkM8DN0tZzYwj74b63q2G7rSp3z/sqNaGrKz9ibvecujivKk8DPIH1vcbLlha7xgbOOIKzzDFftOXAl8GkR+RhwqU7rvR/oMWuFvVdOdbGpdDlmjXOHcpzI5O+qFQxp1Rm6fpwou629LYVLulFWI23C7DRl11g/tUtO5Fgi3SHw88XJlr8ROKcIwjpPcfWDBy8CdgAfR7iJxNquIhgwvmapkzcX6JQ36fq1IRHSqc4uEcyIA/k82sUbCa5nFxMsR3VMru1a6eauS8yShLp31Yz+El4icZcId4AcXZxsHnPKA68zgrAuAFz94MG1InJDIn1CkF2AjKooQyIt/Lomc9QjBLWDgnEZvYLSbupybhctEfW22LFkZN3SRhl2eccRqVJXlsUA4WRKaY8gv0B45NnJlpNtjYFzjSCsCwzXPPT4JcBHgE8C14B2b6C6MtNjn+ZljQtltbFwk6vvfo0SEnRn2qQ1o9TjY2N2yUVq8w15NTkVMnfEWf8IivKeBu4A7nl255aXmwsJnFcIwrpAcc1DjwuwaYh1vZ+BvKB+qTZgPYxexwh6TNe8tabmBmlDTCbn7MC6XZ6QvNpxDCPtKXO+P4HQUXzoNE6lxFER9oLc+ezOLc/7SwycvwjCeoPg2ocffxvIDmAiMElweUtc7WwgJQ081fmFpF7p5DyUUu6dQWp+rayyLbmUD/6zDKGZ9x/dzGmpWxkuwh8S7BdkfyI9cWTn1mb/ssCFgSCsNyg2PvzEOxAWUmIiwoTEJQAo0mrcQQOrwHJybwfRJvCtYls99ImrpmUhWD5TY2PltRhpXcCUErJGIHEC2A/sRzh4ZOfWf6y44wLnNYKwVgE27n1SIK0HmQALwHbgMsC5Z/0Y1TSDI4nerGAp76fseq5gz1KtsByR6QNLdqcS6S+CHAIOAAeO7Nr64qz+CFy4CMJapdi498m1IrKelDYkmBNhTpC5BHMCa3vKyygqxpcUmHhWjrx7AnKxsnJON5yV0zTTyyIcT4njAseB4yJyDPjzkV1b/30GuiRwASAIK2Dwzt8cEuDtCHPAHIkNwBxwKcI6YJ0g6xLpYk1W/dehLVGZ4L89f5LEEsJSSiyJ8FcGUgKOC3IMeOl3u7fFeqhVjiCswGlj0yNPCfAmGAhsSmRvSWl6nGDdGpF1KfFmEV4dSGgJZAnSEsgrwJJMf+Jq6ej7tseap0AgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEAgEAoFAIBAIXDj4Hwfg2Tzawdz4AAAAAElFTkSuQmCC';

	const img$4 = 'data:image/png;base64,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';

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/dynamics/src/NearbyDevices.html generated by Svelte v2.16.1 */



	function identifyThisDevice({ thisDeviceName, selectedDeviceKey, homebase, homebaseName }) { // hardcore computed property which returns a function which receives further dependent data to calculate the result... this this computed property has some local component store properties and a template object as inputs (template expressions can be used in helpers OR computed properties)

	  return (device) => {
	    const addedProps = {
	      // thisDevice: thisDeviceName == device.deviceName,
	      selectedDevice: selectedDeviceKey == device.deviceKey, // todo! use device keys instead!!
	      homebase: homebaseName ? device.deviceName == homebaseName : device.deviceName == thisDeviceName,
	      homebaseName
	    };

	    return Object.assign(device, addedProps);
	  }
	}

	function homebaseSymbolVisible({ thisDeviceName, selectedDeviceName, homebase, disableDeviceSelector, viewDef }) {
	  return (view) => {

	    if(disableDeviceSelector || !viewDef || viewDef.deviceSelector == 'false' || !homebase) {
	      return false;
	    }

	    return true;
	  }
	}

	function tunnelingSymbolVisible({ homebase, disableDeviceSelector, viewDef }) {
	  return (view) => {

	    if(disableDeviceSelector || !viewDef || viewDef.deviceSelector == 'false' || homebase) {
	      return false;
	    }

	    return true;
	  }
	}

	function homebaseEscapeSymbolVisible({ thisDeviceName, selectedDeviceName }) {
	  return (connected, view) => {
	    if(view == 'home' && thisDeviceName != selectedDeviceName && !connected) {
	      return true;
	    }
	  }
	}

	function nearbyDeviceStyles(el) {
		return getNearbyDeviceStyles(el);
	}

	var methods$a = {
	  toggleNearbyDevices() { // duplication from ActionBar.html just to handle the 'd' keypress shortcut !!
	    const isVisible = this.store.get().nearbyDevicesMenuVisible;
	    this.store.set({ nearbyDevicesMenuVisible: !isVisible });
	  },
	  morphIntoNearbyDevice({ deviceName, deviceKey, ip, guiPort }) {
	    if(deviceName == this.get().thisDeviceName) { // todo - change
	      console.log(`Morphing back into /this/ device`);
	      this.store.switch();
	    } else {
	      console.log(`Morphing into ${deviceName}:${ip}`);
	      this.store.switch({ deviceName, deviceKey, ip, port: guiPort }); // we pass deviceName in case we cannot actually connect to device -> se still fill the state with correct name
	    }
	  },
	  switchToThisDevice() {
	    this.store.switch();
	  },
	  dumpInfo() {
	    console.log(this.get());
	  }
	};

	function oncreate$f() {
	  this.set({ homebaseImgInline: img$3, tunnelingImgInline: img$4 });

	  // adds thisDeviceName, selectedDeviceName, and optionally any part of definition (from this device.def)
	  this.store.entangle(this);

	  this.set({ lineHeight: '1.2' });

	  this.listener = this.store.on('state', ({ current, changed, previous }) => {
	    if(current.thisDeviceState) { // todo: think if we really need to observe all state changes... AND if we get all differences inside thisDeviceState when we observe multiconnected store "state" event
	      const nearbyDevices = current.nearbyDevices;

	      if(nearbyDevices)  {

	        // count visible devices (property hiddenInGui : false)... a bit convoluted but it's simple
	        // ?? :
	        const count = nearbyDevices.filter(({ hiddenInGui }) => !hiddenInGui).length;

	        this.set({ nearbyDevicesCount: count });

	        if(count < 7) {
	          this.set({ lineHeight: '3.2' });
	        } else if(count < 10) {
	          this.set({ lineHeight: '2.4' });
	        } else if(count <= 15) {
	          this.set({ lineHeight: '1.2' });
	        } else {
	          this.set({ lineHeight: '1.0' });
	        }
	      }
	    }
	  });

	}
	function ondestroy() {
	  this.listener.cancel();
	}
	const getNearbyDeviceStyles = ({ stale, hiddenInGui, thisDevice, selectedDevice, homebase, homebaseName, homebaseIsDefined }) => (
	  `
    color: ${stale ? 'white' : 'black'};
    font-weight: ${homebase ? 'bold' : 'normal'};
    font-style: ${homebaseName && thisDevice ? 'italic' : 'normal'};
    background-color: ${stale ? 'black' : (selectedDevice ? '#26A9B7' : '')};
    display: ${hiddenInGui ? 'none' : 'block'};
  `
	);

	const file$i = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/dynamics/src/NearbyDevices.html";

	function click_handler$1(event) {
		const { component, ctx } = this._svelte;

		component.morphIntoNearbyDevice(ctx.device);
	}

	function get_each_context$4(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.device = list[i];
		return child_ctx;
	}

	function create_main_fragment$l(component, ctx) {
		var text0, div1, div0, text1, text2, current;

		var if_block0 = (ctx.loaded && ctx.$nearbyDevicesMenuVisible && ctx.viewDef && ctx.viewDef.deviceSelector != 'false') && create_if_block_3$8(component, ctx);

		var if_block1 = (ctx.homebaseImgInline) && create_if_block_2$9(component, ctx);

		var if_block2 = (ctx.tunnelingImgInline) && create_if_block_1$e(component, ctx);

		var if_block3 = (ctx.homebaseImgInline) && create_if_block$j(component, ctx);

		return {
			c: function create() {
				if (if_block0) if_block0.c();
				text0 = createText("\n\n");
				div1 = createElement("div");
				div0 = createElement("div");
				if (if_block1) if_block1.c();
				text1 = createText("\n\n    ");
				if (if_block2) if_block2.c();
				text2 = createText("\n\n    ");
				if (if_block3) if_block3.c();
				div0.id = "deviceSelector";
				div0.className = "svelte-tcxsiw";
				addLoc(div0, file$i, 38, 2, 1719);
				div1.id = "bottom_icons";
				div1.className = "svelte-tcxsiw";
				addLoc(div1, file$i, 36, 0, 1692);
			},

			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, text0, anchor);
				insert(target, div1, anchor);
				append(div1, div0);
				if (if_block1) if_block1.m(div0, null);
				append(div0, text1);
				if (if_block2) if_block2.m(div0, null);
				append(div0, text2);
				if (if_block3) if_block3.m(div0, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded && ctx.$nearbyDevicesMenuVisible && ctx.viewDef && ctx.viewDef.deviceSelector != 'false') {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_3$8(component, ctx);
						if_block0.c();
						if_block0.m(text0.parentNode, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.homebaseImgInline) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_2$9(component, ctx);
						if_block1.c();
						if_block1.m(div0, text1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.tunnelingImgInline) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_1$e(component, ctx);
						if_block2.c();
						if_block2.m(div0, text2);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (ctx.homebaseImgInline) {
					if (if_block3) {
						if_block3.p(changed, ctx);
					} else {
						if_block3 = create_if_block$j(component, ctx);
						if_block3.c();
						if_block3.m(div0, null);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block0) if_block0.d(detach);
				if (detach) {
					detachNode(text0);
					detachNode(div1);
				}

				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
			}
		};
	}

	// (3:0) {#if loaded && $nearbyDevicesMenuVisible && viewDef && viewDef.deviceSelector != 'false'}
	function create_if_block_3$8(component, ctx) {
		var if_block_anchor;

		var if_block = (!ctx.disableDeviceSelector) && create_if_block_4$8(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (!ctx.disableDeviceSelector) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_4$8(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (9:2) {#if !disableDeviceSelector}
	function create_if_block_4$8(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.$nearbyDevices && ctx.$nearbyDevices.length > 0) && create_if_block_5$8(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.$nearbyDevices && ctx.$nearbyDevices.length > 0) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_5$8(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (11:4) {#if $nearbyDevices && $nearbyDevices.length > 0}
	function create_if_block_5$8(component, ctx) {
		var div1, text0, div0, text1, text2;

		var each_value = ctx.$nearbyDevices.filter(d => d.thisDevice || d.isRPi).sort((a, b) => a.deviceName < b.deviceName ? -1 : (a.deviceName > b.deviceName ? 1 : 0));

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$4(component, get_each_context$4(ctx, each_value, i));
		}

		return {
			c: function create() {
				div1 = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text0 = createText("\n        ");
				div0 = createElement("div");
				text1 = createText(ctx.nearbyDevicesCount);
				text2 = createText(" devices");
				div0.className = "devices_total svelte-tcxsiw";
				addLoc(div0, file$i, 26, 8, 1570);
				setStyle(div1, "line-height", "" + ctx.lineHeight + "em");
				div1.id = "nearby_devices";
				div1.className = "svelte-tcxsiw";
				toggleClass(div1, "nonRPi", !ctx.atRPi);
				addLoc(div1, file$i, 11, 6, 850);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div1, null);
				}

				append(div1, text0);
				append(div1, div0);
				append(div0, text1);
				append(div0, text2);
			},

			p: function update(changed, ctx) {
				if (changed.identifyThisDevice || changed.$nearbyDevices) {
					each_value = ctx.$nearbyDevices.filter(d => d.thisDevice || d.isRPi).sort((a, b) => a.deviceName < b.deviceName ? -1 : (a.deviceName > b.deviceName ? 1 : 0));

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$4(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$4(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div1, text0);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (changed.nearbyDevicesCount) {
					setData(text1, ctx.nearbyDevicesCount);
				}

				if (changed.lineHeight) {
					setStyle(div1, "line-height", "" + ctx.lineHeight + "em");
				}

				if (changed.atRPi) {
					toggleClass(div1, "nonRPi", !ctx.atRPi);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (16:12) {#if device.hasErrors}
	function create_if_block_7$5(component, ctx) {
		var span;

		return {
			c: function create() {
				span = createElement("span");
				span.textContent = "!";
				span.className = "error svelte-tcxsiw";
				addLoc(span, file$i, 15, 34, 1264);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (21:14) {#if device.ip}
	function create_if_block_6$5(component, ctx) {
		var text_value = ctx.device.ip, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$nearbyDevices) && text_value !== (text_value = ctx.device.ip)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (13:8) {#each $nearbyDevices.filter(d => d.thisDevice || d.isRPi).sort((a, b) => a.deviceName < b.deviceName ? -1 : (a.deviceName > b.deviceName ? 1 : 0)) as device}
	function create_each_block$4(component, ctx) {
		var div, text0_value = ctx.device.deviceName, text0, text1, text2_value = ctx.device.playing ? (ctx.device.mediaType == 'video' ? ' ▶' : ' ♫' ) : '', text2, text3, span, div_style_value;

		var if_block0 = (ctx.device.hasErrors) && create_if_block_7$5();

		var if_block1 = (ctx.device.ip) && create_if_block_6$5(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText(text0_value);
				text1 = createText("\n\n            ");
				text2 = createText(text2_value);
				text3 = createText("\n\n            ");
				span = createElement("span");
				if (if_block1) if_block1.c();
				span.className = "ip svelte-tcxsiw";
				addLoc(span, file$i, 19, 12, 1413);

				div._svelte = { component, ctx };

				addListener(div, "click", click_handler$1);
				div.className = "device svelte-tcxsiw";
				div.style.cssText = div_style_value = nearbyDeviceStyles(ctx.identifyThisDevice(ctx.device));
				addLoc(div, file$i, 13, 10, 1112);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, text0);
				append(div, text1);
				append(div, text2);
				append(div, text3);
				append(div, span);
				if (if_block1) if_block1.m(span, null);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (ctx.device.hasErrors) {
					if (!if_block0) {
						if_block0 = create_if_block_7$5();
						if_block0.c();
						if_block0.m(div, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if ((changed.$nearbyDevices) && text0_value !== (text0_value = ctx.device.deviceName)) {
					setData(text0, text0_value);
				}

				if ((changed.$nearbyDevices) && text2_value !== (text2_value = ctx.device.playing ? (ctx.device.mediaType == 'video' ? ' ▶' : ' ♫' ) : '')) {
					setData(text2, text2_value);
				}

				if (ctx.device.ip) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_6$5(component, ctx);
						if_block1.c();
						if_block1.m(span, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				div._svelte.ctx = ctx;
				if ((changed.identifyThisDevice || changed.$nearbyDevices) && div_style_value !== (div_style_value = nearbyDeviceStyles(ctx.identifyThisDevice(ctx.device)))) {
					div.style.cssText = div_style_value;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				removeListener(div, "click", click_handler$1);
			}
		};
	}

	// (43:4) {#if homebaseImgInline}
	function create_if_block_2$9(component, ctx) {
		var img;

		function click_handler_1(event) {
			component.toggleNearbyDevices();
		}

		return {
			c: function create() {
				img = createElement("img");
				addListener(img, "click", click_handler_1);
				img.src = ctx.homebaseImgInline;
				img.alt = "deviceSelector";
				img.className = "svelte-tcxsiw";
				toggleClass(img, "hidden", !ctx.homebaseSymbolVisible(ctx.$view));
				addLoc(img, file$i, 43, 6, 1818);
			},

			m: function mount(target, anchor) {
				insert(target, img, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.homebaseImgInline) {
					img.src = ctx.homebaseImgInline;
				}

				if ((changed.homebaseSymbolVisible || changed.$view)) {
					toggleClass(img, "hidden", !ctx.homebaseSymbolVisible(ctx.$view));
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(img);
				}

				removeListener(img, "click", click_handler_1);
			}
		};
	}

	// (47:4) {#if tunnelingImgInline}
	function create_if_block_1$e(component, ctx) {
		var img;

		function click_handler_1(event) {
			component.toggleNearbyDevices();
		}

		return {
			c: function create() {
				img = createElement("img");
				addListener(img, "click", click_handler_1);
				img.src = ctx.homebaseImgInline;
				img.alt = "deviceSelector";
				img.className = "svelte-tcxsiw";
				toggleClass(img, "hidden", !ctx.tunnelingSymbolVisible(ctx.$view));
				addLoc(img, file$i, 47, 6, 1995);
			},

			m: function mount(target, anchor) {
				insert(target, img, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.homebaseImgInline) {
					img.src = ctx.homebaseImgInline;
				}

				if ((changed.tunnelingSymbolVisible || changed.$view)) {
					toggleClass(img, "hidden", !ctx.tunnelingSymbolVisible(ctx.$view));
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(img);
				}

				removeListener(img, "click", click_handler_1);
			}
		};
	}

	// (51:4) {#if homebaseImgInline}
	function create_if_block$j(component, ctx) {
		var img;

		function click_handler_1(event) {
			component.switchToThisDevice();
		}

		return {
			c: function create() {
				img = createElement("img");
				addListener(img, "click", click_handler_1);
				img.src = ctx.homebaseImgInline;
				img.alt = "switchToThisDevice";
				img.className = "svelte-tcxsiw";
				toggleClass(img, "hidden", !ctx.homebaseEscapeSymbolVisible(ctx.$connected, ctx.$view));
				addLoc(img, file$i, 51, 6, 2172);
			},

			m: function mount(target, anchor) {
				insert(target, img, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.homebaseImgInline) {
					img.src = ctx.homebaseImgInline;
				}

				if ((changed.homebaseEscapeSymbolVisible || changed.$connected || changed.$view)) {
					toggleClass(img, "hidden", !ctx.homebaseEscapeSymbolVisible(ctx.$connected, ctx.$view));
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(img);
				}

				removeListener(img, "click", click_handler_1);
			}
		};
	}

	function NearbyDevices(options) {
		this._debugName = '<NearbyDevices>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<NearbyDevices> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["nearbyDevicesMenuVisible","nearbyDevices","view","connected"]), options.data);
		this.store._add(this, ["nearbyDevicesMenuVisible","nearbyDevices","view","connected"]);

		this._recompute({ thisDeviceName: 1, selectedDeviceKey: 1, homebase: 1, homebaseName: 1, selectedDeviceName: 1, disableDeviceSelector: 1, viewDef: 1 }, this._state);
		if (!('thisDeviceName' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'thisDeviceName'");
		if (!('selectedDeviceKey' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'selectedDeviceKey'");
		if (!('homebase' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'homebase'");
		if (!('homebaseName' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'homebaseName'");
		if (!('selectedDeviceName' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'selectedDeviceName'");
		if (!('disableDeviceSelector' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'disableDeviceSelector'");
		if (!('viewDef' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'viewDef'");
		if (!('loaded' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'loaded'");
		if (!('$nearbyDevicesMenuVisible' in this._state)) console.warn("<NearbyDevices> was created without expected data property '$nearbyDevicesMenuVisible'");
		if (!('$nearbyDevices' in this._state)) console.warn("<NearbyDevices> was created without expected data property '$nearbyDevices'");
		if (!('lineHeight' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'lineHeight'");
		if (!('atRPi' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'atRPi'");

		if (!('nearbyDevicesCount' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'nearbyDevicesCount'");
		if (!('homebaseImgInline' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'homebaseImgInline'");

		if (!('$view' in this._state)) console.warn("<NearbyDevices> was created without expected data property '$view'");
		if (!('tunnelingImgInline' in this._state)) console.warn("<NearbyDevices> was created without expected data property 'tunnelingImgInline'");


		if (!('$connected' in this._state)) console.warn("<NearbyDevices> was created without expected data property '$connected'");
		this._intro = !!options.intro;

		this._handlers.destroy = [ondestroy, removeFromStore];

		this._fragment = create_main_fragment$l(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$f.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(NearbyDevices.prototype, protoDev);
	assign(NearbyDevices.prototype, methods$a);

	NearbyDevices.prototype._checkReadOnly = function _checkReadOnly(newState) {
		if ('identifyThisDevice' in newState && !this._updatingReadonlyProperty) throw new Error("<NearbyDevices>: Cannot set read-only property 'identifyThisDevice'");
		if ('homebaseSymbolVisible' in newState && !this._updatingReadonlyProperty) throw new Error("<NearbyDevices>: Cannot set read-only property 'homebaseSymbolVisible'");
		if ('tunnelingSymbolVisible' in newState && !this._updatingReadonlyProperty) throw new Error("<NearbyDevices>: Cannot set read-only property 'tunnelingSymbolVisible'");
		if ('homebaseEscapeSymbolVisible' in newState && !this._updatingReadonlyProperty) throw new Error("<NearbyDevices>: Cannot set read-only property 'homebaseEscapeSymbolVisible'");
	};

	NearbyDevices.prototype._recompute = function _recompute(changed, state) {
		if (changed.thisDeviceName || changed.selectedDeviceKey || changed.homebase || changed.homebaseName) {
			if (this._differs(state.identifyThisDevice, (state.identifyThisDevice = identifyThisDevice(state)))) changed.identifyThisDevice = true;
		}

		if (changed.thisDeviceName || changed.selectedDeviceName || changed.homebase || changed.disableDeviceSelector || changed.viewDef) {
			if (this._differs(state.homebaseSymbolVisible, (state.homebaseSymbolVisible = homebaseSymbolVisible(state)))) changed.homebaseSymbolVisible = true;
		}

		if (changed.homebase || changed.disableDeviceSelector || changed.viewDef) {
			if (this._differs(state.tunnelingSymbolVisible, (state.tunnelingSymbolVisible = tunnelingSymbolVisible(state)))) changed.tunnelingSymbolVisible = true;
		}

		if (changed.thisDeviceName || changed.selectedDeviceName) {
			if (this._differs(state.homebaseEscapeSymbolVisible, (state.homebaseEscapeSymbolVisible = homebaseEscapeSymbolVisible(state)))) changed.homebaseEscapeSymbolVisible = true;
		}
	};

	const img$5 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgEAAAG2CAYAAADmwVUxAAAEvWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgdGlmZjpJbWFnZUxlbmd0aD0iNDM4IgogICB0aWZmOkltYWdlV2lkdGg9IjUxMyIKICAgdGlmZjpSZXNvbHV0aW9uVW5pdD0iMiIKICAgdGlmZjpYUmVzb2x1dGlvbj0iMzAwLjAiCiAgIHRpZmY6WVJlc29sdXRpb249IjMwMC4wIgogICBleGlmOlBpeGVsWERpbWVuc2lvbj0iNTEzIgogICBleGlmOlBpeGVsWURpbWVuc2lvbj0iNDM4IgogICBleGlmOkNvbG9yU3BhY2U9IjEiCiAgIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiCiAgIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIKICAgeG1wOk1vZGlmeURhdGU9IjIw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';

	const img$6 = 'data:image/png;base64,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';

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/Suntime.html generated by Svelte v2.16.1 */



	function oncreate$g() {
	  this.set({ sunriseImgInline: img$5, sunsetImgInline: img$6 });

	  this.store.entangle(this);
	}
	const file$j = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/Suntime.html";

	function create_main_fragment$m(component, ctx) {
		var div, text, current;

		var if_block0 = (ctx.sunrise) && create_if_block_2$a(component, ctx);

		var if_block1 = (ctx.sunset) && create_if_block$k(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block0) if_block0.c();
				text = createText("\n\n  ");
				if (if_block1) if_block1.c();
				div.id = "suntime";
				addLoc(div, file$j, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, text);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.sunrise) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_2$a(component, ctx);
						if_block0.c();
						if_block0.m(div, text);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.sunset) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block$k(component, ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (2:2) {#if sunrise}
	function create_if_block_2$a(component, ctx) {
		var div1, div0, text0, span, text1;

		var if_block = (ctx.sunriseImgInline) && create_if_block_3$9(component, ctx);

		return {
			c: function create() {
				div1 = createElement("div");
				div0 = createElement("div");
				if (if_block) if_block.c();
				text0 = createText("\n        ");
				span = createElement("span");
				text1 = createText(ctx.sunrise);
				span.className = "svelte-1gwsqnl";
				addLoc(span, file$j, 7, 8, 288);
				div0.className = "inner svelte-1gwsqnl";
				addLoc(div0, file$j, 3, 6, 160);
				div1.id = "sunrise";
				div1.className = "svelte-1gwsqnl";
				toggleClass(div1, "protect_visibility", ctx.viewDef && ctx.viewDef.protectVisibility && (!ctx.$player || ctx.$player.paused));
				addLoc(div1, file$j, 2, 4, 39);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				if (if_block) if_block.m(div0, null);
				append(div0, text0);
				append(div0, span);
				append(span, text1);
			},

			p: function update(changed, ctx) {
				if (ctx.sunriseImgInline) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_3$9(component, ctx);
						if_block.c();
						if_block.m(div0, text0);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.sunrise) {
					setData(text1, ctx.sunrise);
				}

				if ((changed.viewDef || changed.$player)) {
					toggleClass(div1, "protect_visibility", ctx.viewDef && ctx.viewDef.protectVisibility && (!ctx.$player || ctx.$player.paused));
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (5:8) {#if sunriseImgInline}
	function create_if_block_3$9(component, ctx) {
		var img;

		return {
			c: function create() {
				img = createElement("img");
				img.src = ctx.sunriseImgInline;
				img.alt = "sunrise";
				img.className = "svelte-1gwsqnl";
				addLoc(img, file$j, 5, 10, 221);
			},

			m: function mount(target, anchor) {
				insert(target, img, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.sunriseImgInline) {
					img.src = ctx.sunriseImgInline;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(img);
				}
			}
		};
	}

	// (13:2) {#if sunset}
	function create_if_block$k(component, ctx) {
		var div1, div0, text0, span, text1;

		var if_block = (ctx.sunsetImgInline) && create_if_block_1$f(component, ctx);

		return {
			c: function create() {
				div1 = createElement("div");
				div0 = createElement("div");
				if (if_block) if_block.c();
				text0 = createText("\n        ");
				span = createElement("span");
				text1 = createText(ctx.sunset);
				span.className = "svelte-1gwsqnl";
				addLoc(span, file$j, 18, 8, 608);
				div0.className = "inner svelte-1gwsqnl";
				addLoc(div0, file$j, 14, 6, 483);
				div1.id = "sunset";
				div1.className = "svelte-1gwsqnl";
				toggleClass(div1, "protect_visibility", ctx.viewDef && ctx.viewDef.protectVisibility && (!ctx.$player || ctx.$player.paused));
				addLoc(div1, file$j, 13, 4, 363);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				if (if_block) if_block.m(div0, null);
				append(div0, text0);
				append(div0, span);
				append(span, text1);
			},

			p: function update(changed, ctx) {
				if (ctx.sunsetImgInline) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$f(component, ctx);
						if_block.c();
						if_block.m(div0, text0);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.sunset) {
					setData(text1, ctx.sunset);
				}

				if ((changed.viewDef || changed.$player)) {
					toggleClass(div1, "protect_visibility", ctx.viewDef && ctx.viewDef.protectVisibility && (!ctx.$player || ctx.$player.paused));
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (16:8) {#if sunsetImgInline}
	function create_if_block_1$f(component, ctx) {
		var img;

		return {
			c: function create() {
				img = createElement("img");
				img.src = ctx.sunsetImgInline;
				img.alt = "sunset";
				img.className = "svelte-1gwsqnl";
				addLoc(img, file$j, 16, 10, 543);
			},

			m: function mount(target, anchor) {
				insert(target, img, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.sunsetImgInline) {
					img.src = ctx.sunsetImgInline;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(img);
				}
			}
		};
	}

	function Suntime(options) {
		this._debugName = '<Suntime>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Suntime> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["player"]), options.data);
		this.store._add(this, ["player"]);
		if (!('sunrise' in this._state)) console.warn("<Suntime> was created without expected data property 'sunrise'");
		if (!('viewDef' in this._state)) console.warn("<Suntime> was created without expected data property 'viewDef'");
		if (!('$player' in this._state)) console.warn("<Suntime> was created without expected data property '$player'");
		if (!('sunriseImgInline' in this._state)) console.warn("<Suntime> was created without expected data property 'sunriseImgInline'");
		if (!('sunset' in this._state)) console.warn("<Suntime> was created without expected data property 'sunset'");
		if (!('sunsetImgInline' in this._state)) console.warn("<Suntime> was created without expected data property 'sunsetImgInline'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$m(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$g.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Suntime.prototype, protoDev);

	Suntime.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/MediaTimePosition.html generated by Svelte v2.16.1 */

	var methods$b = {
	  seek(e) {
	    // if(!this.get().isStream) {
	      const timeposition = this.refs.timeposition;
	      const percentPos = e.offsetX / timeposition.offsetWidth;
	      this.fire('seek', { percentPos });
	    // }
	  }
	};

	function oncreate$h() {
	  this.listener = this.store.on('state', ({ current, changed, previous }) => {
	    const { player } = current;

	    if(!player) {
	      return;
	    }

	    this.set({ isStream: player.isStream });

	    const progress = this.refs.progress;
	    const timeposition = this.refs.timeposition;

	    if(progress) {
	      if(changed.frontTicker)  {
	        // WHEN PLAYING

	        if(player && player.percentposition != null) {
	          const percentage = player.percentposition;//100 * player.timeposition / player.currentMedia.duration;
	          progress.style.width = `${percentage}%`;
	        } else {
	          progress.style.width = "0%";
	        }

	        if(!player.paused && player.currentMedia && player.currentMedia.songPath) {
	          //todo: when in bottom_wide mode perhaps use #444 (and correct opacity from 0.2 to 0.5 on .progress)
	          //progress.style.background = "#aaa";
	          let bgColor = "#45FFB9";
	          if(player.timeLimit) {
	            bgColor= "#66AEB7";
	          } else if(player.limit && !player.isStream) {
	            bgColor = "#B6E29E";
	          }
	          progress.style.background = bgColor;
	        } else {
	          progress.style.background = "#444";
	        }

	        if(player.currentMedia && player.currentMedia.songPath && !player.paused) {
	          timeposition.style.cursor = 'pointer';
	        } else {
	          timeposition.style.cursor = 'default';
	        }
	      }
	    }
	  });
	}
	function ondestroy$1() {
	  this.listener.cancel();
	}
	const file$k = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/MediaTimePosition.html";

	function create_main_fragment$n(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$player && ctx.$player.currentMedia) && create_if_block$l(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$player && ctx.$player.currentMedia) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$l(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $player && $player.currentMedia}
	function create_if_block$l(component, ctx) {
		var div1, div0, text0, text1;

		var if_block0 = (ctx.$player.timeposition) && create_if_block_2$b(component, ctx);

		var if_block1 = (ctx.$player.currentMedia.duration) && create_if_block_1$g(component, ctx);

		function click_handler(event) {
			component.seek(event);
		}

		return {
			c: function create() {
				div1 = createElement("div");
				div0 = createElement("div");
				text0 = createText("\n\n    ");
				if (if_block0) if_block0.c();
				text1 = createText("\n\n    ");
				if (if_block1) if_block1.c();
				div0.className = "progress svelte-bmnwjd";
				addLoc(div0, file$k, 4, 4, 204);
				addListener(div1, "click", click_handler);
				div1.id = "timeposition";
				div1.className = "svelte-bmnwjd";
				toggleClass(div1, "bottom_slim_wide", ctx.$view != 'player');
				toggleClass(div1, "bottom_slim_times_visible", ctx.$view == 'clock');
				addLoc(div1, file$k, 2, 2, 41);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				component.refs.progress = div0;
				append(div1, text0);
				if (if_block0) if_block0.m(div1, null);
				append(div1, text1);
				if (if_block1) if_block1.m(div1, null);
				component.refs.timeposition = div1;
			},

			p: function update(changed, ctx) {
				if (ctx.$player.timeposition) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_2$b(component, ctx);
						if_block0.c();
						if_block0.m(div1, text1);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.$player.currentMedia.duration) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_1$g(component, ctx);
						if_block1.c();
						if_block1.m(div1, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (changed.$view) {
					toggleClass(div1, "bottom_slim_wide", ctx.$view != 'player');
					toggleClass(div1, "bottom_slim_times_visible", ctx.$view == 'clock');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				if (component.refs.progress === div0) component.refs.progress = null;
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				removeListener(div1, "click", click_handler);
				if (component.refs.timeposition === div1) component.refs.timeposition = null;
			}
		};
	}

	// (7:4) {#if $player.timeposition}
	function create_if_block_2$b(component, ctx) {
		var if_block_anchor;

		function select_block_type(ctx) {
			return create_else_block_1$1;
		}

		var current_block_type = select_block_type();
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type()) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			d: function destroy(detach) {
				if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (17:6) {:else}
	function create_else_block_1$1(component, ctx) {
		var div, text_value = util.songTime(ctx.Math.floor(ctx.$player.timeposition)), text;

		return {
			c: function create() {
				div = createElement("div");
				text = createText(text_value);
				div.className = "time_current svelte-bmnwjd";
				addLoc(div, file$k, 17, 8, 592);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
			},

			p: function update(changed, ctx) {
				if ((changed.Math || changed.$player) && text_value !== (text_value = util.songTime(ctx.Math.floor(ctx.$player.timeposition)))) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (22:4) {#if $player.currentMedia.duration}
	function create_if_block_1$g(component, ctx) {
		var div, text_value = util.songTime(ctx.$player.currentMedia.duration), text;

		return {
			c: function create() {
				div = createElement("div");
				text = createText(text_value);
				div.className = "time_total svelte-bmnwjd";
				addLoc(div, file$k, 22, 6, 943);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text_value !== (text_value = util.songTime(ctx.$player.currentMedia.duration))) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function MediaTimePosition(options) {
		this._debugName = '<MediaTimePosition>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<MediaTimePosition> references store properties, but no store was provided");
		}

		init(this, options);
		this.refs = {};
		this._state = assign(assign({ Math : Math }, this.store._init(["player","view"])), options.data);
		this.store._add(this, ["player","view"]);
		if (!('$player' in this._state)) console.warn("<MediaTimePosition> was created without expected data property '$player'");
		if (!('$view' in this._state)) console.warn("<MediaTimePosition> was created without expected data property '$view'");
		this._intro = !!options.intro;

		this._handlers.destroy = [ondestroy$1, removeFromStore];

		this._fragment = create_main_fragment$n(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$h.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(MediaTimePosition.prototype, protoDev);
	assign(MediaTimePosition.prototype, methods$b);

	MediaTimePosition.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/PlayInfo.html generated by Svelte v2.16.1 */



	var methods$c = {
	  select(view) {
	    this.fire('select', { view });
	  },
	  handleKeypress(event) {
	    if(util.isInputElementActive()) {
	      return
	    }

	    // SOME DUPLICATION!! in PLAYER
	    if(event.key && !event.altKey && !event.metaKey && !event.shiftKey) {
	      const $player = this.store.get().player; // somehow $player not accessible from here, but in oncreate() it was...
	      if(event.key == ' ') {
	        event.preventDefault();
	        if($player.paused) {
	          this.play();
	        } else {
	          this.pause();
	        }
	      }

	      if(event.key == 'n') {
	        this.next();
	      }

	      const step = 10;

	      if(event.code == 'ArrowRight') {
	        this.forward(step);
	      }

	      if(event.code == 'ArrowLeft') {
	        this.forward(-step);
	      }

	      if(event.keyCode == 38 || event.key == '+' || event.key == '=') {
	        this.volumeUp();
	      }

	      if(event.keyCode == 40 || event.key == '-') {
	        this.volumeDown();
	      }
	    }
	  },
	  play() {
	    this.action('play');
	  },
	  next() {
	    this.action('next');
	  },
	  shuffle() {
	    this.action('shuffle');
	  },
	  pause() {
	    this.action('pause');
	  },
	  forward(seconds) {
	    this.action('forward', { seconds });
	  },
	  volumeUp() {
	    this.action('volume_up');
	  },
	  volumeDown() {
	    this.action('volume_down');
	  },
	  action(action, payload, scope = 'player') {
	    this.store.signal('action', { action, scope, payload });
	  }
	};

	function oncreate$i() {
	  this.store.entangle(this);
	}
	const file$l = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/PlayInfo.html";

	function create_main_fragment$o(component, ctx) {
		var if_block_anchor, current;

		function onwindowkeydown(event) {
			component.handleKeypress(event);	}
		window.addEventListener("keydown", onwindowkeydown);

		var if_block = (ctx.$player && !ctx.$player.error && !ctx.$player.paused && ctx.$device && !ctx.$device.serverMode) && create_if_block$m(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$player && !ctx.$player.error && !ctx.$player.paused && ctx.$device && !ctx.$device.serverMode) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$m(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				window.removeEventListener("keydown", onwindowkeydown);

				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (3:0) {#if $player && !$player.error && !$player.paused && $device && !$device.serverMode}
	function create_if_block$m(component, ctx) {
		var div2, div1, div0, text, current;

		function select_block_type(ctx) {
			if (ctx.$player && !ctx.$player.paused && ctx.$player.currentMedia && ctx.$player.currentMedia.song) return create_if_block_2$c;
			if (ctx.$player && ctx.$player.spaced && ctx.$player.spacedTimeRemaining && !ctx.$player.timeposition) return create_if_block_3$a;
		}

		var current_block_type = select_block_type(ctx);
		var if_block0 = current_block_type && current_block_type(component, ctx);

		function click_handler(event) {
			component.select('player');
		}

		var if_block1 = (!ctx.$player.isStream) && create_if_block_1$h(component);

		return {
			c: function create() {
				div2 = createElement("div");
				div1 = createElement("div");
				div0 = createElement("div");
				if (if_block0) if_block0.c();
				text = createText("\n\n      ");
				if (if_block1) if_block1.c();
				addListener(div0, "click", click_handler);
				div0.id = "current_song";
				div0.className = "svelte-u2ttvk";
				addLoc(div0, file$l, 7, 6, 277);
				div1.className = "wrap svelte-u2ttvk";
				addLoc(div1, file$l, 6, 4, 252);
				div2.id = "playinfo";
				div2.className = "svelte-u2ttvk";
				toggleClass(div2, "protect_visibility", ctx.viewDef && ctx.viewDef.protectVisibility);
				toggleClass(div2, "nonRPi", !ctx.atRPi);
				addLoc(div2, file$l, 4, 2, 141);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div1);
				append(div1, div0);
				if (if_block0) if_block0.m(div0, null);
				append(div1, text);
				if (if_block1) if_block1.m(div1, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if (if_block0) if_block0.d(1);
					if_block0 = current_block_type && current_block_type(component, ctx);
					if (if_block0) if_block0.c();
					if (if_block0) if_block0.m(div0, null);
				}

				if (!ctx.$player.isStream) {
					if (!if_block1) {
						if_block1 = create_if_block_1$h(component);
						if_block1.c();
					}
					if_block1.i(div1, null);
				} else if (if_block1) {
					if_block1.o(function() {
						if_block1.d(1);
						if_block1 = null;
					});
				}

				if (changed.viewDef) {
					toggleClass(div2, "protect_visibility", ctx.viewDef && ctx.viewDef.protectVisibility);
				}

				if (changed.atRPi) {
					toggleClass(div2, "nonRPi", !ctx.atRPi);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block1) if_block1.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}

				if (if_block0) if_block0.d();
				removeListener(div0, "click", click_handler);
				if (if_block1) if_block1.d();
			}
		};
	}

	// (12:100) 
	function create_if_block_3$a(component, ctx) {
		var div, text0, span, text1_value = ctx.$player.spacedTimeRemaining, text1, text2, text3;

		return {
			c: function create() {
				div = createElement("div");
				text0 = createText("Waiting ");
				span = createElement("span");
				text1 = createText(text1_value);
				text2 = createText("s");
				text3 = createText(" before continuing ...");
				span.className = "svelte-u2ttvk";
				addLoc(span, file$l, 13, 20, 879);
				div.className = "spaced_time_remaining svelte-u2ttvk";
				addLoc(div, file$l, 12, 10, 823);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text0);
				append(div, span);
				append(span, text1);
				append(span, text2);
				append(div, text3);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text1_value !== (text1_value = ctx.$player.spacedTimeRemaining)) {
					setData(text1, text1_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (9:8) {#if $player && !$player.paused && $player.currentMedia && $player.currentMedia.song}
	function create_if_block_2$c(component, ctx) {
		var span, text0_value = ctx.$player.isStream ? 'STREAM' : '♪♫♬', text0, text1, text2_value = ctx.$player.currentMedia.artist ? `${ctx.$player.currentMedia.artist} - ${ctx.$player.currentMedia.song}`.substring(0,50) : ctx.$player.currentMedia.song.substring(0,50), text2;

		return {
			c: function create() {
				span = createElement("span");
				text0 = createText(text0_value);
				text1 = createText(" ");
				text2 = createText(text2_value);
				span.className = "notes svelte-u2ttvk";
				addLoc(span, file$l, 9, 10, 433);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				append(span, text0);
				insert(target, text1, anchor);
				insert(target, text2, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text0_value !== (text0_value = ctx.$player.isStream ? 'STREAM' : '♪♫♬')) {
					setData(text0, text0_value);
				}

				if ((changed.$player) && text2_value !== (text2_value = ctx.$player.currentMedia.artist ? `${ctx.$player.currentMedia.artist} - ${ctx.$player.currentMedia.song}`.substring(0,50) : ctx.$player.currentMedia.song.substring(0,50))) {
					setData(text2, text2_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
					detachNode(text1);
					detachNode(text2);
				}
			}
		};
	}

	// (19:6) {#if !$player.isStream}
	function create_if_block_1$h(component, ctx) {
		var div, current;

		var mediatimeposition = new MediaTimePosition({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				div = createElement("div");
				mediatimeposition._fragment.c();
				div.className = "time_position";
				addLoc(div, file$l, 19, 8, 1028);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				mediatimeposition._mount(div, null);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (mediatimeposition) mediatimeposition._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				mediatimeposition.destroy();
			}
		};
	}

	function PlayInfo(options) {
		this._debugName = '<PlayInfo>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<PlayInfo> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["player","device"]), options.data);
		this.store._add(this, ["player","device"]);
		if (!('$player' in this._state)) console.warn("<PlayInfo> was created without expected data property '$player'");
		if (!('$device' in this._state)) console.warn("<PlayInfo> was created without expected data property '$device'");
		if (!('viewDef' in this._state)) console.warn("<PlayInfo> was created without expected data property 'viewDef'");
		if (!('atRPi' in this._state)) console.warn("<PlayInfo> was created without expected data property 'atRPi'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$o(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$i.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(PlayInfo.prototype, protoDev);
	assign(PlayInfo.prototype, methods$c);

	PlayInfo.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/home/src/Home.html generated by Svelte v2.16.1 */



	var methods$d = {
	  go(handle) {
	    window.location.href = `http://${window.location.hostname}:${window.location.port}/${handle}`;
	  },
	  select(view) {
	    this.fire('select', { view });
	  },
	};

	function oncreate$j() {
	  this.store.entangle(this);
	}
	const file$m = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/home/src/Home.html";

	function create_main_fragment$p(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.loaded) && create_if_block$n(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$n(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if loaded}
	function create_if_block$n(component, ctx) {
		var div, text, if_block_anchor, current;

		var timeanddate_initial_data = { timeDate: ctx.timeDate };
		var timeanddate = new TimeAndDate({
			root: component.root,
			store: component.store,
			data: timeanddate_initial_data
		});

		var if_block = (ctx.$connected && ctx.$device) && create_if_block_1$i(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				timeanddate._fragment.c();
				text = createText("\n\n  ");
				if (if_block) if_block.c();
				if_block_anchor = createComment();
				div.id = "time";
				div.className = "svelte-1uq6icf";
				toggleClass(div, "protect_visibility", ctx.viewDef && ctx.viewDef.protectVisibility);
				addLoc(div, file$m, 2, 2, 16);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				timeanddate._mount(div, null);
				insert(target, text, anchor);
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var timeanddate_changes = {};
				if (changed.timeDate) timeanddate_changes.timeDate = ctx.timeDate;
				timeanddate._set(timeanddate_changes);

				if (changed.viewDef) {
					toggleClass(div, "protect_visibility", ctx.viewDef && ctx.viewDef.protectVisibility);
				}

				if (ctx.$connected && ctx.$device) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$i(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 2);

				if (timeanddate) timeanddate._fragment.o(outrocallback);

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				timeanddate.destroy();
				if (detach) {
					detachNode(text);
				}

				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (7:2) {#if $connected && $device}
	function create_if_block_1$i(component, ctx) {
		var current_block_type_index, if_block0, text0, text1, current;

		var if_block_creators = [
			create_if_block_3$b,
			create_if_block_4$9
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.$device.serverMode) return 0;
			if (ctx.environment && ctx.environment.length > 0) return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
		}

		var if_block1 = (ctx.$player) && create_if_block_2$d(component);

		var suntime_initial_data = {
		 	sunrise: ctx.timeDate.sunrise,
		 	sunset: ctx.timeDate.sunset
		 };
		var suntime = new Suntime({
			root: component.root,
			store: component.store,
			data: suntime_initial_data
		});

		return {
			c: function create() {
				if (if_block0) if_block0.c();
				text0 = createText("\n\n    ");
				if (if_block1) if_block1.c();
				text1 = createText("\n\n    ");
				suntime._fragment.c();
			},

			m: function mount(target, anchor) {
				if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
				insert(target, text0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, text1, anchor);
				suntime._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if (if_block0) {
						if_block0.o(function() {
							if_blocks[previous_block_index].d(1);
							if_blocks[previous_block_index] = null;
						});
					}

					if (~current_block_type_index) {
						if_block0 = if_blocks[current_block_type_index];
						if (!if_block0) {
							if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
							if_block0.c();
						}
						if_block0.m(text0.parentNode, text0);
					} else {
						if_block0 = null;
					}
				}

				if (ctx.$player) {
					if (!if_block1) {
						if_block1 = create_if_block_2$d(component);
						if_block1.c();
					}
					if_block1.i(text1.parentNode, text1);
				} else if (if_block1) {
					if_block1.o(function() {
						if_block1.d(1);
						if_block1 = null;
					});
				}

				var suntime_changes = {};
				if (changed.timeDate) suntime_changes.sunrise = ctx.timeDate.sunrise;
				if (changed.timeDate) suntime_changes.sunset = ctx.timeDate.sunset;
				suntime._set(suntime_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 3);

				if (if_block0) if_block0.o(outrocallback);
				else outrocallback();

				if (if_block1) if_block1.o(outrocallback);
				else outrocallback();

				if (suntime) suntime._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (~current_block_type_index) if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(text0);
				}

				if (if_block1) if_block1.d(detach);
				if (detach) {
					detachNode(text1);
				}

				suntime.destroy(detach);
			}
		};
	}

	// (13:51) 
	function create_if_block_4$9(component, ctx) {
		var div, current;

		var temperaturereading_initial_data = { tempData: ctx.environment[0], big: "true" };
		var temperaturereading = new TemperatureReading({
			root: component.root,
			store: component.store,
			data: temperaturereading_initial_data
		});

		return {
			c: function create() {
				div = createElement("div");
				temperaturereading._fragment.c();
				div.id = "environment_widget";
				div.className = "no_click svelte-1uq6icf";
				addLoc(div, file$m, 14, 6, 362);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				temperaturereading._mount(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				var temperaturereading_changes = {};
				if (changed.environment) temperaturereading_changes.tempData = ctx.environment[0];
				temperaturereading._set(temperaturereading_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (temperaturereading) temperaturereading._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				temperaturereading.destroy();
			}
		};
	}

	// (9:4) {#if $device.serverMode}
	function create_if_block_3$b(component, ctx) {
		var div, img, current;

		return {
			c: function create() {
				div = createElement("div");
				img = createElement("img");
				img.src = "/img/hot-air-balloon.png";
				img.className = "svelte-1uq6icf";
				addLoc(img, file$m, 10, 8, 253);
				div.className = "baloon svelte-1uq6icf";
				toggleClass(div, "nonRPi", !ctx.atRPi);
				addLoc(div, file$m, 9, 6, 202);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, img);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.atRPi) {
					toggleClass(div, "nonRPi", !ctx.atRPi);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (21:4) {#if $player}
	function create_if_block_2$d(component, ctx) {
		var current;

		var playinfo = new PlayInfo({
			root: component.root,
			store: component.store
		});

		playinfo.on("select", function(event) {
			component.select(event.view);
		});

		return {
			c: function create() {
				playinfo._fragment.c();
			},

			m: function mount(target, anchor) {
				playinfo._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (playinfo) playinfo._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				playinfo.destroy(detach);
			}
		};
	}

	function Home(options) {
		this._debugName = '<Home>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Home> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","device","player"]), options.data);
		this.store._add(this, ["connected","device","player"]);
		if (!('loaded' in this._state)) console.warn("<Home> was created without expected data property 'loaded'");
		if (!('viewDef' in this._state)) console.warn("<Home> was created without expected data property 'viewDef'");
		if (!('timeDate' in this._state)) console.warn("<Home> was created without expected data property 'timeDate'");
		if (!('$connected' in this._state)) console.warn("<Home> was created without expected data property '$connected'");
		if (!('$device' in this._state)) console.warn("<Home> was created without expected data property '$device'");
		if (!('atRPi' in this._state)) console.warn("<Home> was created without expected data property 'atRPi'");
		if (!('environment' in this._state)) console.warn("<Home> was created without expected data property 'environment'");
		if (!('$player' in this._state)) console.warn("<Home> was created without expected data property '$player'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$p(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$j.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Home.prototype, protoDev);
	assign(Home.prototype, methods$d);

	Home.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	function queryDifferentEnough({ searchQuery, prevQuery }) {
	  return normalizeQuery(searchQuery) != normalizeQuery(prevQuery);
	}

	function normalizeQuery(query) {
	  return query ? query.trim().replace(/\s+/g, ' ') : query;
	}

	let prevQuery = '';
	let executeQueryTimeout;
	const timeTags = []; // we can keep this growing (for now ?)  probably forever, todo: OPTIMIZE LATER and be careful when reassigning this array, learn more about event loops!

	const SEARCH_LAG_MS = 300;

	function executeSearch({ searchQuery, remoteObject, remoteMethod, searchDelay = SEARCH_LAG_MS, searchStatusCallback = () => {} }) {
	  return new Promise((success, reject) => {
	    if (searchQuery.trim() == '') {
	      timeTags.push(Date.now());

	      if (prevQuery != '') {
	        clearTimeout(executeQueryTimeout);
	        searchStatusCallback({ searching: false });
	        success([]); // empty result set
	      }

	      prevQuery = searchQuery;

	      return;
	    }

	    try {
	      if (queryDifferentEnough({ searchQuery, prevQuery })) {
	        clearTimeout(executeQueryTimeout);

	        searchStatusCallback({ searching: true });
	        // if we called this from inside a timeout, there would be a gui lag. Now we report that we are searching even before we fire off search (while we wait for possible next user input)

	        prevQuery = searchQuery;

	        executeQueryTimeout = setTimeout(() => {
	          const timeTag = Date.now();
	          timeTags.push(timeTag);

	          console.log(`Search executed: ${searchQuery}`);

	          const searchOriginHost = window.location.host;

	          remoteObject
	            .call(remoteMethod, { query: normalizeQuery(searchQuery), searchOriginHost })
	            .then(searchResults => {
	              //console.log(`Search with timeTag ${timeTag} just returned ...`);

	              const lastTimeTag = timeTags[timeTags.length - 1];
	              if (timeTag == lastTimeTag) {
	                searchStatusCallback({ searching: false, noHits: searchResults && searchResults.length == 0 });

	                success(searchResults);
	              } else {
	                console.log('Discarding search result which came out of order because a more recent result is due ...');
	                // keep the promise pending --> does not matter in frontend ... nodejs would keep a reference count ..
	                // we only use this lib on GUI!
	              }
	              // timeTags.reduce((prevTimeTag, timeTag) => {
	              //   if (prevTimeTag != null) {
	              //     if (prevTimeTag > timeTag) {
	              //       console.log(`Problem!! Results for ${normalizeQuery(searchQuery)} came back out of order ${prevTimeTag} > ${timeTag}`);
	              //     }
	              //   }
	              //   return timeTag;
	              // }, null);
	            })
	            .catch(e => {
	              searchStatusCallback({ searching: false });
	              reject(e);
	            });
	        }, searchDelay);
	      } else {
	        console.log('Query not different enough');
	      }
	    } catch (e) {
	      console.log('This error should not happen: bug in dmt-js');
	      searchStatusCallback({ searching: false });
	      reject(e);
	    }
	  });
	}

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/RibbonTop.html generated by Svelte v2.16.1 */

	var methods$e = {
	  selectMedia(mediaSourceOption) {
	    this.set({ selectMedia: mediaSourceOption });

	    if(mediaSourceOption == 'browse' || mediaSourceOption == 'search') {
	      this.defaultRibbonState();
	      this.fire('mediaSourceOption', { mediaSourceOption });
	    }
	  },
	  close() {
	    this.defaultRibbonState();
	  },
	  defaultRibbonState() {
	    this.set({ selectMedia: undefined });
	  },
	  action(action, payload) {
	    //this.set({ touchAction: action })
	    //setTimeout(() => this.set({ touchAction: undefined }), 50); // give it some (exact) time to be visible! it's too short otherwise (even if we put it after the action trigger (because this is very fast))
	    this.store.signal('action', { action, scope: this.scope, payload });
	    this.defaultRibbonState();
	  },
	  customizePlaylist(tag) {
	    this.action('sublist', { tag });
	  },
	  playRadio(radioId) {
	    this.action('play_radio', { radioId });
	    //this.defaultRibbonState();
	  }
	};

	function oncreate$k() {
	  //this.store.entangle(this);
	  this.scope = 'player';
	}
	const file$n = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/RibbonTop.html";

	function create_main_fragment$q(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$player) && create_if_block$o(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$player) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$o(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $player}
	function create_if_block$o(component, ctx) {
		var div;

		var if_block = (ctx.$player) && create_if_block_1$j(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.id = "ribbon";
				div.className = "svelte-1o0739n";
				addLoc(div, file$n, 2, 2, 17);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if (ctx.$player) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$j(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (5:4) {#if $player}
	function create_if_block_1$j(component, ctx) {
		var text0, text1, if_block2_anchor;

		var if_block0 = (!ctx.selectMedia && ctx.$device && !ctx.$device.apMode) && create_if_block_12$2(component);

		var if_block1 = (ctx.selectMedia == 'radio') && create_if_block_11$2(component);

		function select_block_type(ctx) {
			if (ctx.$player.isStream) return create_if_block_2$e;
			if (ctx.selectMedia != 'radio') return create_if_block_4$a;
		}

		var current_block_type = select_block_type(ctx);
		var if_block2 = current_block_type && current_block_type(component, ctx);

		return {
			c: function create() {
				if (if_block0) if_block0.c();
				text0 = createText("\n\n      ");
				if (if_block1) if_block1.c();
				text1 = createText("\n\n      ");
				if (if_block2) if_block2.c();
				if_block2_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, text0, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert(target, text1, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (!ctx.selectMedia && ctx.$device && !ctx.$device.apMode) {
					if (!if_block0) {
						if_block0 = create_if_block_12$2(component);
						if_block0.c();
						if_block0.m(text0.parentNode, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.selectMedia == 'radio') {
					if (!if_block1) {
						if_block1 = create_if_block_11$2(component);
						if_block1.c();
						if_block1.m(text1.parentNode, text1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
					if_block2.p(changed, ctx);
				} else {
					if (if_block2) if_block2.d(1);
					if_block2 = current_block_type && current_block_type(component, ctx);
					if (if_block2) if_block2.c();
					if (if_block2) if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			},

			d: function destroy(detach) {
				if (if_block0) if_block0.d(detach);
				if (detach) {
					detachNode(text0);
				}

				if (if_block1) if_block1.d(detach);
				if (detach) {
					detachNode(text1);
				}

				if (if_block2) if_block2.d(detach);
				if (detach) {
					detachNode(if_block2_anchor);
				}
			}
		};
	}

	// (7:6) {#if !selectMedia && $device && !$device.apMode}
	function create_if_block_12$2(component, ctx) {
		var div3, div0, text_1, div2, div1;

		function click_handler(event) {
			component.selectMedia('radio');
		}

		return {
			c: function create() {
				div3 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "Media select";
				text_1 = createText("\n          ");
				div2 = createElement("div");
				div1 = createElement("div");
				div1.textContent = "Net Radio";
				div0.className = "title media_select svelte-1o0739n";
				addLoc(div0, file$n, 8, 10, 150);
				addListener(div1, "click", click_handler);
				div1.className = "option svelte-1o0739n";
				addLoc(div1, file$n, 10, 12, 245);
				div2.className = "options svelte-1o0739n";
				addLoc(div2, file$n, 9, 10, 211);
				div3.className = "section svelte-1o0739n";
				addLoc(div3, file$n, 7, 8, 118);
			},

			m: function mount(target, anchor) {
				insert(target, div3, anchor);
				append(div3, div0);
				append(div3, text_1);
				append(div3, div2);
				append(div2, div1);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div3);
				}

				removeListener(div1, "click", click_handler);
			}
		};
	}

	// (16:6) {#if selectMedia == 'radio'}
	function create_if_block_11$2(component, ctx) {
		var div7, div0, text1, div6, div1, text3, div2, text5, div3, text7, div4, text9, div5;

		function click_handler(event) {
			component.playRadio('jazz');
		}

		function click_handler_1(event) {
			component.playRadio('rock');
		}

		function click_handler_2(event) {
			component.playRadio('classical');
		}

		function click_handler_3(event) {
			component.playRadio('progressive-trance');
		}

		function click_handler_4(event) {
			component.close();
		}

		return {
			c: function create() {
				div7 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "Internet radio station:";
				text1 = createText("\n          ");
				div6 = createElement("div");
				div1 = createElement("div");
				div1.textContent = "Jazz";
				text3 = createText("\n            ");
				div2 = createElement("div");
				div2.textContent = "Rock";
				text5 = createText("\n            \n            ");
				div3 = createElement("div");
				div3.textContent = "Classical";
				text7 = createText("\n            \n            ");
				div4 = createElement("div");
				div4.textContent = "Psytrance";
				text9 = createText("\n            \n            ");
				div5 = createElement("div");
				div5.textContent = "Close";
				div0.className = "title svelte-1o0739n";
				addLoc(div0, file$n, 17, 10, 433);
				addListener(div1, "click", click_handler);
				div1.className = "option svelte-1o0739n";
				addLoc(div1, file$n, 19, 12, 526);
				addListener(div2, "click", click_handler_1);
				div2.className = "option svelte-1o0739n";
				addLoc(div2, file$n, 20, 12, 598);
				addListener(div3, "click", click_handler_2);
				div3.className = "option svelte-1o0739n";
				addLoc(div3, file$n, 22, 12, 761);
				addListener(div4, "click", click_handler_3);
				div4.className = "option svelte-1o0739n";
				addLoc(div4, file$n, 24, 12, 930);
				addListener(div5, "click", click_handler_4);
				div5.className = "option close svelte-1o0739n";
				addLoc(div5, file$n, 26, 12, 1114);
				div6.className = "options svelte-1o0739n";
				addLoc(div6, file$n, 18, 10, 492);
				div7.className = "section svelte-1o0739n";
				addLoc(div7, file$n, 16, 8, 401);
			},

			m: function mount(target, anchor) {
				insert(target, div7, anchor);
				append(div7, div0);
				append(div7, text1);
				append(div7, div6);
				append(div6, div1);
				append(div6, text3);
				append(div6, div2);
				append(div6, text5);
				append(div6, div3);
				append(div6, text7);
				append(div6, div4);
				append(div6, text9);
				append(div6, div5);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div7);
				}

				removeListener(div1, "click", click_handler);
				removeListener(div2, "click", click_handler_1);
				removeListener(div3, "click", click_handler_2);
				removeListener(div4, "click", click_handler_3);
				removeListener(div5, "click", click_handler_4);
			}
		};
	}

	// (43:8) {#if selectMedia != 'radio'}
	function create_if_block_4$a(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.$playlist && ctx.$playlist.length > 0) && create_if_block_5$9(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.$playlist && ctx.$playlist.length > 0) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_5$9(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (32:6) {#if $player.isStream}
	function create_if_block_2$e(component, ctx) {
		var div2, div0, text_1, div1;

		var if_block = (ctx.$player.currentMedia && ctx.$player.currentMedia.songPath) && create_if_block_3$c(component);

		return {
			c: function create() {
				div2 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "Radio options";
				text_1 = createText("\n          ");
				div1 = createElement("div");
				if (if_block) if_block.c();
				div0.className = "title media_select svelte-1o0739n";
				addLoc(div0, file$n, 33, 10, 1285);
				div1.className = "options svelte-1o0739n";
				addLoc(div1, file$n, 34, 10, 1347);
				div2.className = "section svelte-1o0739n";
				addLoc(div2, file$n, 32, 8, 1253);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div2, text_1);
				append(div2, div1);
				if (if_block) if_block.m(div1, null);
			},

			p: function update(changed, ctx) {
				if (ctx.$player.currentMedia && ctx.$player.currentMedia.songPath) {
					if (!if_block) {
						if_block = create_if_block_3$c(component);
						if_block.c();
						if_block.m(div1, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (46:10) {#if $playlist && $playlist.length > 0}
	function create_if_block_5$9(component, ctx) {
		var div2, div0, text1, div1, text2, text3, if_block2_anchor;

		var if_block0 = (ctx.$playlist.length > 1) && create_if_block_10$3(component);

		var if_block1 = (ctx.$player.currentMedia && ctx.$player.currentMedia.songPath) && create_if_block_9$4(component);

		var if_block2 = (ctx.$device && ctx.$device.network == 'zaboric') && create_if_block_6$6(component, ctx);

		return {
			c: function create() {
				div2 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "Current entry";
				text1 = createText("\n              ");
				div1 = createElement("div");
				if (if_block0) if_block0.c();
				text2 = createText("\n\n                ");
				if (if_block1) if_block1.c();
				text3 = createText("\n\n            ");
				if (if_block2) if_block2.c();
				if_block2_anchor = createComment();
				div0.className = "title svelte-1o0739n";
				addLoc(div0, file$n, 47, 14, 1803);
				div1.className = "options svelte-1o0739n";
				addLoc(div1, file$n, 48, 14, 1856);
				div2.className = "section svelte-1o0739n";
				addLoc(div2, file$n, 46, 12, 1767);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				append(div2, text1);
				append(div2, div1);
				if (if_block0) if_block0.m(div1, null);
				append(div1, text2);
				if (if_block1) if_block1.m(div1, null);
				insert(target, text3, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert(target, if_block2_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.$playlist.length > 1) {
					if (!if_block0) {
						if_block0 = create_if_block_10$3(component);
						if_block0.c();
						if_block0.m(div1, text2);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.$player.currentMedia && ctx.$player.currentMedia.songPath) {
					if (!if_block1) {
						if_block1 = create_if_block_9$4(component);
						if_block1.c();
						if_block1.m(div1, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$device && ctx.$device.network == 'zaboric') {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_6$6(component, ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (detach) {
					detachNode(text3);
				}

				if (if_block2) if_block2.d(detach);
				if (detach) {
					detachNode(if_block2_anchor);
				}
			}
		};
	}

	// (50:16) {#if $playlist.length > 1}
	function create_if_block_10$3(component, ctx) {
		var div;

		function click_handler(event) {
			component.action('similar');
		}

		return {
			c: function create() {
				div = createElement("div");
				div.textContent = "Similar";
				addListener(div, "click", click_handler);
				div.className = "option similar svelte-1o0739n";
				addLoc(div, file$n, 50, 18, 1939);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(div, "click", click_handler);
			}
		};
	}

	// (54:16) {#if $player.currentMedia && $player.currentMedia.songPath}
	function create_if_block_9$4(component, ctx) {
		var div;

		function click_handler(event) {
			component.action('stop');
		}

		return {
			c: function create() {
				div = createElement("div");
				div.textContent = "■ Stop";
				addListener(div, "click", click_handler);
				div.className = "option svelte-1o0739n";
				addLoc(div, file$n, 54, 18, 2127);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(div, "click", click_handler);
			}
		};
	}

	// (60:12) {#if $device && $device.network == 'zaboric'}
	function create_if_block_6$6(component, ctx) {
		var if_block_anchor;

		function select_block_type_1(ctx) {
			if (['balkon', 'dnevna', 'spalnica'].includes(ctx.$device.deviceName)) return create_if_block_7$6;
			if (ctx.$device.deviceName == 'televizija') return create_if_block_8$5;
		}

		var current_block_type = select_block_type_1(ctx);
		var if_block = current_block_type && current_block_type(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if (if_block) if_block.d(1);
					if_block = current_block_type && current_block_type(component, ctx);
					if (if_block) if_block.c();
					if (if_block) if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (73:58) 
	function create_if_block_8$5(component, ctx) {
		var div9, div0, text1, div8, div1, text3, div2, text5, div3, text7, div4, text9, div5, text11, div6, text13, div7;

		function click_handler(event) {
			component.customizePlaylist('wolfoo');
		}

		function click_handler_1(event) {
			component.customizePlaylist('babyzoo');
		}

		function click_handler_2(event) {
			component.customizePlaylist('booba');
		}

		function click_handler_3(event) {
			component.customizePlaylist('simsala');
		}

		function click_handler_4(event) {
			component.customizePlaylist('mickey mouse');
		}

		function click_handler_5(event) {
			component.customizePlaylist('looloo');
		}

		function click_handler_6(event) {
			component.customizePlaylist('cartoons slosinh');
		}

		return {
			c: function create() {
				div9 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "Customize playlist";
				text1 = createText("\n                  ");
				div8 = createElement("div");
				div1 = createElement("div");
				div1.textContent = "Wolfoo";
				text3 = createText("\n                    ");
				div2 = createElement("div");
				div2.textContent = "BabyZoo";
				text5 = createText("\n                    ");
				div3 = createElement("div");
				div3.textContent = "Booba";
				text7 = createText("\n                    ");
				div4 = createElement("div");
				div4.textContent = "Simsala";
				text9 = createText("\n                    ");
				div5 = createElement("div");
				div5.textContent = "Mickey Mouse";
				text11 = createText("\n                    ");
				div6 = createElement("div");
				div6.textContent = "Looloo";
				text13 = createText("\n                    ");
				div7 = createElement("div");
				div7.textContent = "Slo risanke";
				div0.className = "title svelte-1o0739n";
				addLoc(div0, file$n, 74, 18, 3203);
				addListener(div1, "click", click_handler);
				div1.className = "option svelte-1o0739n";
				addLoc(div1, file$n, 76, 20, 3307);
				addListener(div2, "click", click_handler_1);
				div2.className = "option svelte-1o0739n";
				addLoc(div2, file$n, 77, 20, 3399);
				addListener(div3, "click", click_handler_2);
				div3.className = "option svelte-1o0739n";
				addLoc(div3, file$n, 78, 20, 3493);
				addListener(div4, "click", click_handler_3);
				div4.className = "option svelte-1o0739n";
				addLoc(div4, file$n, 79, 20, 3583);
				addListener(div5, "click", click_handler_4);
				div5.className = "option svelte-1o0739n";
				addLoc(div5, file$n, 80, 20, 3677);
				addListener(div6, "click", click_handler_5);
				div6.className = "option svelte-1o0739n";
				addLoc(div6, file$n, 81, 20, 3781);
				addListener(div7, "click", click_handler_6);
				div7.className = "option svelte-1o0739n";
				addLoc(div7, file$n, 82, 20, 3873);
				div8.className = "options svelte-1o0739n";
				addLoc(div8, file$n, 75, 18, 3265);
				div9.className = "section svelte-1o0739n";
				addLoc(div9, file$n, 73, 16, 3163);
			},

			m: function mount(target, anchor) {
				insert(target, div9, anchor);
				append(div9, div0);
				append(div9, text1);
				append(div9, div8);
				append(div8, div1);
				append(div8, text3);
				append(div8, div2);
				append(div8, text5);
				append(div8, div3);
				append(div8, text7);
				append(div8, div4);
				append(div8, text9);
				append(div8, div5);
				append(div8, text11);
				append(div8, div6);
				append(div8, text13);
				append(div8, div7);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div9);
				}

				removeListener(div1, "click", click_handler);
				removeListener(div2, "click", click_handler_1);
				removeListener(div3, "click", click_handler_2);
				removeListener(div4, "click", click_handler_3);
				removeListener(div5, "click", click_handler_4);
				removeListener(div6, "click", click_handler_5);
				removeListener(div7, "click", click_handler_6);
			}
		};
	}

	// (62:14) {#if ['balkon', 'dnevna', 'spalnica'].includes($device.deviceName)}
	function create_if_block_7$6(component, ctx) {
		var div6, div0, text1, div5, div1, text3, div2, text5, div3, text7, div4;

		function click_handler(event) {
			component.customizePlaylist('andreja');
		}

		function click_handler_1(event) {
			component.customizePlaylist('david');
		}

		function click_handler_2(event) {
			component.customizePlaylist('irma');
		}

		function click_handler_3(event) {
			component.customizePlaylist('otroci');
		}

		return {
			c: function create() {
				div6 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "Customize playlist";
				text1 = createText("\n                  ");
				div5 = createElement("div");
				div1 = createElement("div");
				div1.textContent = "Andreja";
				text3 = createText("\n                    ");
				div2 = createElement("div");
				div2.textContent = "David";
				text5 = createText("\n                    ");
				div3 = createElement("div");
				div3.textContent = "Irma";
				text7 = createText("\n                    ");
				div4 = createElement("div");
				div4.textContent = "Otroci";
				div0.className = "title svelte-1o0739n";
				addLoc(div0, file$n, 64, 18, 2592);
				addListener(div1, "click", click_handler);
				div1.className = "option svelte-1o0739n";
				addLoc(div1, file$n, 66, 20, 2696);
				addListener(div2, "click", click_handler_1);
				div2.className = "option svelte-1o0739n";
				addLoc(div2, file$n, 67, 20, 2790);
				addListener(div3, "click", click_handler_2);
				div3.className = "option svelte-1o0739n";
				addLoc(div3, file$n, 68, 20, 2880);
				addListener(div4, "click", click_handler_3);
				div4.className = "option svelte-1o0739n";
				addLoc(div4, file$n, 69, 20, 2968);
				div5.className = "options svelte-1o0739n";
				addLoc(div5, file$n, 65, 18, 2654);
				div6.className = "section svelte-1o0739n";
				addLoc(div6, file$n, 63, 16, 2552);
			},

			m: function mount(target, anchor) {
				insert(target, div6, anchor);
				append(div6, div0);
				append(div6, text1);
				append(div6, div5);
				append(div5, div1);
				append(div5, text3);
				append(div5, div2);
				append(div5, text5);
				append(div5, div3);
				append(div5, text7);
				append(div5, div4);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div6);
				}

				removeListener(div1, "click", click_handler);
				removeListener(div2, "click", click_handler_1);
				removeListener(div3, "click", click_handler_2);
				removeListener(div4, "click", click_handler_3);
			}
		};
	}

	// (36:12) {#if $player.currentMedia && $player.currentMedia.songPath}
	function create_if_block_3$c(component, ctx) {
		var div;

		function click_handler(event) {
			component.action('stop');
		}

		return {
			c: function create() {
				div = createElement("div");
				div.textContent = "Quit Radio";
				addListener(div, "click", click_handler);
				div.className = "option quit svelte-1o0739n";
				addLoc(div, file$n, 36, 14, 1455);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(div, "click", click_handler);
			}
		};
	}

	function RibbonTop(options) {
		this._debugName = '<RibbonTop>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<RibbonTop> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["player","device","playlist"]), options.data);
		this.store._add(this, ["player","device","playlist"]);
		if (!('$player' in this._state)) console.warn("<RibbonTop> was created without expected data property '$player'");
		if (!('selectMedia' in this._state)) console.warn("<RibbonTop> was created without expected data property 'selectMedia'");
		if (!('$device' in this._state)) console.warn("<RibbonTop> was created without expected data property '$device'");
		if (!('$playlist' in this._state)) console.warn("<RibbonTop> was created without expected data property '$playlist'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$q(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$k.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(RibbonTop.prototype, protoDev);
	assign(RibbonTop.prototype, methods$e);

	RibbonTop.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/RibbonCurrentSelectionAndMissing.html generated by Svelte v2.16.1 */

	var methods$f = {
	  selectMedia(mediaSourceOption) {
	    this.set({ selectMedia: mediaSourceOption });

	    if(mediaSourceOption == 'browse' || mediaSourceOption == 'search') {
	      this.defaultRibbonState();
	      this.fire('mediaSourceOption', { mediaSourceOption });
	    }
	  },
	  close() {
	    this.defaultRibbonState();
	  },
	  defaultRibbonState() {
	    this.set({ selectMedia: undefined });
	  },
	  setNext() {
	    this.action('set_next');
	  },
	  playNow() {
	    this.setNext();
	    this.action('next');
	  },
	  cut() {
	    this.action('cut_selected');
	  },
	  paste() {
	    this.action('paste');
	  },
	  deselectAll() {
	    this.action('deselect_all');
	  },
	  action(action, payload) {
	    this.store.signal('action', { action, scope: this.scope, payload });
	    this.defaultRibbonState();
	  },
	  playRadio(radioId) {
	    this.action('play_radio', { radioId });
	  }
	};

	function oncreate$l() {
	  this.scope = 'player';
	}
	const file$o = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/RibbonCurrentSelectionAndMissing.html";

	function create_main_fragment$r(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$player) && create_if_block$p(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$player) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$p(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $player}
	function create_if_block$p(component, ctx) {
		var div, text;

		var if_block0 = (ctx.$player.hasMissingMedia && !ctx.$player.isStream) && create_if_block_7$7(component, ctx);

		var if_block1 = (ctx.$player) && create_if_block_1$k(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block0) if_block0.c();
				text = createText("\n\n    ");
				if (if_block1) if_block1.c();
				div.id = "ribbon";
				div.className = "svelte-1mcdlju";
				addLoc(div, file$o, 2, 2, 17);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, text);
				if (if_block1) if_block1.m(div, null);
			},

			p: function update(changed, ctx) {
				if (ctx.$player.hasMissingMedia && !ctx.$player.isStream) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_7$7(component, ctx);
						if_block0.c();
						if_block0.m(div, text);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.$player) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_1$k(component, ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (5:4) {#if $player.hasMissingMedia && !$player.isStream}
	function create_if_block_7$7(component, ctx) {
		var div3, div0, text1, div2, div1, text2, text3_value = ctx.$playlistMetadata.numberOfMissingMedia, text3, text4;

		function click_handler(event) {
			component.action('remove_missing_media');
		}

		return {
			c: function create() {
				div3 = createElement("div");
				div0 = createElement("div");
				div0.textContent = "Media is missing";
				text1 = createText("\n        ");
				div2 = createElement("div");
				div1 = createElement("div");
				text2 = createText("Remove ");
				text3 = createText(text3_value);
				text4 = createText(" missing");
				div0.className = "title svelte-1mcdlju";
				addLoc(div0, file$o, 7, 8, 142);
				addListener(div1, "click", click_handler);
				div1.className = "option svelte-1mcdlju";
				addLoc(div1, file$o, 9, 10, 224);
				div2.className = "options svelte-1mcdlju";
				addLoc(div2, file$o, 8, 8, 192);
				div3.className = "section missing_media svelte-1mcdlju";
				addLoc(div3, file$o, 6, 6, 98);
			},

			m: function mount(target, anchor) {
				insert(target, div3, anchor);
				append(div3, div0);
				append(div3, text1);
				append(div3, div2);
				append(div2, div1);
				append(div1, text2);
				append(div1, text3);
				append(div1, text4);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlistMetadata) && text3_value !== (text3_value = ctx.$playlistMetadata.numberOfMissingMedia)) {
					setData(text3, text3_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div3);
				}

				removeListener(div1, "click", click_handler);
			}
		};
	}

	// (16:4) {#if $player}
	function create_if_block_1$k(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.$playlistMetadata.playlistHasSelectedEntries || ctx.$playlistMetadata.playlistClipboard) && create_if_block_2$f(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (ctx.$playlistMetadata.playlistHasSelectedEntries || ctx.$playlistMetadata.playlistClipboard) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_2$f(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (18:6) {#if $playlistMetadata.playlistHasSelectedEntries || $playlistMetadata.playlistClipboard}
	function create_if_block_2$f(component, ctx) {
		var div1, text, div0;

		function select_block_type(ctx) {
			if (ctx.$playlistMetadata.playlistHasSelectedEntries) return create_if_block_5$a;
			if (ctx.$playlistMetadata.playlistClipboard) return create_if_block_6$7;
		}

		var current_block_type = select_block_type(ctx);
		var if_block0 = current_block_type && current_block_type(component, ctx);

		function select_block_type_1(ctx) {
			if (ctx.$playlistMetadata.playlistHasSelectedEntries) return create_if_block_3$d;
			if (ctx.$playlistMetadata.playlistClipboard) return create_if_block_4$b;
		}

		var current_block_type_1 = select_block_type_1(ctx);
		var if_block1 = current_block_type_1 && current_block_type_1(component, ctx);

		return {
			c: function create() {
				div1 = createElement("div");
				if (if_block0) if_block0.c();
				text = createText("\n\n          ");
				div0 = createElement("div");
				if (if_block1) if_block1.c();
				div0.className = "options svelte-1mcdlju";
				addLoc(div0, file$o, 25, 10, 947);
				div1.className = "section svelte-1mcdlju";
				addLoc(div1, file$o, 18, 8, 511);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				if (if_block0) if_block0.m(div1, null);
				append(div1, text);
				append(div1, div0);
				if (if_block1) if_block1.m(div0, null);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if (if_block0) if_block0.d(1);
					if_block0 = current_block_type && current_block_type(component, ctx);
					if (if_block0) if_block0.c();
					if (if_block0) if_block0.m(div1, text);
				}

				if (current_block_type_1 !== (current_block_type_1 = select_block_type_1(ctx))) {
					if (if_block1) if_block1.d(1);
					if_block1 = current_block_type_1 && current_block_type_1(component, ctx);
					if (if_block1) if_block1.c();
					if (if_block1) if_block1.m(div0, null);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (22:55) 
	function create_if_block_6$7(component, ctx) {
		var div, text0, text1_value = ctx.$playlistMetadata.playlistClipboard, text1, text2, text3_value = ctx.$playlistMetadata.playlistClipboard > 1 ? 's' : '', text3, text4;

		return {
			c: function create() {
				div = createElement("div");
				text0 = createText("Undo ");
				text1 = createText(text1_value);
				text2 = createText(" item");
				text3 = createText(text3_value);
				text4 = createText("?");
				div.className = "title selected_entries svelte-1mcdlju";
				addLoc(div, file$o, 22, 12, 777);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text0);
				append(div, text1);
				append(div, text2);
				append(div, text3);
				append(div, text4);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlistMetadata) && text1_value !== (text1_value = ctx.$playlistMetadata.playlistClipboard)) {
					setData(text1, text1_value);
				}

				if ((changed.$playlistMetadata) && text3_value !== (text3_value = ctx.$playlistMetadata.playlistClipboard > 1 ? 's' : '')) {
					setData(text3, text3_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (20:10) {#if $playlistMetadata.playlistHasSelectedEntries}
	function create_if_block_5$a(component, ctx) {
		var div, text0, text1_value = ctx.$playlistMetadata.playlistSelectedCount, text1, text2;

		return {
			c: function create() {
				div = createElement("div");
				text0 = createText("Selected entries (");
				text1 = createText(text1_value);
				text2 = createText(")");
				div.className = "title selected_entries svelte-1mcdlju";
				addLoc(div, file$o, 20, 12, 606);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text0);
				append(div, text1);
				append(div, text2);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlistMetadata) && text1_value !== (text1_value = ctx.$playlistMetadata.playlistSelectedCount)) {
					setData(text1, text1_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (32:57) 
	function create_if_block_4$b(component, ctx) {
		var div;

		function click_handler(event) {
			component.paste();
		}

		return {
			c: function create() {
				div = createElement("div");
				div.textContent = "Undo";
				addListener(div, "click", click_handler);
				div.className = "option svelte-1mcdlju";
				addLoc(div, file$o, 32, 14, 1418);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(div, "click", click_handler);
			}
		};
	}

	// (27:12) {#if $playlistMetadata.playlistHasSelectedEntries}
	function create_if_block_3$d(component, ctx) {
		var div0, text1, div1, text3, div2, text5, div3;

		function click_handler(event) {
			component.playNow();
		}

		function click_handler_1(event) {
			component.setNext();
		}

		function click_handler_2(event) {
			component.cut();
		}

		function click_handler_3(event) {
			component.deselectAll();
		}

		return {
			c: function create() {
				div0 = createElement("div");
				div0.textContent = "Play Now";
				text1 = createText("\n              ");
				div1 = createElement("div");
				div1.textContent = "◈ Set Next";
				text3 = createText("\n              ");
				div2 = createElement("div");
				div2.textContent = "✖ Remove";
				text5 = createText("\n              ");
				div3 = createElement("div");
				div3.textContent = "Cancel";
				addListener(div0, "click", click_handler);
				div0.className = "option play_now svelte-1mcdlju";
				addLoc(div0, file$o, 27, 14, 1046);
				addListener(div1, "click", click_handler_1);
				div1.className = "option set_next svelte-1mcdlju";
				addLoc(div1, file$o, 28, 14, 1125);
				addListener(div2, "click", click_handler_2);
				div2.className = "option remove svelte-1mcdlju";
				addLoc(div2, file$o, 29, 14, 1206);
				addListener(div3, "click", click_handler_3);
				div3.className = "option deselect svelte-1mcdlju";
				addLoc(div3, file$o, 30, 14, 1279);
			},

			m: function mount(target, anchor) {
				insert(target, div0, anchor);
				insert(target, text1, anchor);
				insert(target, div1, anchor);
				insert(target, text3, anchor);
				insert(target, div2, anchor);
				insert(target, text5, anchor);
				insert(target, div3, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div0);
				}

				removeListener(div0, "click", click_handler);
				if (detach) {
					detachNode(text1);
					detachNode(div1);
				}

				removeListener(div1, "click", click_handler_1);
				if (detach) {
					detachNode(text3);
					detachNode(div2);
				}

				removeListener(div2, "click", click_handler_2);
				if (detach) {
					detachNode(text5);
					detachNode(div3);
				}

				removeListener(div3, "click", click_handler_3);
			}
		};
	}

	function RibbonCurrentSelectionAndMissing(options) {
		this._debugName = '<RibbonCurrentSelectionAndMissing>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<RibbonCurrentSelectionAndMissing> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["player","playlistMetadata"]), options.data);
		this.store._add(this, ["player","playlistMetadata"]);
		if (!('$player' in this._state)) console.warn("<RibbonCurrentSelectionAndMissing> was created without expected data property '$player'");
		if (!('$playlistMetadata' in this._state)) console.warn("<RibbonCurrentSelectionAndMissing> was created without expected data property '$playlistMetadata'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$r(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$l.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(RibbonCurrentSelectionAndMissing.prototype, protoDev);
	assign(RibbonCurrentSelectionAndMissing.prototype, methods$f);

	RibbonCurrentSelectionAndMissing.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/*  ------------------------------------------------------------------------ */

	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

	const O = Object;

	/*  See https://misc.flogisoft.com/bash/tip_colors_and_formatting
	    ------------------------------------------------------------------------ */

	const colorCodes = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'lightGray', '', 'default'],
	      colorCodesLight = ['darkGray', 'lightRed', 'lightGreen', 'lightYellow', 'lightBlue', 'lightMagenta', 'lightCyan', 'white', ''],
	      styleCodes = ['', 'bright', 'dim', 'italic', 'underline', '', '', 'inverse'],
	      asBright = { 'red': 'lightRed',
	    'green': 'lightGreen',
	    'yellow': 'lightYellow',
	    'blue': 'lightBlue',
	    'magenta': 'lightMagenta',
	    'cyan': 'lightCyan',
	    'black': 'darkGray',
	    'lightGray': 'white' },
	      types = { 0: 'style',
	    2: 'unstyle',
	    3: 'color',
	    9: 'colorLight',
	    4: 'bgColor',
	    10: 'bgColorLight' },
	      subtypes = { color: colorCodes,
	    colorLight: colorCodesLight,
	    bgColor: colorCodes,
	    bgColorLight: colorCodesLight,
	    style: styleCodes,
	    unstyle: styleCodes

	    /*  ------------------------------------------------------------------------ */

	};const clean = obj => {
	    for (const k in obj) {
	        if (!obj[k]) {
	            delete obj[k];
	        }
	    }
	    return O.keys(obj).length === 0 ? undefined : obj;
	};

	/*  ------------------------------------------------------------------------ */

	class Color {

	    constructor(background, name, brightness) {

	        this.background = background;
	        this.name = name;
	        this.brightness = brightness;
	    }

	    get inverse() {
	        return new Color(!this.background, this.name || (this.background ? 'black' : 'white'), this.brightness);
	    }

	    get clean() {
	        return clean({ name: this.name === 'default' ? '' : this.name,
	            bright: this.brightness === Code.bright,
	            dim: this.brightness === Code.dim });
	    }

	    defaultBrightness(value) {

	        return new Color(this.background, this.name, this.brightness || value);
	    }

	    css(inverted) {

	        const color = inverted ? this.inverse : this;

	        const rgbName = color.brightness === Code.bright && asBright[color.name] || color.name;

	        const prop = color.background ? 'background:' : 'color:',
	              rgb = Colors.rgb[rgbName],
	              alpha = this.brightness === Code.dim ? 0.5 : 1;

	        return rgb ? prop + 'rgba(' + [].concat(_toConsumableArray(rgb), [alpha]).join(',') + ');' : !color.background && alpha < 1 ? 'color:rgba(0,0,0,0.5);' : ''; // Chrome does not support 'opacity' property...
	    }
	}

	/*  ------------------------------------------------------------------------ */

	class Code {

	    constructor(n) {
	        if (n !== undefined) {
	            this.value = Number(n);
	        }
	    }

	    get type() {
	        return types[Math.floor(this.value / 10)];
	    }

	    get subtype() {
	        return subtypes[this.type][this.value % 10];
	    }

	    get str() {
	        return this.value ? '\u001b\[' + this.value + 'm' : '';
	    }

	    static str(x) {
	        return new Code(x).str;
	    }

	    get isBrightness() {
	        return this.value === Code.noBrightness || this.value === Code.bright || this.value === Code.dim;
	    }
	}

	/*  ------------------------------------------------------------------------ */

	O.assign(Code, {

	    reset: 0,
	    bright: 1,
	    dim: 2,
	    inverse: 7,
	    noBrightness: 22,
	    noItalic: 23,
	    noUnderline: 24,
	    noInverse: 27,
	    noColor: 39,
	    noBgColor: 49
	});

	/*  ------------------------------------------------------------------------ */

	const replaceAll = (str, a, b) => str.split(a).join(b);

	/*  ANSI brightness codes do not overlap, e.g. "{bright}{dim}foo" will be rendered bright (not dim).
	    So we fix it by adding brightness canceling before each brightness code, so the former example gets
	    converted to "{noBrightness}{bright}{noBrightness}{dim}foo" – this way it gets rendered as expected.
	 */

	const denormalizeBrightness = s => s.replace(/(\u001b\[(1|2)m)/g, '\u001b[22m$1');
	const normalizeBrightness = s => s.replace(/\u001b\[22m(\u001b\[(1|2)m)/g, '$1');

	const wrap$1 = (x, openCode, closeCode) => {

	    const open = Code.str(openCode),
	          close = Code.str(closeCode);

	    return String(x).split('\n').map(line => denormalizeBrightness(open + replaceAll(normalizeBrightness(line), close, open) + close)).join('\n');
	};

	/*  ------------------------------------------------------------------------ */

	const camel = (a, b) => a + b.charAt(0).toUpperCase() + b.slice(1);

	const stringWrappingMethods = (() => [].concat(_toConsumableArray(colorCodes.map((k, i) => !k ? [] : [// color methods

	[k, 30 + i, Code.noColor], [camel('bg', k), 40 + i, Code.noBgColor]])), _toConsumableArray(colorCodesLight.map((k, i) => !k ? [] : [// light color methods

	[k, 90 + i, Code.noColor], [camel('bg', k), 100 + i, Code.noBgColor]])), _toConsumableArray(['', 'BrightRed', 'BrightGreen', 'BrightYellow', 'BrightBlue', 'BrightMagenta', 'BrightCyan'].map((k, i) => !k ? [] : [['bg' + k, 100 + i, Code.noBgColor]])), _toConsumableArray(styleCodes.map((k, i) => !k ? [] : [// style methods

	[k, i, k === 'bright' || k === 'dim' ? Code.noBrightness : 20 + i]]))).reduce((a, b) => a.concat(b)))();

	/*  ------------------------------------------------------------------------ */

	const assignStringWrappingAPI = function (target) {
	    let wrapBefore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target;
	    return stringWrappingMethods.reduce((memo, _ref) => {
	        var _ref2 = _slicedToArray(_ref, 3);

	        let k = _ref2[0],
	            open = _ref2[1],
	            close = _ref2[2];
	        return O.defineProperty(memo, k, {
	            get: () => assignStringWrappingAPI(str => wrapBefore(wrap$1(str, open, close)))
	        });
	    }, target);
	};

	/*  ------------------------------------------------------------------------ */

	const TEXT = 0,
	      BRACKET = 1,
	      CODE = 2;

	function rawParse(s) {

	    let state = TEXT,
	        buffer = '',
	        text = '',
	        code = '',
	        codes = [];
	    let spans = [];

	    for (let i = 0, n = s.length; i < n; i++) {

	        const c = s[i];

	        buffer += c;

	        switch (state) {

	            case TEXT:
	                if (c === '\u001b') {
	                    state = BRACKET;buffer = c;
	                } else {
	                    text += c;
	                }
	                break;

	            case BRACKET:
	                if (c === '[') {
	                    state = CODE;code = '';codes = [];
	                } else {
	                    state = TEXT;text += buffer;
	                }
	                break;

	            case CODE:

	                if (c >= '0' && c <= '9') {
	                    code += c;
	                } else if (c === ';') {
	                    codes.push(new Code(code));code = '';
	                } else if (c === 'm' && code.length) {
	                    codes.push(new Code(code));
	                    for (const code of codes) {
	                        spans.push({ text, code });text = '';
	                    }
	                    state = TEXT;
	                } else {
	                    state = TEXT;text += buffer;
	                }
	        }
	    }

	    if (state !== TEXT) text += buffer;

	    if (text) spans.push({ text, code: new Code() });

	    return spans;
	}

	/*  ------------------------------------------------------------------------ */

	/**
	 * Represents an ANSI-escaped string.
	 */
	class Colors {

	    /**
	     * @param {string} s a string containing ANSI escape codes.
	     */
	    constructor(s) {

	        this.spans = s ? rawParse(s) : [];
	    }

	    get str() {
	        return this.spans.reduce((str, p) => str + p.text + p.code.str, '');
	    }

	    get parsed() {

	        let color, bgColor, brightness, styles;

	        function reset() {

	            color = new Color(), bgColor = new Color(true /* background */), brightness = undefined, styles = new Set();
	        }

	        reset();

	        return O.assign(new Colors(), {

	            spans: this.spans.map(span => {

	                const c = span.code;

	                const inverted = styles.has('inverse'),
	                      underline = styles.has('underline') ? 'text-decoration: underline;' : '',
	                      italic = styles.has('italic') ? 'font-style: italic;' : '',
	                      bold = brightness === Code.bright ? 'font-weight: bold;' : '';

	                const foreColor = color.defaultBrightness(brightness);

	                const styledSpan = O.assign({ css: bold + italic + underline + foreColor.css(inverted) + bgColor.css(inverted) }, clean({ bold: !!bold, color: foreColor.clean, bgColor: bgColor.clean }), span);

	                for (const k of styles) {
	                    styledSpan[k] = true;
	                }

	                if (c.isBrightness) {

	                    brightness = c.value;
	                } else if (span.code.value !== undefined) {

	                    if (span.code.value === Code.reset) {
	                        reset();
	                    } else {

	                        switch (span.code.type) {

	                            case 'color':
	                            case 'colorLight':
	                                color = new Color(false, c.subtype);break;

	                            case 'bgColor':
	                            case 'bgColorLight':
	                                bgColor = new Color(true, c.subtype);break;

	                            case 'style':
	                                styles.add(c.subtype);break;
	                            case 'unstyle':
	                                styles.delete(c.subtype);break;
	                        }
	                    }
	                }

	                return styledSpan;
	            }).filter(s => s.text.length > 0)
	        });
	    }

	    /*  Outputs with Chrome DevTools-compatible format     */

	    get asChromeConsoleLogArguments() {

	        const spans = this.parsed.spans;

	        return [spans.map(s => '%c' + s.text).join('')].concat(_toConsumableArray(spans.map(s => s.css)));
	    }

	    get browserConsoleArguments() /* LEGACY, DEPRECATED */{
	        return this.asChromeConsoleLogArguments;
	    }

	    /**
	     * @desc installs String prototype extensions
	     * @example
	     * require ('ansicolor').nice
	     * console.log ('foo'.bright.red)
	     */
	    static get nice() {

	        Colors.names.forEach(k => {
	            if (!(k in String.prototype)) {
	                O.defineProperty(String.prototype, k, { get: function () {
	                        return Colors[k](this);
	                    } });
	            }
	        });

	        return Colors;
	    }

	    /**
	     * @desc parses a string containing ANSI escape codes
	     * @return {Colors} parsed representation.
	     */
	    static parse(s) {
	        return new Colors(s).parsed;
	    }

	    /**
	     * @desc strips ANSI codes from a string
	     * @param {string} s a string containing ANSI escape codes.
	     * @return {string} clean string.
	     */
	    static strip(s) {
	        return s.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g, ''); // hope V8 caches the regexp
	    }

	    /**
	     * @example
	     * const spans = [...ansi.parse ('\u001b[7m\u001b[7mfoo\u001b[7mbar\u001b[27m')]
	     */
	    [Symbol.iterator]() {
	        return this.spans[Symbol.iterator]();
	    }
	}

	/*  ------------------------------------------------------------------------ */

	assignStringWrappingAPI(Colors, str => str);

	/*  ------------------------------------------------------------------------ */

	Colors.names = stringWrappingMethods.map((_ref3) => {
	    var _ref4 = _slicedToArray(_ref3, 1);

	    let k = _ref4[0];
	    return k;
	});

	/*  ------------------------------------------------------------------------ */

	Colors.rgb = {

	    black: [0, 0, 0],
	    darkGray: [100, 100, 100],
	    lightGray: [200, 200, 200],
	    white: [255, 255, 255],

	    red: [204, 0, 0],
	    lightRed: [255, 51, 0],

	    green: [0, 204, 0],
	    lightGreen: [51, 204, 51],

	    yellow: [204, 102, 0],
	    lightYellow: [255, 153, 51],

	    blue: [0, 0, 255],
	    lightBlue: [26, 140, 255],

	    magenta: [204, 0, 204],
	    lightMagenta: [255, 0, 255],

	    cyan: [0, 153, 255],
	    lightCyan: [0, 204, 255]

	    /*  ------------------------------------------------------------------------ */

	};var ansicolor = Colors;

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/Player.html generated by Svelte v2.16.1 */



	const colors = colorsDmt;

	function hasSearchResults(searchResults) {
	  if(searchResults) {
	    for(const providerResults of searchResults) {
	      if(providerResults.results && providerResults.results.length > 0) {
	        return true
	      }
	    }
	  }
	  return false;
	}
	function parseAnsi(text) {
	  return ansicolor.parse(text);
	}
	function formatProviderMeta(providerResponse) {
	  const { meta } = providerResponse;
	  const cnt = meta.contentId ? `${colors.gray('/')}${colors.cyan(meta.contentId)}` : '';
	  const provider = `${colors.green('Content')} → ${colors.magenta(`@${meta.providerHost}`)}${cnt} ${
    providerResponse.providerAddress ? colors.gray(`(${meta.providerAddress})`) : ''
  }`;
	  return provider;
	}
	function formatProviderMetaBottom(providerResponse) {
	  const { meta } = providerResponse;
	  const { page, noMorePages, resultCount, resultsFrom, resultsTo, searchTimePretty, networkTimePretty } = meta;

	  let time = '';

	  if (searchTimePretty) {
	    time += colors.gray(` · ${colors.gray('fs')} ${colors.green(searchTimePretty)}`);
	  }

	  if (networkTimePretty) {
	    time += colors.gray(` · ${colors.gray('network')} ${colors.cyan(networkTimePretty)}`);
	  }

	  if (resultCount > 0) {
	    if (page == 1 && noMorePages) {
	      return colors.yellow(`${resultCount} ${resultCount == 1 ? 'result' : 'results'}${time}`);
	    }

	    const isLastPage = noMorePages ? colors.gray(' (last page)') : '';
	    const resultsDescription = `${colors.cyan(`Results ${resultsFrom} to ${resultsTo}`)}`;
	    return colors.gray(`${colors.magenta(`Page ${page}`)}${isLastPage} → ${resultsDescription}${time}`);
	  }

	  return colors.gray(`No ${page > 1 ? 'more ' : ''}results${time}`);
	}
	var methods$g = {
	  selectedDeviceChanged(deviceName) {
	    const { queries } = this.get();
	    if(queries[deviceName]) {
	      const { searchQuery, mediaType } = queries[deviceName];
	      this.set({ searchQuery, mediaType });
	    } else {
	      this.set({ searchQuery: '', mediaType: null });
	    }
	  },
	  searchInputChanged() {
	    const { searchQuery, selectedDeviceName, queries, mediaType } = this.get();

	    if(searchQuery == '') {
	      this.clearResults(); // check!! do we have to do the rest??
	    }

	    queries[selectedDeviceName] = queries[selectedDeviceName] || {};

	    queries[selectedDeviceName].searchQuery = searchQuery;
	    queries[selectedDeviceName].mediaType = mediaType;
	    this.set({ queries });

	    //this.executeQueryTimeout = setTimeout(() => {
	    //const { selectedDeviceName } = this.get();
	    const { prevQuery, prevMediaType } = queries[selectedDeviceName];

	    if(searchQuery.trim()) {
	      // console.log(searchQuery);
	      // we do these comparisons here althout basic comparisons if search query is different enough are also done in
	      // executeSearch ... here we have a specific situation because we query multiple devices as we switch between them, we need separate context for each
	      if(this.queryDifferentEnough({ searchQuery, prevQuery, mediaType, prevMediaType })) {
	        // console.log(`Sent ${searchQuery} with mediaType=${mediaType} to rpc/player/search`);

	        // console.log("BBB");
	        // console.log(this.getSearchQuery());

	        // warning: this is remote object attached in gui middleware, not player actor yet !
	        const remoteObject = this.store.remoteObject('player');
	        const remoteMethod = 'search';

	        const searchDelay = 120;

	        executeSearch({ searchQuery: this.getSearchQuery(), remoteObject, remoteMethod, searchDelay }).then(searchResults => {
	          console.log("GOT SEARCH RESULTS");
	          this.store.currentStore().set({ searchResults });
	        }).catch(console.log);

	      }

	      queries[selectedDeviceName].prevQuery = searchQuery;
	      queries[selectedDeviceName].prevMediaType = mediaType;
	      this.set({ queries });
	    }
	    //}, 120); // 200 !!!
	  },
	  queryDifferentEnough({ searchQuery, prevQuery, mediaType, prevMediaType }) {
	    return this.normalizeQuery(searchQuery) != this.normalizeQuery(prevQuery) || mediaType != prevMediaType;
	  },
	  normalizeQuery(query) {
	    return query ? query.trim().replace(/\s+/g, ' ') : query;
	  },
	  addResults() {
	    const query = this.getSearchQuery();
	    if(query) {
	      // warning: this is remote object attached in gui middleware, not player actor yet !
	      this.store.remoteObject('player').call('add', { query }).then(searchResults => {
	        this.store.currentStore().set({ searchResults });
	      }).catch(console.log);
	    }
	    this.clearResults();
	  },
	  insertResults() {
	    const query = this.getSearchQuery();
	    // warning: this is remote object attached in gui middleware, not player actor yet !
	    this.store.remoteObject('player').call('insert', { query }).then(searchResults => {
	      this.store.currentStore().set({ searchResults });
	    }).catch(console.log);
	    this.clearResults();
	  },
	  playResults() {
	    const query = this.getSearchQuery();
	    if(query) {
	      // warning: this is remote object attached in gui middleware, not player actor yet !
	      this.store.remoteObject('player').call('play', { query }).catch(console.log);
	    }
	    this.clearResults();
	  },
	  clearResults() {
	    //console.log("CLEARING RESULTS");
	    const { queries, selectedDeviceName } = this.get();
	    queries[selectedDeviceName] = { searchQuery: '', prevQuery: '' };
	    this.set({ queries, searchQuery: '' });
	    this.store.currentStore().set({ searchResults: null });
	  },
	  getSearchQuery() {
	    let { searchQuery, mediaType } = this.get();
	    searchQuery = searchQuery.trim();
	    if(mediaType == 'video') {
	      searchQuery = `${searchQuery} @media=video`;
	    }
	    return searchQuery;
	  },
	  chooseMediaType(mediaType) {
	    this.set({ mediaType });
	    const { queries, selectedDeviceName } = this.get();
	    queries[selectedDeviceName] = { mediaType };
	    this.set({ queries });
	    this.searchInputChanged();
	  },
	  handleKeypress(event) {
	    if(util.isInputElementActive()) {
	      return
	    }

	    // DUPLICATE!! --> some events from here are also handled in PlayInfo (which is not included in Player though, only in home and Clock for now )...
	    if(event.key && !event.altKey && !event.metaKey && !event.shiftKey) {
	      const $player = this.store.get().player;

	      // GUI BUG!! todo.. happened only once , rare occurence :) on eclipse when pressing space.. no idea why $player does not exist... there is some good reason probably
	      // Uncaught TypeError: Cannot read property 'paused' of null
	      // at No.handleKeypress (Player.html:470)
	      //
	      // maybe in the start when player is not yet in the store (!?)
	      // doesn't matter .. will get fixed in Svelte3
	      if(!$player) {
	        return;
	      }

	      if(event.key == ' ') {
	        event.preventDefault();
	        if($player.paused) {
	          this.play();
	        } else {
	          this.pause();
	        }
	      }

	      if(event.key == 'n') {
	        this.next();
	      }

	      if(event.key == 's') {
	        this.shuffle();
	      }

	      if(event.key == 'l') {
	        this.limitIncrease();
	      }

	      if(event.key == 'm') {
	        this.timeLimitIncrease();
	      }

	      if(event.key == 'r') {
	        this.limitReset();
	      }

	      const step = 10;

	      if(event.code == 'ArrowRight') {
	        this.forward(step);
	      }

	      if(event.code == 'ArrowLeft') {
	        this.forward(-step);
	      }

	      if(event.keyCode == 38 || event.key == '+' || event.key == '=') {
	        this.volumeUp();
	      }

	      if(event.keyCode == 40 || event.key == '-') {
	        this.volumeDown();
	      }
	    }
	  },
	  action(action, payload) {
	    this.set({ touchAction: action });
	    setTimeout(() => this.set({ touchAction: undefined }), 50); // give it some (exact) time to be visible! it's too short otherwise (even if we put it after the action trigger (because this is very fast))

	    this.store.signal('action', { action, scope: this.scope, payload });
	  },
	  selectMediaSource(mediaSourceOption) {
	    // todo: handle "browser" and "search"
	    // delegate to proper subcomponent!
	    console.log(`Selecting media via: ${mediaSourceOption}. todo: browse and search`);

	    alert('Interface for this is coming by v1.0.1 ... use "dmt next" to update the system then or use commandline for now - command "m"');
	    //this.set({ selectMedia: media })
	    //this.fire('selectMedia', { media })
	  },
	  play() {
	    this.action('play');
	  },
	  pause() {
	    this.action('pause');
	  },
	  next() {
	    this.action('next');
	  },
	  shuffle() {
	    this.action('shuffle');
	  },
	  repeatIncrease() {
	    this.action('repeat');
	  },
	  forward(seconds) {
	    this.action('forward', { seconds });
	  },
	  volumeUp() {
	    this.action('volume_up');
	  },
	  volumeDown() {
	    this.action('volume_down');
	  },
	  stop() {
	    this.action('stop');
	  },
	  limitIncrease() { // used shen LIMIT button is clicked or "l" key pressed
	    if(this.get().isStream || this.get().timeLimit) {
	      this.action('time_limit');
	    } else {
	      this.action('limit');
	    }
	  },
	  timeLimitIncrease() { // used with "ADD MORE TIME" or "SET TIME LIMIT"
	    this.action('time_limit');
	  },
	  limitReset() {
	    this.action('remove_limit');
	  },
	  timeLimitReset() {
	    this.action('remove_time_limit');
	  },
	  selectMedia(songId) {
	    this.action('select', { songId });
	  },
	  seek(percentPos) {
	    this.action('goto', { percentPos });
	  },
	  calculateTimeLimit(player) {
	    return player.timeLimit > 2 ? `${Math.round(player.timeLimit)} min` : `${Math.round(player.timeLimit*60)} s`;
	  }
	};

	function oncreate$m() {
	  this.scope = 'player'; // scope for sending actions from frontend GUI to backend
	  // adds thisDeviceName and selectedDeviceName to the component store
	  this.store.entangle(this);

	  this.set({ queries: {}, searchQuery: '' });

	  this.listener = this.store.on('state', ({ current, changed, previous }) => {
	    const { prevDeviceName, selectedDeviceName } = this.get();
	    if(prevDeviceName != selectedDeviceName) {
	      this.selectedDeviceChanged(selectedDeviceName);
	    }
	    this.set({ prevDeviceName: selectedDeviceName });

	    if(current.thisDeviceState) { // todo: think if we really need to observe all state changes... AND if we get all differences inside thisDeviceState when we observe multiconnected store "state" event
	      const { player } = current;

	      if(player)  {
	        if(player.timeLimit) {
	          this.set({ timeLimit: this.calculateTimeLimit(player) });
	        } else {
	          this.set({ timeLimit: undefined });
	        }

	        this.set({ isStream: player.isStream });
	      }
	    }
	  });
	}
	function ondestroy$2() {
	  this.listener.cancel();
	}
	const file$p = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/player/src/Player.html";

	function click_handler$2(event) {
		const { component, ctx } = this._svelte;

		component.selectMedia(ctx.song.id);
	}

	function get_each_context_3(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.song = list[i];
		return child_ctx;
	}

	function get_each_context_2(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.span = list[i];
		return child_ctx;
	}

	function get_each_context_1$1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.filePathANSI = list[i].filePathANSI;
		return child_ctx;
	}

	function get_each_context$5(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.providerResponse = list[i];
		return child_ctx;
	}

	function create_main_fragment$s(component, ctx) {
		var if_block_anchor, current;

		function onwindowkeydown(event) {
			component.handleKeypress(event);	}
		window.addEventListener("keydown", onwindowkeydown);

		var if_block = (ctx.loaded && ctx.$connected && ctx.$device) && create_if_block$q(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded && ctx.$connected && ctx.$device) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$q(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				window.removeEventListener("keydown", onwindowkeydown);

				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (3:0) {#if loaded && $connected && $device}
	function create_if_block$q(component, ctx) {
		var text, current_block_type_index, if_block1, if_block1_anchor, current;

		var if_block0 = (!ctx.atRPi) && create_if_block_28(component, ctx);

		var if_block_creators = [
			create_if_block_1$l,
			create_if_block_2$g
		];

		var if_blocks = [];

		function select_block_type_1(ctx) {
			if (ctx.$device.serverMode) return 0;
			if (ctx.$player) return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type_1(ctx))) {
			if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
		}

		return {
			c: function create() {
				if (if_block0) if_block0.c();
				text = createText("\n\n  ");
				if (if_block1) if_block1.c();
				if_block1_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, text, anchor);
				if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block1_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (!ctx.atRPi) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_28(component, ctx);
						if_block0.c();
						if_block0.m(text.parentNode, text);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);
				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if (if_block1) {
						if_block1.o(function() {
							if_blocks[previous_block_index].d(1);
							if_blocks[previous_block_index] = null;
						});
					}

					if (~current_block_type_index) {
						if_block1 = if_blocks[current_block_type_index];
						if (!if_block1) {
							if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
							if_block1.c();
						}
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					} else {
						if_block1 = null;
					}
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block1) if_block1.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block0) if_block0.d(detach);
				if (detach) {
					detachNode(text);
				}

				if (~current_block_type_index) if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(if_block1_anchor);
				}
			}
		};
	}

	// (5:2) {#if !atRPi}
	function create_if_block_28(component, ctx) {
		var div, input, input_updating = false, text0, button0, text2, button1, text4, button2, text6, button3, text8, button4, text10, text11;

		function input_input_handler() {
			input_updating = true;
			component.set({ searchQuery: input.value });
			input_updating = false;
		}

		function keyup_handler(event) {
			component.searchInputChanged();
		}

		function paste_handler(event) {
			component.searchInputChanged();
		}

		function click_handler(event) {
			component.chooseMediaType('music');
		}

		function click_handler_1(event) {
			component.chooseMediaType('video');
		}

		function click_handler_2(event) {
			component.playResults();
		}

		function click_handler_3(event) {
			component.addResults();
		}

		function click_handler_4(event) {
			component.insertResults();
		}

		var if_block0 = (ctx.searchQuery && ctx.searchQuery.trim()) && create_if_block_31(component);

		var if_block1 = (ctx.$searchResults && ctx.searchQuery && ctx.searchQuery.trim()) && create_if_block_29(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				input = createElement("input");
				text0 = createText("\n\n      ");
				button0 = createElement("button");
				button0.textContent = "Music";
				text2 = createText("\n      ");
				button1 = createElement("button");
				button1.textContent = "Video";
				text4 = createText("\n\n      ");
				button2 = createElement("button");
				button2.textContent = "▶ Play";
				text6 = createText("\n      ");
				button3 = createElement("button");
				button3.textContent = "Add";
				text8 = createText("\n      ");
				button4 = createElement("button");
				button4.textContent = "Insert";
				text10 = createText("\n\n      ");
				if (if_block0) if_block0.c();
				text11 = createText("\n\n      ");
				if (if_block1) if_block1.c();
				addListener(input, "input", input_input_handler);
				addListener(input, "keyup", keyup_handler);
				addListener(input, "paste", paste_handler);
				input.className = "search_input svelte-96fn1x";
				input.placeholder = "Search media";
				addLoc(input, file$p, 6, 6, 138);
				addListener(button0, "click", click_handler);
				button0.className = "media_type svelte-96fn1x";
				toggleClass(button0, "selected", ctx.mediaType != 'video');
				addLoc(button0, file$p, 8, 6, 288);
				addListener(button1, "click", click_handler_1);
				button1.className = "media_type svelte-96fn1x";
				toggleClass(button1, "selected", ctx.mediaType == 'video');
				addLoc(button1, file$p, 9, 6, 410);
				addListener(button2, "click", click_handler_2);
				button2.className = "action svelte-96fn1x";
				toggleClass(button2, "hidden", !hasSearchResults(ctx.$searchResults));
				addLoc(button2, file$p, 11, 6, 533);
				addListener(button3, "click", click_handler_3);
				button3.className = "action svelte-96fn1x";
				toggleClass(button3, "hidden", !hasSearchResults(ctx.$searchResults));
				addLoc(button3, file$p, 12, 6, 652);
				addListener(button4, "click", click_handler_4);
				button4.className = "action svelte-96fn1x";
				toggleClass(button4, "hidden", !hasSearchResults(ctx.$searchResults));
				addLoc(button4, file$p, 13, 6, 767);
				div.className = "search svelte-96fn1x";
				addLoc(div, file$p, 5, 4, 111);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, input);

				input.value = ctx.searchQuery;

				append(div, text0);
				append(div, button0);
				append(div, text2);
				append(div, button1);
				append(div, text4);
				append(div, button2);
				append(div, text6);
				append(div, button3);
				append(div, text8);
				append(div, button4);
				append(div, text10);
				if (if_block0) if_block0.m(div, null);
				append(div, text11);
				if (if_block1) if_block1.m(div, null);
			},

			p: function update(changed, ctx) {
				if (!input_updating && changed.searchQuery) input.value = ctx.searchQuery;
				if (changed.mediaType) {
					toggleClass(button0, "selected", ctx.mediaType != 'video');
					toggleClass(button1, "selected", ctx.mediaType == 'video');
				}

				if (changed.$searchResults) {
					toggleClass(button2, "hidden", !hasSearchResults(ctx.$searchResults));
					toggleClass(button3, "hidden", !hasSearchResults(ctx.$searchResults));
					toggleClass(button4, "hidden", !hasSearchResults(ctx.$searchResults));
				}

				if (ctx.searchQuery && ctx.searchQuery.trim()) {
					if (!if_block0) {
						if_block0 = create_if_block_31(component);
						if_block0.c();
						if_block0.m(div, text11);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.$searchResults && ctx.searchQuery && ctx.searchQuery.trim()) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_29(component, ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(input, "input", input_input_handler);
				removeListener(input, "keyup", keyup_handler);
				removeListener(input, "paste", paste_handler);
				removeListener(button0, "click", click_handler);
				removeListener(button1, "click", click_handler_1);
				removeListener(button2, "click", click_handler_2);
				removeListener(button3, "click", click_handler_3);
				removeListener(button4, "click", click_handler_4);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (16:6) {#if searchQuery && searchQuery.trim()}
	function create_if_block_31(component, ctx) {
		var button;

		function click_handler(event) {
			component.clearResults();
		}

		return {
			c: function create() {
				button = createElement("button");
				button.textContent = "Clear";
				addListener(button, "click", click_handler);
				button.className = "clear svelte-96fn1x";
				addLoc(button, file$p, 16, 8, 937);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (20:6) {#if $searchResults && searchQuery && searchQuery.trim()}
	function create_if_block_29(component, ctx) {
		var div;

		var each_value = ctx.$searchResults;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block_1$1(component, get_each_context$5(ctx, each_value, i));
		}

		return {
			c: function create() {
				div = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				div.className = "search_results svelte-96fn1x";
				addLoc(div, file$p, 20, 8, 1085);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.$searchResults) {
					each_value = ctx.$searchResults;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$5(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1$1(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (31:12) {:else}
	function create_else_block_6(component, ctx) {
		var text, div, raw_value = formatProviderMetaBottom(ctx.providerResponse);

		var each_value_1 = ctx.providerResponse.results;

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_2(component, get_each_context_1$1(ctx, each_value_1, i));
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				text = createText("\n\n              ");
				div = createElement("div");
				div.className = "results_info_bottom svelte-96fn1x";
				addLoc(div, file$p, 36, 14, 1768);
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insert(target, text, anchor);
				insert(target, div, anchor);
				div.innerHTML = raw_value;
			},

			p: function update(changed, ctx) {
				if (changed.$searchResults) {
					each_value_1 = ctx.providerResponse.results;

					for (var i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_2(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(text.parentNode, text);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_1.length;
				}

				if ((changed.$searchResults) && raw_value !== (raw_value = formatProviderMetaBottom(ctx.providerResponse))) {
					div.innerHTML = raw_value;
				}
			},

			d: function destroy(detach) {
				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(text);
					detachNode(div);
				}
			}
		};
	}

	// (27:12) {#if providerResponse.error}
	function create_if_block_30(component, ctx) {
		var div, text0, text1_value = ctx.providerResponse.error, text1;

		return {
			c: function create() {
				div = createElement("div");
				text0 = createText("⚠️  Error: ");
				text1 = createText(text1_value);
				div.className = "provider_error svelte-96fn1x";
				addLoc(div, file$p, 27, 14, 1342);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text0);
				append(div, text1);
			},

			p: function update(changed, ctx) {
				if ((changed.$searchResults) && text1_value !== (text1_value = ctx.providerResponse.error)) {
					setData(text1, text1_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (34:36) {#each parseAnsi(filePathANSI).spans as span}
	function create_each_block_3(component, ctx) {
		var span, text_value = ctx.span.text, text, span_style_value;

		return {
			c: function create() {
				span = createElement("span");
				text = createText(text_value);
				span.style.cssText = span_style_value = ctx.span.css;
				span.className = "svelte-96fn1x";
				addLoc(span, file$p, 33, 81, 1674);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				append(span, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$searchResults) && text_value !== (text_value = ctx.span.text)) {
					setData(text, text_value);
				}

				if ((changed.$searchResults) && span_style_value !== (span_style_value = ctx.span.css)) {
					span.style.cssText = span_style_value;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (32:14) {#each providerResponse.results as { filePathANSI }}
	function create_each_block_2(component, ctx) {
		var div;

		var each_value_2 = parseAnsi(ctx.filePathANSI).spans;

		var each_blocks = [];

		for (var i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_3(component, get_each_context_2(ctx, each_value_2, i));
		}

		return {
			c: function create() {
				div = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				div.className = "result svelte-96fn1x";
				addLoc(div, file$p, 33, 16, 1609);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.$searchResults) {
					each_value_2 = parseAnsi(ctx.filePathANSI).spans;

					for (var i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_3(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_2.length;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (22:10) {#each $searchResults as providerResponse}
	function create_each_block_1$1(component, ctx) {
		var div, raw_value = formatProviderMeta(ctx.providerResponse), text, if_block_anchor;

		function select_block_type(ctx) {
			if (ctx.providerResponse.error) return create_if_block_30;
			return create_else_block_6;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				text = createText("\n\n            ");
				if_block.c();
				if_block_anchor = createComment();
				div.className = "provider_title svelte-96fn1x";
				addLoc(div, file$p, 22, 12, 1179);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				div.innerHTML = raw_value;
				insert(target, text, anchor);
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$searchResults) && raw_value !== (raw_value = formatProviderMeta(ctx.providerResponse))) {
					div.innerHTML = raw_value;
				}

				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
					detachNode(text);
				}

				if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (51:19) 
	function create_if_block_2$g(component, ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block_3$e,
			create_else_block_4
		];

		var if_blocks = [];

		function select_block_type_2(ctx) {
			if (!ctx.$player.error) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block.c();
					}
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (47:2) {#if $device.serverMode}
	function create_if_block_1$l(component, ctx) {
		var div, h1, current;

		return {
			c: function create() {
				div = createElement("div");
				h1 = createElement("h1");
				h1.textContent = "There is no player available in serverMode";
				h1.className = "svelte-96fn1x";
				addLoc(h1, file$p, 48, 6, 2031);
				div.className = "player svelte-96fn1x";
				addLoc(div, file$p, 47, 4, 2004);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h1);
				current = true;
			},

			p: noop,

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (216:4) {:else}
	function create_else_block_4(component, ctx) {
		var div, h1, text0, text1_value = ctx.$player.error.type, text1, text2, h2, raw_value = ctx.$player.error.msg.replace('\n', '<br>'), text3, current;

		var if_block = (ctx.$player.error.type == 'mpv_binary_missing') && create_if_block_26(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				h1 = createElement("h1");
				text0 = createText("⚠️ ");
				text1 = createText(text1_value);
				text2 = createText("\n\n        ");
				h2 = createElement("h2");
				text3 = createText("\n\n        ");
				if (if_block) if_block.c();
				h1.className = "error svelte-96fn1x";
				addLoc(h1, file$p, 217, 8, 10213);
				h2.className = "error svelte-96fn1x";
				addLoc(h2, file$p, 219, 8, 10269);
				div.className = "player svelte-96fn1x";
				addLoc(div, file$p, 216, 6, 10184);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h1);
				append(h1, text0);
				append(h1, text1);
				append(div, text2);
				append(div, h2);
				h2.innerHTML = raw_value;
				append(div, text3);
				if (if_block) if_block.m(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text1_value !== (text1_value = ctx.$player.error.type)) {
					setData(text1, text1_value);
				}

				if ((changed.$player) && raw_value !== (raw_value = ctx.$player.error.msg.replace('\n', '<br>'))) {
					h2.innerHTML = raw_value;
				}

				if (ctx.$player.error.type == 'mpv_binary_missing') {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_26(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (53:4) {#if !$player.error}
	function create_if_block_3$e(component, ctx) {
		var div2, div0, text0, text1, text2, button0, text3, button0_disabled_value, text4, button1, text5, button1_disabled_value, text6, text7, text8, text9, text10, text11, text12, div1, current_block_type_index, if_block9, text13, current;

		var if_block0 = (ctx.$player.isStream || (ctx.$playlist && ctx.$playlist.length > 0)) && create_if_block_23(component, ctx);

		var if_block1 = (!ctx.$player.isStream && ctx.$playlist && ctx.$playlist.length > 0) && create_if_block_21(component, ctx);

		var if_block2 = (ctx.$player.isStream) && create_if_block_20(component, ctx);

		function click_handler(event) {
			component.volumeDown();
		}

		function click_handler_1(event) {
			component.volumeUp();
		}

		function select_block_type_5(ctx) {
			if (ctx.homebase) return create_if_block_19;
			return create_else_block_1$2;
		}

		var current_block_type = select_block_type_5(ctx);
		var if_block3 = current_block_type(component, ctx);

		function select_block_type_6(ctx) {
			if (!ctx.$player.isStream && ctx.$player.limit) return create_if_block_17;
			if (ctx.$player.timeLimit) return create_if_block_18;
		}

		var current_block_type_1 = select_block_type_6(ctx);
		var if_block4 = current_block_type_1 && current_block_type_1(component, ctx);

		var if_block5 = (ctx.$player.limitReached) && create_if_block_16$1();

		var if_block6 = (ctx.$player.timeLimitReached) && create_if_block_15$1();

		var if_block7 = (!ctx.$player.isStream) && create_if_block_13$1(component, ctx);

		var if_block8 = (ctx.$player.currentMedia && ctx.$player.currentMedia.song) && create_if_block_10$4(component, ctx);

		var if_block_creators = [
			create_if_block_9$5,
			create_else_block$5
		];

		var if_blocks = [];

		function select_block_type_7(ctx) {
			if ((ctx.$player.hasMissingMedia && !ctx.$player.isStream) || ctx.$playlistMetadata.playlistHasSelectedEntries || ctx.$playlistMetadata.playlistClipboard) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_7(ctx);
		if_block9 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		var if_block10 = (!ctx.$player.isStream && ctx.$playlist) && create_if_block_4$c(component, ctx);

		return {
			c: function create() {
				div2 = createElement("div");
				div0 = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText("\n\n          ");
				if (if_block1) if_block1.c();
				text1 = createText("\n\n          ");
				if (if_block2) if_block2.c();
				text2 = createText("\n\n          ");
				button0 = createElement("button");
				text3 = createText("Vol ⬇");
				text4 = createText("\n          ");
				button1 = createElement("button");
				text5 = createText("Vol ⬆");
				text6 = createText("\n          \n          ");
				if_block3.c();
				text7 = createText("\n\n        \n          ");
				if (if_block4) if_block4.c();
				text8 = createText("\n\n          ");
				if (if_block5) if_block5.c();
				text9 = createText("\n\n          ");
				if (if_block6) if_block6.c();
				text10 = createText("\n\n        \n\n        ");
				if (if_block7) if_block7.c();
				text11 = createText("\n\n        \n\n        ");
				if (if_block8) if_block8.c();
				text12 = createText("\n\n        \n        ");
				div1 = createElement("div");
				if_block9.c();
				text13 = createText("\n\n        \n\n        ");
				if (if_block10) if_block10.c();
				addListener(button0, "click", click_handler);
				button0.className = "volume svelte-96fn1x";
				button0.disabled = button0_disabled_value = !ctx.$connected || ctx.$player.volume == 0;
				toggleClass(button0, "touch_pressed", ctx.touchAction == 'volume_down');
				addLoc(button0, file$p, 87, 10, 4348);
				addListener(button1, "click", click_handler_1);
				button1.className = "volume svelte-96fn1x";
				button1.disabled = button1_disabled_value = !ctx.$connected || ctx.$player.volume == 100;
				toggleClass(button1, "touch_pressed", ctx.touchAction == 'volume_up');
				addLoc(button1, file$p, 88, 10, 4519);
				div0.className = "control svelte-96fn1x";
				addLoc(div0, file$p, 55, 8, 2198);
				div1.id = "player_ribbon_top";
				div1.className = "svelte-96fn1x";
				addLoc(div1, file$p, 165, 8, 7707);
				div2.className = "player svelte-96fn1x";
				toggleClass(div2, "nonRPi", !ctx.atRPi);
				addLoc(div2, file$p, 54, 6, 2147);
			},

			m: function mount(target, anchor) {
				insert(target, div2, anchor);
				append(div2, div0);
				if (if_block0) if_block0.m(div0, null);
				append(div0, text0);
				if (if_block1) if_block1.m(div0, null);
				append(div0, text1);
				if (if_block2) if_block2.m(div0, null);
				append(div0, text2);
				append(div0, button0);
				append(button0, text3);
				append(div0, text4);
				append(div0, button1);
				append(button1, text5);
				append(div0, text6);
				if_block3.m(div0, null);
				append(div2, text7);
				if (if_block4) if_block4.m(div2, null);
				append(div2, text8);
				if (if_block5) if_block5.m(div2, null);
				append(div2, text9);
				if (if_block6) if_block6.m(div2, null);
				append(div2, text10);
				if (if_block7) if_block7.m(div2, null);
				append(div2, text11);
				if (if_block8) if_block8.m(div2, null);
				append(div2, text12);
				append(div2, div1);
				if_blocks[current_block_type_index].m(div1, null);
				append(div2, text13);
				if (if_block10) if_block10.m(div2, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$player.isStream || (ctx.$playlist && ctx.$playlist.length > 0)) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_23(component, ctx);
						if_block0.c();
						if_block0.m(div0, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (!ctx.$player.isStream && ctx.$playlist && ctx.$playlist.length > 0) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_21(component, ctx);
						if_block1.c();
						if_block1.m(div0, text1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.$player.isStream) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_20(component, ctx);
						if_block2.c();
						if_block2.m(div0, text2);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if ((!current || changed.$connected || changed.$player) && button0_disabled_value !== (button0_disabled_value = !ctx.$connected || ctx.$player.volume == 0)) {
					button0.disabled = button0_disabled_value;
				}

				if (changed.touchAction) {
					toggleClass(button0, "touch_pressed", ctx.touchAction == 'volume_down');
				}

				if ((!current || changed.$connected || changed.$player) && button1_disabled_value !== (button1_disabled_value = !ctx.$connected || ctx.$player.volume == 100)) {
					button1.disabled = button1_disabled_value;
				}

				if (changed.touchAction) {
					toggleClass(button1, "touch_pressed", ctx.touchAction == 'volume_up');
				}

				if (current_block_type === (current_block_type = select_block_type_5(ctx)) && if_block3) {
					if_block3.p(changed, ctx);
				} else {
					if_block3.d(1);
					if_block3 = current_block_type(component, ctx);
					if_block3.c();
					if_block3.m(div0, null);
				}

				if (current_block_type_1 === (current_block_type_1 = select_block_type_6(ctx)) && if_block4) {
					if_block4.p(changed, ctx);
				} else {
					if (if_block4) if_block4.d(1);
					if_block4 = current_block_type_1 && current_block_type_1(component, ctx);
					if (if_block4) if_block4.c();
					if (if_block4) if_block4.m(div2, text8);
				}

				if (ctx.$player.limitReached) {
					if (!if_block5) {
						if_block5 = create_if_block_16$1();
						if_block5.c();
						if_block5.m(div2, text9);
					}
				} else if (if_block5) {
					if_block5.d(1);
					if_block5 = null;
				}

				if (ctx.$player.timeLimitReached) {
					if (!if_block6) {
						if_block6 = create_if_block_15$1();
						if_block6.c();
						if_block6.m(div2, text10);
					}
				} else if (if_block6) {
					if_block6.d(1);
					if_block6 = null;
				}

				if (!ctx.$player.isStream) {
					if (if_block7) {
						if_block7.p(changed, ctx);
					} else {
						if_block7 = create_if_block_13$1(component, ctx);
						if_block7.c();
						if_block7.m(div2, text11);
					}
				} else if (if_block7) {
					if_block7.d(1);
					if_block7 = null;
				}

				if (ctx.$player.currentMedia && ctx.$player.currentMedia.song) {
					if (if_block8) {
						if_block8.p(changed, ctx);
					} else {
						if_block8 = create_if_block_10$4(component, ctx);
						if (if_block8) if_block8.c();
					}

					if_block8.i(div2, text12);
				} else if (if_block8) {
					if_block8.o(function() {
						if_block8.d(1);
						if_block8 = null;
					});
				}

				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_7(ctx);
				if (current_block_type_index !== previous_block_index) {
					if_block9.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block9 = if_blocks[current_block_type_index];
					if (!if_block9) {
						if_block9 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block9.c();
					}
					if_block9.m(div1, null);
				}

				if (!ctx.$player.isStream && ctx.$playlist) {
					if (if_block10) {
						if_block10.p(changed, ctx);
					} else {
						if_block10 = create_if_block_4$c(component, ctx);
						if_block10.c();
						if_block10.m(div2, null);
					}
				} else if (if_block10) {
					if_block10.d(1);
					if_block10 = null;
				}

				if (changed.atRPi) {
					toggleClass(div2, "nonRPi", !ctx.atRPi);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 2);

				if (if_block8) if_block8.o(outrocallback);
				else outrocallback();

				if (if_block9) if_block9.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				removeListener(button0, "click", click_handler);
				removeListener(button1, "click", click_handler_1);
				if_block3.d();
				if (if_block4) if_block4.d();
				if (if_block5) if_block5.d();
				if (if_block6) if_block6.d();
				if (if_block7) if_block7.d();
				if (if_block8) if_block8.d();
				if_blocks[current_block_type_index].d();
				if (if_block10) if_block10.d();
			}
		};
	}

	// (222:8) {#if $player.error.type == 'mpv_binary_missing'}
	function create_if_block_26(component, ctx) {
		var if_block_anchor;

		function select_block_type_8(ctx) {
			if (ctx.atRPi) return create_if_block_27;
			return create_else_block_5;
		}

		var current_block_type = select_block_type_8(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type_8(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			d: function destroy(detach) {
				if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (225:10) {:else}
	function create_else_block_5(component, ctx) {
		var text0, a, text1, a_href_value;

		return {
			c: function create() {
				text0 = createText("🆘 ");
				a = createElement("a");
				text1 = createText("Click here for install instructions ...");
				a.href = a_href_value = "$" + ctx.$player.error.helpUrl;
				a.className = "svelte-96fn1x";
				addLoc(a, file$p, 225, 15, 10530);
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, a, anchor);
				append(a, text1);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && a_href_value !== (a_href_value = "$" + ctx.$player.error.helpUrl)) {
					a.href = a_href_value;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(a);
				}
			}
		};
	}

	// (223:10) {#if atRPi}
	function create_if_block_27(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("Please use the DMT RaspberryPi guide to compile the mpv project.");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: noop,

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (58:10) {#if $player.isStream || ($playlist && $playlist.length > 0)}
	function create_if_block_23(component, ctx) {
		var if_block_anchor;

		function select_block_type_3(ctx) {
			if (ctx.$player.paused) return create_if_block_24;
			return create_else_block_3;
		}

		var current_block_type = select_block_type_3(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			d: function destroy(detach) {
				if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (66:12) {:else}
	function create_else_block_3(component, ctx) {
		var button, text, button_disabled_value;

		function click_handler(event) {
			component.pause();
		}

		return {
			c: function create() {
				button = createElement("button");
				text = createText("● Pause");
				addListener(button, "click", click_handler);
				button.className = "pause svelte-96fn1x";
				button.disabled = button_disabled_value = !ctx.$connected;
				toggleClass(button, "touch_pressed", ctx.touchAction == 'pause');
				addLoc(button, file$p, 66, 14, 2795);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
				append(button, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$connected) && button_disabled_value !== (button_disabled_value = !ctx.$connected)) {
					button.disabled = button_disabled_value;
				}

				if (changed.touchAction) {
					toggleClass(button, "touch_pressed", ctx.touchAction == 'pause');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (59:12) {#if $player.paused}
	function create_if_block_24(component, ctx) {
		var if_block_anchor;

		function select_block_type_4(ctx) {
			if (ctx.homebase) return create_if_block_25;
			return create_else_block_2$1;
		}

		var current_block_type = select_block_type_4(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			d: function destroy(detach) {
				if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (62:14) {:else}
	function create_else_block_2$1(component, ctx) {
		var button, text, button_disabled_value;

		function click_handler(event) {
			component.play();
		}

		return {
			c: function create() {
				button = createElement("button");
				text = createText("▶ Play");
				addListener(button, "click", click_handler);
				button.className = "play foreign svelte-96fn1x";
				button.disabled = button_disabled_value = !ctx.$connected;
				toggleClass(button, "touch_pressed", ctx.touchAction == 'play');
				addLoc(button, file$p, 63, 16, 2608);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
				append(button, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$connected) && button_disabled_value !== (button_disabled_value = !ctx.$connected)) {
					button.disabled = button_disabled_value;
				}

				if (changed.touchAction) {
					toggleClass(button, "touch_pressed", ctx.touchAction == 'play');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (60:14) {#if homebase}
	function create_if_block_25(component, ctx) {
		var button, text, button_disabled_value;

		function click_handler(event) {
			component.play();
		}

		return {
			c: function create() {
				button = createElement("button");
				text = createText("▶ Play");
				addListener(button, "click", click_handler);
				button.className = "play svelte-96fn1x";
				button.disabled = button_disabled_value = !ctx.$connected;
				toggleClass(button, "touch_pressed", ctx.touchAction == 'play');
				addLoc(button, file$p, 60, 16, 2371);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
				append(button, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$connected) && button_disabled_value !== (button_disabled_value = !ctx.$connected)) {
					button.disabled = button_disabled_value;
				}

				if (changed.touchAction) {
					toggleClass(button, "touch_pressed", ctx.touchAction == 'play');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (71:10) {#if !$player.isStream && $playlist && $playlist.length > 0}
	function create_if_block_21(component, ctx) {
		var button0, text0, text1_value = ctx.$player.limit || '', text1, button0_disabled_value, text2, button1, text3, button1_disabled_value, text4, button2, text5, button2_disabled_value, text6, button3, text7, button3_disabled_value;

		function click_handler(event) {
			component.limitIncrease();
		}

		function click_handler_1(event) {
			component.next();
		}

		function click_handler_2(event) {
			component.shuffle();
		}

		var if_block = (ctx.$player.repeatCount) && create_if_block_22(component, ctx);

		function click_handler_3(event) {
			component.repeatIncrease();
		}

		return {
			c: function create() {
				button0 = createElement("button");
				text0 = createText("Limit ");
				text1 = createText(text1_value);
				text2 = createText("\n            ");
				button1 = createElement("button");
				text3 = createText("➬ Next");
				text4 = createText("\n            ");
				button2 = createElement("button");
				text5 = createText("Shuffle");
				text6 = createText("\n\n            ");
				button3 = createElement("button");
				text7 = createText("Repeat\n            ");
				if (if_block) if_block.c();
				addListener(button0, "click", click_handler);
				button0.disabled = button0_disabled_value = !ctx.$connected;
				button0.className = "svelte-96fn1x";
				toggleClass(button0, "limit_active", ctx.$player.limit > 0);
				toggleClass(button0, "time_limit_active", ctx.$player.timeLimit > 0);
				toggleClass(button0, "touch_pressed", ctx.touchAction == 'limit' || ctx.touchAction == 'time_limit');
				addLoc(button0, file$p, 71, 12, 3041);
				addListener(button1, "click", click_handler_1);
				button1.disabled = button1_disabled_value = !ctx.$connected;
				button1.className = "svelte-96fn1x";
				toggleClass(button1, "touch_pressed", ctx.touchAction == 'next');
				addLoc(button1, file$p, 72, 12, 3313);
				addListener(button2, "click", click_handler_2);
				button2.disabled = button2_disabled_value = !ctx.$connected;
				button2.className = "svelte-96fn1x";
				toggleClass(button2, "touch_pressed", ctx.touchAction == 'shuffle');
				addLoc(button2, file$p, 73, 12, 3436);
				addListener(button3, "click", click_handler_3);
				button3.disabled = button3_disabled_value = !ctx.$connected;
				button3.className = "svelte-96fn1x";
				toggleClass(button3, "touch_pressed", ctx.touchAction == 'repeat');
				toggleClass(button3, "repeat_active1", ctx.$player.repeatCount == 1);
				toggleClass(button3, "repeat_active2", ctx.$player.repeatCount == 2);
				toggleClass(button3, "repeat_active3", ctx.$player.repeatCount == 3);
				addLoc(button3, file$p, 75, 12, 3567);
			},

			m: function mount(target, anchor) {
				insert(target, button0, anchor);
				append(button0, text0);
				append(button0, text1);
				insert(target, text2, anchor);
				insert(target, button1, anchor);
				append(button1, text3);
				insert(target, text4, anchor);
				insert(target, button2, anchor);
				append(button2, text5);
				insert(target, text6, anchor);
				insert(target, button3, anchor);
				append(button3, text7);
				if (if_block) if_block.m(button3, null);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text1_value !== (text1_value = ctx.$player.limit || '')) {
					setData(text1, text1_value);
				}

				if ((changed.$connected) && button0_disabled_value !== (button0_disabled_value = !ctx.$connected)) {
					button0.disabled = button0_disabled_value;
				}

				if (changed.$player) {
					toggleClass(button0, "limit_active", ctx.$player.limit > 0);
					toggleClass(button0, "time_limit_active", ctx.$player.timeLimit > 0);
				}

				if (changed.touchAction) {
					toggleClass(button0, "touch_pressed", ctx.touchAction == 'limit' || ctx.touchAction == 'time_limit');
				}

				if ((changed.$connected) && button1_disabled_value !== (button1_disabled_value = !ctx.$connected)) {
					button1.disabled = button1_disabled_value;
				}

				if (changed.touchAction) {
					toggleClass(button1, "touch_pressed", ctx.touchAction == 'next');
				}

				if ((changed.$connected) && button2_disabled_value !== (button2_disabled_value = !ctx.$connected)) {
					button2.disabled = button2_disabled_value;
				}

				if (changed.touchAction) {
					toggleClass(button2, "touch_pressed", ctx.touchAction == 'shuffle');
				}

				if (ctx.$player.repeatCount) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_22(component, ctx);
						if_block.c();
						if_block.m(button3, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if ((changed.$connected) && button3_disabled_value !== (button3_disabled_value = !ctx.$connected)) {
					button3.disabled = button3_disabled_value;
				}

				if (changed.touchAction) {
					toggleClass(button3, "touch_pressed", ctx.touchAction == 'repeat');
				}

				if (changed.$player) {
					toggleClass(button3, "repeat_active1", ctx.$player.repeatCount == 1);
					toggleClass(button3, "repeat_active2", ctx.$player.repeatCount == 2);
					toggleClass(button3, "repeat_active3", ctx.$player.repeatCount == 3);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button0);
				}

				removeListener(button0, "click", click_handler);
				if (detach) {
					detachNode(text2);
					detachNode(button1);
				}

				removeListener(button1, "click", click_handler_1);
				if (detach) {
					detachNode(text4);
					detachNode(button2);
				}

				removeListener(button2, "click", click_handler_2);
				if (detach) {
					detachNode(text6);
					detachNode(button3);
				}

				if (if_block) if_block.d();
				removeListener(button3, "click", click_handler_3);
			}
		};
	}

	// (77:12) {#if $player.repeatCount}
	function create_if_block_22(component, ctx) {
		var text_value = ctx.$player.repeatCount, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text_value !== (text_value = ctx.$player.repeatCount)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (83:10) {#if $player.isStream}
	function create_if_block_20(component, ctx) {
		var button0, text0, button0_disabled_value, text1, button1, text2, button1_disabled_value;

		function click_handler(event) {
			component.limitIncrease();
		}

		function click_handler_1(event) {
			component.stop();
		}

		return {
			c: function create() {
				button0 = createElement("button");
				text0 = createText("Limit");
				text1 = createText("\n            ");
				button1 = createElement("button");
				text2 = createText("Quit");
				addListener(button0, "click", click_handler);
				button0.disabled = button0_disabled_value = !ctx.$connected;
				button0.className = "svelte-96fn1x";
				toggleClass(button0, "time_limit_active", ctx.$player.timeLimit > 0);
				toggleClass(button0, "touch_pressed", ctx.touchAction == 'limit' || ctx.touchAction == 'time_limit');
				addLoc(button0, file$p, 83, 12, 4001);
				addListener(button1, "click", click_handler_1);
				button1.disabled = button1_disabled_value = !ctx.$connected;
				button1.className = "svelte-96fn1x";
				toggleClass(button1, "touch_pressed", ctx.touchAction == 'stop');
				addLoc(button1, file$p, 84, 12, 4212);
			},

			m: function mount(target, anchor) {
				insert(target, button0, anchor);
				append(button0, text0);
				insert(target, text1, anchor);
				insert(target, button1, anchor);
				append(button1, text2);
			},

			p: function update(changed, ctx) {
				if ((changed.$connected) && button0_disabled_value !== (button0_disabled_value = !ctx.$connected)) {
					button0.disabled = button0_disabled_value;
				}

				if (changed.$player) {
					toggleClass(button0, "time_limit_active", ctx.$player.timeLimit > 0);
				}

				if (changed.touchAction) {
					toggleClass(button0, "touch_pressed", ctx.touchAction == 'limit' || ctx.touchAction == 'time_limit');
				}

				if ((changed.$connected) && button1_disabled_value !== (button1_disabled_value = !ctx.$connected)) {
					button1.disabled = button1_disabled_value;
				}

				if (changed.touchAction) {
					toggleClass(button1, "touch_pressed", ctx.touchAction == 'stop');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button0);
				}

				removeListener(button0, "click", click_handler);
				if (detach) {
					detachNode(text1);
					detachNode(button1);
				}

				removeListener(button1, "click", click_handler_1);
			}
		};
	}

	// (93:10) {:else}
	function create_else_block_1$2(component, ctx) {
		var span, text_value = ctx.$player.volume, text;

		return {
			c: function create() {
				span = createElement("span");
				text = createText(text_value);
				span.className = "volume foreign svelte-96fn1x";
				addLoc(span, file$p, 94, 12, 4922);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				append(span, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text_value !== (text_value = ctx.$player.volume)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (91:10) {#if homebase}
	function create_if_block_19(component, ctx) {
		var span, text_value = ctx.$player.volume, text;

		return {
			c: function create() {
				span = createElement("span");
				text = createText(text_value);
				span.className = "volume svelte-96fn1x";
				addLoc(span, file$p, 91, 12, 4777);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				append(span, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text_value !== (text_value = ctx.$player.volume)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (104:37) 
	function create_if_block_18(component, ctx) {
		var div, span1, text0, span0, text1, text2, a0, text4, a1;

		function click_handler(event) {
			event.preventDefault();
			event.stopPropagation();
			component.timeLimitReset();
		}

		function click_handler_1(event) {
			event.preventDefault();
			event.stopPropagation();
			component.timeLimitIncrease();
		}

		return {
			c: function create() {
				div = createElement("div");
				span1 = createElement("span");
				text0 = createText("Stopping in ");
				span0 = createElement("span");
				text1 = createText(ctx.timeLimit);
				text2 = createText("\n              ■ ");
				a0 = createElement("a");
				a0.textContent = "REMOVE LIMIT";
				text4 = createText("\n              ■ ");
				a1 = createElement("a");
				a1.textContent = "ADD MORE TIME";
				span0.className = "limit_num svelte-96fn1x";
				addLoc(span0, file$p, 105, 85, 5834);
				addListener(a0, "click", click_handler);
				a0.href = "#";
				a0.className = "svelte-96fn1x";
				toggleClass(a0, "touch_pressed", ctx.touchAction == 'remove_time_limit');
				addLoc(a0, file$p, 106, 16, 5893);
				addListener(a1, "click", click_handler_1);
				a1.href = "#";
				a1.className = "set_time_limit svelte-96fn1x";
				toggleClass(a1, "touch_pressed", ctx.touchAction == 'time_limit');
				addLoc(a1, file$p, 107, 16, 6054);
				span1.className = "time_limit svelte-96fn1x";
				toggleClass(span1, "grayed_out", ctx.$player.paused);
				addLoc(span1, file$p, 105, 14, 5763);
				div.className = "limit_info svelte-96fn1x";
				addLoc(div, file$p, 104, 12, 5724);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, span1);
				append(span1, text0);
				append(span1, span0);
				append(span0, text1);
				append(span1, text2);
				append(span1, a0);
				append(span1, text4);
				append(span1, a1);
			},

			p: function update(changed, ctx) {
				if (changed.timeLimit) {
					setData(text1, ctx.timeLimit);
				}

				if (changed.touchAction) {
					toggleClass(a0, "touch_pressed", ctx.touchAction == 'remove_time_limit');
					toggleClass(a1, "touch_pressed", ctx.touchAction == 'time_limit');
				}

				if (changed.$player) {
					toggleClass(span1, "grayed_out", ctx.$player.paused);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(a0, "click", click_handler);
				removeListener(a1, "click", click_handler_1);
			}
		};
	}

	// (100:10) {#if !$player.isStream && $player.limit}
	function create_if_block_17(component, ctx) {
		var div, span1, text0, span0, text1_value = ctx.$player.limit == 1 ? 'current' : ctx.$player.limit, text1, text2, text3_value = ctx.$player.limit == 1 ? 'track' : 'tracks', text3, text4, a0, text6, a1;

		function click_handler(event) {
			event.preventDefault();
			event.stopPropagation();
			component.limitReset();
		}

		function click_handler_1(event) {
			event.preventDefault();
			event.stopPropagation();
			component.timeLimitIncrease();
		}

		return {
			c: function create() {
				div = createElement("div");
				span1 = createElement("span");
				text0 = createText("Stop after ");
				span0 = createElement("span");
				text1 = createText(text1_value);
				text2 = createText(" ");
				text3 = createText(text3_value);
				text4 = createText(" ■ ");
				a0 = createElement("a");
				a0.textContent = "REMOVE LIMIT";
				text6 = createText(" ■ ");
				a1 = createElement("a");
				a1.textContent = "SET TIME LIMIT";
				span0.className = "limit_num svelte-96fn1x";
				addLoc(span0, file$p, 101, 51, 5220);
				addListener(a0, "click", click_handler);
				a0.href = "#";
				a0.className = "svelte-96fn1x";
				toggleClass(a0, "touch_pressed", ctx.touchAction == 'remove_limit');
				addLoc(a0, file$p, 101, 175, 5344);
				addListener(a1, "click", click_handler_1);
				a1.href = "#";
				a1.className = "set_time_limit svelte-96fn1x";
				toggleClass(a1, "touch_pressed", ctx.touchAction == 'time_limit');
				addLoc(a1, file$p, 101, 313, 5482);
				span1.className = "track_limit svelte-96fn1x";
				addLoc(span1, file$p, 101, 14, 5183);
				div.className = "limit_info svelte-96fn1x";
				addLoc(div, file$p, 100, 12, 5144);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, span1);
				append(span1, text0);
				append(span1, span0);
				append(span0, text1);
				append(span1, text2);
				append(span1, text3);
				append(span1, text4);
				append(span1, a0);
				append(span1, text6);
				append(span1, a1);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text1_value !== (text1_value = ctx.$player.limit == 1 ? 'current' : ctx.$player.limit)) {
					setData(text1, text1_value);
				}

				if ((changed.$player) && text3_value !== (text3_value = ctx.$player.limit == 1 ? 'track' : 'tracks')) {
					setData(text3, text3_value);
				}

				if (changed.touchAction) {
					toggleClass(a0, "touch_pressed", ctx.touchAction == 'remove_limit');
					toggleClass(a1, "touch_pressed", ctx.touchAction == 'time_limit');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(a0, "click", click_handler);
				removeListener(a1, "click", click_handler_1);
			}
		};
	}

	// (112:10) {#if $player.limitReached}
	function create_if_block_16$1(component, ctx) {
		var div;

		return {
			c: function create() {
				div = createElement("div");
				div.textContent = "Paused because limit was reached.";
				div.className = "limit_reached svelte-96fn1x";
				addLoc(div, file$p, 112, 12, 6304);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (118:10) {#if $player.timeLimitReached}
	function create_if_block_15$1(component, ctx) {
		var div;

		return {
			c: function create() {
				div = createElement("div");
				div.textContent = "Paused because time limit was reached.";
				div.className = "time_limit_reached svelte-96fn1x";
				addLoc(div, file$p, 118, 12, 6469);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (128:8) {#if !$player.isStream}
	function create_if_block_13$1(component, ctx) {
		var if_block_anchor;

		var if_block = (!ctx.$playlist || ctx.$playlist.length == 0) && create_if_block_14$1();

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (!ctx.$playlist || ctx.$playlist.length == 0) {
					if (!if_block) {
						if_block = create_if_block_14$1();
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (130:10) {#if !$playlist || $playlist.length == 0}
	function create_if_block_14$1(component, ctx) {
		var div, h1;

		return {
			c: function create() {
				div = createElement("div");
				h1 = createElement("h1");
				h1.textContent = "Playlist is empty";
				h1.className = "svelte-96fn1x";
				addLoc(h1, file$p, 131, 14, 6855);
				div.className = "player_notice svelte-96fn1x";
				addLoc(div, file$p, 130, 12, 6813);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h1);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	// (140:8) {#if $player.currentMedia && $player.currentMedia.song}
	function create_if_block_10$4(component, ctx) {
		var div1, div0, text0, text1, text2_value = ctx.$player.currentMedia.song, text2, text3, div2, current;

		var if_block0 = (!ctx.$player.paused) && create_if_block_12$3();

		var if_block1 = (ctx.$player.currentMedia.artist) && create_if_block_11$3(component, ctx);

		var mediatimeposition = new MediaTimePosition({
			root: component.root,
			store: component.store
		});

		mediatimeposition.on("seek", function(event) {
			component.seek(event.percentPos);
		});

		return {
			c: function create() {
				div1 = createElement("div");
				div0 = createElement("div");
				if (if_block0) if_block0.c();
				text0 = createText("\n\n            ");
				if (if_block1) if_block1.c();
				text1 = createText("\n\n            ");
				text2 = createText(text2_value);
				text3 = createText("\n\n          ");
				div2 = createElement("div");
				mediatimeposition._fragment.c();
				div0.className = "song svelte-96fn1x";
				toggleClass(div0, "bigger", ctx.$player.currentMedia.song.length < 35);
				addLoc(div0, file$p, 144, 12, 7176);
				div1.className = "streaming_media_info svelte-96fn1x";
				toggleClass(div1, "faded", ctx.$player.paused);
				addLoc(div1, file$p, 140, 10, 7039);
				div2.className = "time_position svelte-96fn1x";
				addLoc(div2, file$p, 159, 10, 7538);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				if (if_block0) if_block0.m(div0, null);
				append(div0, text0);
				if (if_block1) if_block1.m(div0, null);
				append(div0, text1);
				append(div0, text2);
				insert(target, text3, anchor);
				insert(target, div2, anchor);
				mediatimeposition._mount(div2, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (!ctx.$player.paused) {
					if (!if_block0) {
						if_block0 = create_if_block_12$3();
						if_block0.c();
						if_block0.m(div0, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.$player.currentMedia.artist) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_11$3(component, ctx);
						if_block1.c();
						if_block1.m(div0, text1);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if ((!current || changed.$player) && text2_value !== (text2_value = ctx.$player.currentMedia.song)) {
					setData(text2, text2_value);
				}

				if (changed.$player) {
					toggleClass(div0, "bigger", ctx.$player.currentMedia.song.length < 35);
					toggleClass(div1, "faded", ctx.$player.paused);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (mediatimeposition) mediatimeposition._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (detach) {
					detachNode(text3);
					detachNode(div2);
				}

				mediatimeposition.destroy();
			}
		};
	}

	// (147:14) {#if !$player.paused}
	function create_if_block_12$3(component, ctx) {
		var span;

		return {
			c: function create() {
				span = createElement("span");
				span.textContent = "♪♫♬";
				span.className = "svelte-96fn1x";
				addLoc(span, file$p, 147, 16, 7301);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (151:12) {#if $player.currentMedia.artist}
	function create_if_block_11$3(component, ctx) {
		var text0_value = ctx.$player.currentMedia.artist, text0, text1;

		return {
			c: function create() {
				text0 = createText(text0_value);
				text1 = createText(" -");
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, text1, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text0_value !== (text0_value = ctx.$player.currentMedia.artist)) {
					setData(text0, text0_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(text1);
				}
			}
		};
	}

	// (169:10) {:else}
	function create_else_block$5(component, ctx) {
		var current;

		var ribbontop = new RibbonTop({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				ribbontop._fragment.c();
			},

			m: function mount(target, anchor) {
				ribbontop._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (ribbontop) ribbontop._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				ribbontop.destroy(detach);
			}
		};
	}

	// (167:10) {#if ($player.hasMissingMedia && !$player.isStream) || $playlistMetadata.playlistHasSelectedEntries || $playlistMetadata.playlistClipboard}
	function create_if_block_9$5(component, ctx) {
		var current;

		var ribboncurrentselectionandmissing = new RibbonCurrentSelectionAndMissing({
			root: component.root,
			store: component.store
		});

		ribboncurrentselectionandmissing.on("mediaSourceOption", function(event) {
			component.selectMediaSource(event.mediaSourceOption);
		});

		return {
			c: function create() {
				ribboncurrentselectionandmissing._fragment.c();
			},

			m: function mount(target, anchor) {
				ribboncurrentselectionandmissing._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (ribboncurrentselectionandmissing) ribboncurrentselectionandmissing._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				ribboncurrentselectionandmissing.destroy(detach);
			}
		};
	}

	// (176:8) {#if !$player.isStream && $playlist}
	function create_if_block_4$c(component, ctx) {
		var div, ul;

		var each_value_3 = ctx.$playlist;

		var each_blocks = [];

		for (var i = 0; i < each_value_3.length; i += 1) {
			each_blocks[i] = create_each_block$5(component, get_each_context_3(ctx, each_value_3, i));
		}

		return {
			c: function create() {
				div = createElement("div");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				ul.className = "svelte-96fn1x";
				addLoc(ul, file$p, 177, 12, 8212);
				div.id = "playlist";
				div.className = "svelte-96fn1x";
				toggleClass(div, "nonRPi", !ctx.atRPi);
				addLoc(div, file$p, 176, 10, 8158);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, ul);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.$playlist || changed.$player) {
					each_value_3 = ctx.$playlist;

					for (var i = 0; i < each_value_3.length; i += 1) {
						const child_ctx = get_each_context_3(ctx, each_value_3, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$5(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_3.length;
				}

				if (changed.atRPi) {
					toggleClass(div, "nonRPi", !ctx.atRPi);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (181:16) {#if song.albumTitle}
	function create_if_block_8$6(component, ctx) {
		var li, text_value = ctx.song.albumTitle, text;

		return {
			c: function create() {
				li = createElement("li");
				text = createText(text_value);
				li.className = "album_title svelte-96fn1x";
				addLoc(li, file$p, 181, 18, 8314);
			},

			m: function mount(target, anchor) {
				insert(target, li, anchor);
				append(li, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlist) && text_value !== (text_value = ctx.song.albumTitle)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(li);
				}
			}
		};
	}

	// (192:20) {#if song.metadata && song.metadata.duration && song.mediaType == 'video'}
	function create_if_block_7$8(component, ctx) {
		var span, text0, text1_value = ctx.song.metadata.duration, text1, text2;

		return {
			c: function create() {
				span = createElement("span");
				text0 = createText("[");
				text1 = createText(text1_value);
				text2 = createText("]");
				span.className = "duration svelte-96fn1x";
				toggleClass(span, "non_past", !ctx.song.past);
				addLoc(span, file$p, 192, 22, 9360);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				append(span, text0);
				append(span, text1);
				append(span, text2);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlist) && text1_value !== (text1_value = ctx.song.metadata.duration)) {
					setData(text1, text1_value);
				}

				if (changed.$playlist) {
					toggleClass(span, "non_past", !ctx.song.past);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (198:22) {#if song.current && $player.repeatCount}
	function create_if_block_6$8(component, ctx) {
		var span, text0, text1_value = ctx.$player.repeatCount, text1, text2;

		return {
			c: function create() {
				span = createElement("span");
				text0 = createText("(+");
				text1 = createText(text1_value);
				text2 = createText("x)");
				span.className = "repeat_song_mark svelte-96fn1x";
				addLoc(span, file$p, 198, 24, 9613);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				append(span, text0);
				append(span, text1);
				append(span, text2);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && text1_value !== (text1_value = ctx.$player.repeatCount)) {
					setData(text1, text1_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (205:20) {#if song.metadata && song.metadata.duration && song.mediaType == 'music'}
	function create_if_block_5$b(component, ctx) {
		var span, text0, text1_value = ctx.song.metadata.duration, text1, text2;

		return {
			c: function create() {
				span = createElement("span");
				text0 = createText("[");
				text1 = createText(text1_value);
				text2 = createText("]");
				span.className = "duration svelte-96fn1x";
				toggleClass(span, "non_past", !ctx.song.past);
				addLoc(span, file$p, 205, 22, 9923);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				append(span, text0);
				append(span, text1);
				append(span, text2);
			},

			p: function update(changed, ctx) {
				if ((changed.$playlist) && text1_value !== (text1_value = ctx.song.metadata.duration)) {
					setData(text1, text1_value);
				}

				if (changed.$playlist) {
					toggleClass(span, "non_past", !ctx.song.past);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (179:14) {#each $playlist as song}
	function create_each_block$5(component, ctx) {
		var text0, span0, text1_value = ctx.song.current ? (ctx.$player.paused ? '●' : (!ctx.$player.currentMedia || !ctx.$player.currentMedia.mediaType || ctx.$player.currentMedia.mediaType == 'music' ? '♫' : '▶')) : '', text1, text2, div, li, span1, text3_value = util.pad(ctx.song.id), text3, text4, text5, span2, text6_value = ctx.song.title, text6, text7, text8, text9;

		var if_block0 = (ctx.song.albumTitle) && create_if_block_8$6(component, ctx);

		var if_block1 = (ctx.song.metadata && ctx.song.metadata.duration && ctx.song.mediaType == 'video') && create_if_block_7$8(component, ctx);

		var if_block2 = (ctx.song.current && ctx.$player.repeatCount) && create_if_block_6$8(component, ctx);

		var if_block3 = (ctx.song.metadata && ctx.song.metadata.duration && ctx.song.mediaType == 'music') && create_if_block_5$b(component, ctx);

		return {
			c: function create() {
				if (if_block0) if_block0.c();
				text0 = createText("\n\n                ");
				span0 = createElement("span");
				text1 = createText(text1_value);
				text2 = createText("\n\n                ");
				div = createElement("div");
				li = createElement("li");
				span1 = createElement("span");
				text3 = createText(text3_value);
				text4 = createText("\n\n                    \n                    ");
				if (if_block1) if_block1.c();
				text5 = createText("\n\n                    ");
				span2 = createElement("span");
				text6 = createText(text6_value);
				text7 = createText("\n\n                      ");
				if (if_block2) if_block2.c();
				text8 = createText("\n\n                    \n                    ");
				if (if_block3) if_block3.c();
				text9 = createText("\n                ");
				span0.className = "marker svelte-96fn1x";
				toggleClass(span0, "limit_marker", ctx.$player.limit > 0);
				addLoc(span0, file$p, 184, 16, 8400);
				span1.className = "id svelte-96fn1x";
				addLoc(span1, file$p, 188, 20, 9125);
				span2.className = "song svelte-96fn1x";
				addLoc(span2, file$p, 195, 20, 9492);

				li._svelte = { component, ctx };

				addListener(li, "click", click_handler$2);
				li.className = "svelte-96fn1x";
				toggleClass(li, "playing", ctx.song.current && !ctx.$player.paused && !ctx.$player.isStream);
				toggleClass(li, "past", ctx.song.past);
				toggleClass(li, "within_limit", ctx.song.withinLimit);
				toggleClass(li, "about_to_be_cut", ctx.song.aboutToBeCut);
				toggleClass(li, "selected", ctx.song.selected);
				toggleClass(li, "just_pasted", ctx.song.justPasted);
				toggleClass(li, "just_bumped", ctx.song.justBumped);
				toggleClass(li, "error", ctx.song.error);
				toggleClass(li, "metadata_read", ctx.song.metadata);
				addLoc(li, file$p, 187, 18, 8732);
				div.className = "li_wrapper svelte-96fn1x";
				toggleClass(div, "darker", ctx.song.directoryTogetherness);
				addLoc(div, file$p, 186, 16, 8647);
			},

			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert(target, text0, anchor);
				insert(target, span0, anchor);
				append(span0, text1);
				insert(target, text2, anchor);
				insert(target, div, anchor);
				append(div, li);
				append(li, span1);
				append(span1, text3);
				append(li, text4);
				if (if_block1) if_block1.m(li, null);
				append(li, text5);
				append(li, span2);
				append(span2, text6);
				append(span2, text7);
				if (if_block2) if_block2.m(span2, null);
				append(li, text8);
				if (if_block3) if_block3.m(li, null);
				append(div, text9);
			},

			p: function update(changed, _ctx) {
				ctx = _ctx;
				if (ctx.song.albumTitle) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_8$6(component, ctx);
						if_block0.c();
						if_block0.m(text0.parentNode, text0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if ((changed.$playlist || changed.$player) && text1_value !== (text1_value = ctx.song.current ? (ctx.$player.paused ? '●' : (!ctx.$player.currentMedia || !ctx.$player.currentMedia.mediaType || ctx.$player.currentMedia.mediaType == 'music' ? '♫' : '▶')) : '')) {
					setData(text1, text1_value);
				}

				if (changed.$player) {
					toggleClass(span0, "limit_marker", ctx.$player.limit > 0);
				}

				if ((changed.$playlist) && text3_value !== (text3_value = util.pad(ctx.song.id))) {
					setData(text3, text3_value);
				}

				if (ctx.song.metadata && ctx.song.metadata.duration && ctx.song.mediaType == 'video') {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block_7$8(component, ctx);
						if_block1.c();
						if_block1.m(li, text5);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if ((changed.$playlist) && text6_value !== (text6_value = ctx.song.title)) {
					setData(text6, text6_value);
				}

				if (ctx.song.current && ctx.$player.repeatCount) {
					if (if_block2) {
						if_block2.p(changed, ctx);
					} else {
						if_block2 = create_if_block_6$8(component, ctx);
						if_block2.c();
						if_block2.m(span2, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if (ctx.song.metadata && ctx.song.metadata.duration && ctx.song.mediaType == 'music') {
					if (if_block3) {
						if_block3.p(changed, ctx);
					} else {
						if_block3 = create_if_block_5$b(component, ctx);
						if_block3.c();
						if_block3.m(li, null);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}

				li._svelte.ctx = ctx;
				if ((changed.$playlist || changed.$player)) {
					toggleClass(li, "playing", ctx.song.current && !ctx.$player.paused && !ctx.$player.isStream);
				}

				if (changed.$playlist) {
					toggleClass(li, "past", ctx.song.past);
					toggleClass(li, "within_limit", ctx.song.withinLimit);
					toggleClass(li, "about_to_be_cut", ctx.song.aboutToBeCut);
					toggleClass(li, "selected", ctx.song.selected);
					toggleClass(li, "just_pasted", ctx.song.justPasted);
					toggleClass(li, "just_bumped", ctx.song.justBumped);
					toggleClass(li, "error", ctx.song.error);
					toggleClass(li, "metadata_read", ctx.song.metadata);
					toggleClass(div, "darker", ctx.song.directoryTogetherness);
				}
			},

			d: function destroy(detach) {
				if (if_block0) if_block0.d(detach);
				if (detach) {
					detachNode(text0);
					detachNode(span0);
					detachNode(text2);
					detachNode(div);
				}

				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
				removeListener(li, "click", click_handler$2);
			}
		};
	}

	function Player(options) {
		this._debugName = '<Player>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Player> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","device","searchResults","player","playlist","playlistMetadata"]), options.data);
		this.store._add(this, ["connected","device","searchResults","player","playlist","playlistMetadata"]);
		if (!('loaded' in this._state)) console.warn("<Player> was created without expected data property 'loaded'");
		if (!('$connected' in this._state)) console.warn("<Player> was created without expected data property '$connected'");
		if (!('$device' in this._state)) console.warn("<Player> was created without expected data property '$device'");
		if (!('atRPi' in this._state)) console.warn("<Player> was created without expected data property 'atRPi'");
		if (!('searchQuery' in this._state)) console.warn("<Player> was created without expected data property 'searchQuery'");
		if (!('mediaType' in this._state)) console.warn("<Player> was created without expected data property 'mediaType'");
		if (!('$searchResults' in this._state)) console.warn("<Player> was created without expected data property '$searchResults'");
		if (!('$player' in this._state)) console.warn("<Player> was created without expected data property '$player'");
		if (!('$playlist' in this._state)) console.warn("<Player> was created without expected data property '$playlist'");
		if (!('homebase' in this._state)) console.warn("<Player> was created without expected data property 'homebase'");
		if (!('touchAction' in this._state)) console.warn("<Player> was created without expected data property 'touchAction'");
		if (!('timeLimit' in this._state)) console.warn("<Player> was created without expected data property 'timeLimit'");
		if (!('$playlistMetadata' in this._state)) console.warn("<Player> was created without expected data property '$playlistMetadata'");
		this._intro = !!options.intro;

		this._handlers.destroy = [ondestroy$2, removeFromStore];

		this._fragment = create_main_fragment$s(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$m.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Player.prototype, protoDev);
	assign(Player.prototype, methods$g);

	Player.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/AnalogClock.html generated by Svelte v2.16.1 */

	function getTime() {
	  const time = new Date();

	  return {
	    hours: time.getHours(),
	    minutes: time.getMinutes(),
	    seconds: time.getSeconds()
	  }
	}

	// original: https://github.com/sveltejs/v2.svelte.dev/blob/master/content/examples/svg-clock/App.html
	// had to rework state a bit because for some reason it didn't work ok in production (Rotate(NaN) error)
	// when using computed() properties
	function data() {
	  return getTime();
	}
	function oncreate$n() {
	  const update = () => {
	    this.set(getTime());
	    this.timer = setTimeout(update, 1000);
	  };

	  update();
	}
	function ondestroy$3() {
	  clearTimeout(this.timer);
	}
	const file$q = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/widgets/src/AnalogClock.html";

	function get_each_context_1$2(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.offset = list[i];
		return child_ctx;
	}

	function get_each_context$6(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.minute = list[i];
		return child_ctx;
	}

	function create_main_fragment$t(component, ctx) {
		var svg, circle, line0, line0_transform_value, line1, line1_transform_value, g, line2, line3, g_transform_value, current;

		var each_value = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55];

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$6(component, get_each_context$6(ctx, each_value, i));
		}

		return {
			c: function create() {
				svg = createSvgElement("svg");
				circle = createSvgElement("circle");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				line0 = createSvgElement("line");
				line1 = createSvgElement("line");
				g = createSvgElement("g");
				line2 = createSvgElement("line");
				line3 = createSvgElement("line");
				setAttribute(circle, "class", "clock-face svelte-mdkkpl");
				setAttribute(circle, "r", "48");
				addLoc(circle, file$q, 1, 2, 34);
				setAttribute(line0, "class", "hour svelte-mdkkpl");
				setAttribute(line0, "y1", "2");
				setAttribute(line0, "y2", "-20");
				setAttribute(line0, "transform", line0_transform_value = "rotate(" + (30 * ctx.hours + ctx.minutes / 2) + ")");
				addLoc(line0, file$q, 23, 2, 471);
				setAttribute(line1, "class", "minute svelte-mdkkpl");
				setAttribute(line1, "y1", "4");
				setAttribute(line1, "y2", "-30");
				setAttribute(line1, "transform", line1_transform_value = "rotate(" + (6 * ctx.minutes + ctx.seconds / 10) + ")");
				addLoc(line1, file$q, 31, 2, 600);
				setAttribute(line2, "class", "second svelte-mdkkpl");
				setAttribute(line2, "y1", "10");
				setAttribute(line2, "y2", "-38");
				addLoc(line2, file$q, 40, 4, 775);
				setAttribute(line3, "class", "second-counterweight svelte-mdkkpl");
				setAttribute(line3, "y1", "10");
				setAttribute(line3, "y2", "2");
				addLoc(line3, file$q, 41, 4, 819);
				setAttribute(g, "transform", g_transform_value = "rotate(" + 6 * ctx.seconds + ")");
				setAttribute(g, "class", "svelte-mdkkpl");
				addLoc(g, file$q, 39, 2, 733);
				setAttribute(svg, "viewBox", "-50 -50 100 100");
				setAttribute(svg, "class", "svelte-mdkkpl");
				addLoc(svg, file$q, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, svg, anchor);
				append(svg, circle);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(svg, null);
				}

				append(svg, line0);
				append(svg, line1);
				append(svg, g);
				append(g, line2);
				append(g, line3);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((changed.hours || changed.minutes) && line0_transform_value !== (line0_transform_value = "rotate(" + (30 * ctx.hours + ctx.minutes / 2) + ")")) {
					setAttribute(line0, "transform", line0_transform_value);
				}

				if ((changed.minutes || changed.seconds) && line1_transform_value !== (line1_transform_value = "rotate(" + (6 * ctx.minutes + ctx.seconds / 10) + ")")) {
					setAttribute(line1, "transform", line1_transform_value);
				}

				if ((changed.seconds) && g_transform_value !== (g_transform_value = "rotate(" + 6 * ctx.seconds + ")")) {
					setAttribute(g, "transform", g_transform_value);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(svg);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (13:4) {#each [1, 2, 3, 4] as offset}
	function create_each_block_1$2(component, ctx) {
		var line;

		return {
			c: function create() {
				line = createSvgElement("line");
				setAttribute(line, "class", "minor svelte-mdkkpl");
				setAttribute(line, "y1", "42");
				setAttribute(line, "y2", "45");
				setAttribute(line, "transform", "rotate(" + 6 * (ctx.minute + ctx.offset) + ")");
				addLoc(line, file$q, 13, 6, 304);
			},

			m: function mount(target, anchor) {
				insert(target, line, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(line);
				}
			}
		};
	}

	// (5:2) {#each [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55] as minute}
	function create_each_block$6(component, ctx) {
		var line, each_anchor;

		var each_value_1 = [1, 2, 3, 4];

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$2(component, get_each_context_1$2(ctx, each_value_1, i));
		}

		return {
			c: function create() {
				line = createSvgElement("line");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
				setAttribute(line, "class", "major svelte-mdkkpl");
				setAttribute(line, "y1", "40");
				setAttribute(line, "y2", "45");
				setAttribute(line, "transform", "rotate(" + 30 * ctx.minute + ")");
				addLoc(line, file$q, 5, 4, 161);
			},

			m: function mount(target, anchor) {
				insert(target, line, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insert(target, each_anchor, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(line);
				}

				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	function AnalogClock(options) {
		this._debugName = '<AnalogClock>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign(data(), options.data);
		if (!('hours' in this._state)) console.warn("<AnalogClock> was created without expected data property 'hours'");
		if (!('minutes' in this._state)) console.warn("<AnalogClock> was created without expected data property 'minutes'");
		if (!('seconds' in this._state)) console.warn("<AnalogClock> was created without expected data property 'seconds'");
		this._intro = !!options.intro;

		this._handlers.destroy = [ondestroy$3];

		this._fragment = create_main_fragment$t(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$n.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(AnalogClock.prototype, protoDev);

	AnalogClock.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/clock/src/Clock.html generated by Svelte v2.16.1 */



	var methods$h = {
	  go(handle) {
	    window.location.href = `http://${window.location.hostname}:${window.location.port}/${handle}`;
	  },
	  select(view) {
	    this.fire('select', { view });
	  },
	  toggleClock() {
	    this.set({ clockHidden: !this.get().clockHidden });

	    const visibility = this.get().clockHidden ? 'hidden' : 'visible';

	    document.getElementById('clock_inner').style.visibility = visibility;
	  }
	};

	function oncreate$o() {
	  this.store.entangle(this);

	  this.listener = this.store.on('state', ({ current, changed, previous }) => {
	  });
	}
	function ondestroy$4() {
	  this.listener.cancel();
	}
	const file$r = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/clock/src/Clock.html";

	function create_main_fragment$u(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.loaded) && create_if_block$r(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$r(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if loaded}
	function create_if_block$r(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$connected) && create_if_block_1$m(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$connected) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$m(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (3:2) {#if $connected}
	function create_if_block_1$m(component, ctx) {
		var div1, div0, text, current;

		var clock = new AnalogClock({
			root: component.root,
			store: component.store
		});

		function click_handler(event) {
			component.toggleClock();
		}

		var playinfo = new PlayInfo({
			root: component.root,
			store: component.store
		});

		playinfo.on("select", function(event) {
			component.select(event.view);
		});

		return {
			c: function create() {
				div1 = createElement("div");
				div0 = createElement("div");
				clock._fragment.c();
				text = createText("\n\n    ");
				playinfo._fragment.c();
				div0.id = "clock_inner";
				addLoc(div0, file$r, 5, 6, 171);
				addListener(div1, "click", click_handler);
				div1.id = "analog_clock";
				div1.className = "svelte-bgs5sd";
				toggleClass(div1, "hidden", ctx.viewDef && (ctx.viewDef.show == 'none' || ctx.viewDef.show == 'blank'));
				addLoc(div1, file$r, 4, 4, 38);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				clock._mount(div0, null);
				insert(target, text, anchor);
				playinfo._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.viewDef) {
					toggleClass(div1, "hidden", ctx.viewDef && (ctx.viewDef.show == 'none' || ctx.viewDef.show == 'blank'));
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 2);

				if (clock) clock._fragment.o(outrocallback);
				if (playinfo) playinfo._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				clock.destroy();
				removeListener(div1, "click", click_handler);
				if (detach) {
					detachNode(text);
				}

				playinfo.destroy(detach);
			}
		};
	}

	function Clock_1(options) {
		this._debugName = '<Clock_1>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Clock_1> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected"]), options.data);
		this.store._add(this, ["connected"]);
		if (!('loaded' in this._state)) console.warn("<Clock_1> was created without expected data property 'loaded'");
		if (!('$connected' in this._state)) console.warn("<Clock_1> was created without expected data property '$connected'");
		if (!('viewDef' in this._state)) console.warn("<Clock_1> was created without expected data property 'viewDef'");
		this._intro = !!options.intro;

		this._handlers.destroy = [ondestroy$4, removeFromStore];

		this._fragment = create_main_fragment$u(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$o.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Clock_1.prototype, protoDev);
	assign(Clock_1.prototype, methods$h);

	Clock_1.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/apps/src/AppList.html generated by Svelte v2.16.1 */

	function oncreate$p() {
	  //console.log($thisDeviceState.appList);
	}
	const file$s = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/apps/src/AppList.html";

	function get_each_context$7(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.appName = list[i].appName;
		child_ctx.isUserApp = list[i].isUserApp;
		child_ctx.isDeviceApp = list[i].isDeviceApp;
		child_ctx.overridesSystemApp = list[i].overridesSystemApp;
		child_ctx.overridesUserApp = list[i].overridesUserApp;
		return child_ctx;
	}

	function create_main_fragment$v(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$connected) && create_if_block$s(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$connected) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$s(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $connected}
	function create_if_block$s(component, ctx) {
		var div;

		var if_block = (ctx.$thisDeviceState && ctx.$thisDeviceState.appList) && create_if_block_1$n(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.id = "app_list";
				div.className = "svelte-1grmvl4";
				addLoc(div, file$s, 2, 2, 20);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
			},

			p: function update(changed, ctx) {
				if (ctx.$thisDeviceState && ctx.$thisDeviceState.appList) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$n(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (5:4) {#if $thisDeviceState && $thisDeviceState.appList}
	function create_if_block_1$n(component, ctx) {
		var each_anchor;

		var each_value = ctx.$thisDeviceState.appList;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$7(component, get_each_context$7(ctx, each_value, i));
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insert(target, each_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.$thisDeviceState) {
					each_value = ctx.$thisDeviceState.appList;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$7(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$7(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d: function destroy(detach) {
				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	// (16:12) {:else}
	function create_else_block$6(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("[ dmt system app ]");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (14:31) 
	function create_if_block_5$c(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("[ dmt user app ]");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (12:12) {#if isDeviceApp}
	function create_if_block_4$d(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("[ dmt device app ]");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (20:12) {#if overridesSystemApp}
	function create_if_block_3$f(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("[ ⚠️ overrides system app with the same name ]");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (24:12) {#if overridesUserApp}
	function create_if_block_2$h(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("[ ⚠️ overrides user app with the same name ]");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (6:6) {#each $thisDeviceState.appList as {appName, isUserApp, isDeviceApp, overridesSystemApp, overridesUserApp}
	function create_each_block$7(component, ctx) {
		var a, h3, text0_value = ctx.appName, text0, text1, div, text2, text3, text4, a_href_value;

		function select_block_type(ctx) {
			if (ctx.isDeviceApp) return create_if_block_4$d;
			if (ctx.isUserApp) return create_if_block_5$c;
			return create_else_block$6;
		}

		var current_block_type = select_block_type(ctx);
		var if_block0 = current_block_type(component, ctx);

		var if_block1 = (ctx.overridesSystemApp) && create_if_block_3$f();

		var if_block2 = (ctx.overridesUserApp) && create_if_block_2$h();

		return {
			c: function create() {
				a = createElement("a");
				h3 = createElement("h3");
				text0 = createText(text0_value);
				text1 = createText("\n\n          ");
				div = createElement("div");
				if_block0.c();
				text2 = createText("\n\n            ");
				if (if_block1) if_block1.c();
				text3 = createText("\n\n            ");
				if (if_block2) if_block2.c();
				text4 = createText("\n\n        ");
				h3.className = "svelte-1grmvl4";
				addLoc(h3, file$s, 8, 10, 371);
				div.className = "notice svelte-1grmvl4";
				addLoc(div, file$s, 10, 10, 401);
				a.href = a_href_value = "/" + ctx.appName;
				a.className = "svelte-1grmvl4";
				toggleClass(a, "user_app", ctx.isUserApp);
				toggleClass(a, "overrides_system_app", ctx.overridesSystemApp);
				toggleClass(a, "overrides_user_app", ctx.overridesUserApp);
				addLoc(a, file$s, 6, 8, 219);
			},

			m: function mount(target, anchor) {
				insert(target, a, anchor);
				append(a, h3);
				append(h3, text0);
				append(a, text1);
				append(a, div);
				if_block0.m(div, null);
				append(div, text2);
				if (if_block1) if_block1.m(div, null);
				append(div, text3);
				if (if_block2) if_block2.m(div, null);
				append(a, text4);
			},

			p: function update(changed, ctx) {
				if ((changed.$thisDeviceState) && text0_value !== (text0_value = ctx.appName)) {
					setData(text0, text0_value);
				}

				if (current_block_type !== (current_block_type = select_block_type(ctx))) {
					if_block0.d(1);
					if_block0 = current_block_type(component, ctx);
					if_block0.c();
					if_block0.m(div, text2);
				}

				if (ctx.overridesSystemApp) {
					if (!if_block1) {
						if_block1 = create_if_block_3$f();
						if_block1.c();
						if_block1.m(div, text3);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (ctx.overridesUserApp) {
					if (!if_block2) {
						if_block2 = create_if_block_2$h();
						if_block2.c();
						if_block2.m(div, null);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}

				if ((changed.$thisDeviceState) && a_href_value !== (a_href_value = "/" + ctx.appName)) {
					a.href = a_href_value;
				}

				if (changed.$thisDeviceState) {
					toggleClass(a, "user_app", ctx.isUserApp);
					toggleClass(a, "overrides_system_app", ctx.overridesSystemApp);
					toggleClass(a, "overrides_user_app", ctx.overridesUserApp);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(a);
				}

				if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
			}
		};
	}

	function AppList(options) {
		this._debugName = '<AppList>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<AppList> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","thisDeviceState"]), options.data);
		this.store._add(this, ["connected","thisDeviceState"]);
		if (!('$connected' in this._state)) console.warn("<AppList> was created without expected data property '$connected'");
		if (!('$thisDeviceState' in this._state)) console.warn("<AppList> was created without expected data property '$thisDeviceState'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$v(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$p.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(AppList.prototype, protoDev);

	AppList.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/ambience/src/Ambience.html generated by Svelte v2.16.1 */



	function oncreate$q() {
	  this.store.entangle(this);
	}
	const file$t = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/ambience/src/Ambience.html";

	function create_main_fragment$w(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$connected) && create_if_block$t(component);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$connected) {
					if (!if_block) {
						if_block = create_if_block$t(component);
						if_block.c();
					}
					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if $connected}
	function create_if_block$t(component, ctx) {
		var div, current;

		var iotactions = new IotActions({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				div = createElement("div");
				iotactions._fragment.c();
				div.id = "iot_actions";
				div.className = "svelte-1v4q3y7";
				addLoc(div, file$t, 2, 2, 20);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				iotactions._mount(div, null);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (iotactions) iotactions._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				iotactions.destroy();
			}
		};
	}

	function Ambience(options) {
		this._debugName = '<Ambience>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Ambience> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected"]), options.data);
		this.store._add(this, ["connected"]);
		if (!('$connected' in this._state)) console.warn("<Ambience> was created without expected data property '$connected'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$w(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$q.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Ambience.prototype, protoDev);

	Ambience.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/help/src/Help.html generated by Svelte v2.16.1 */

	var methods$i = {
	  doc(doc) {
	    this.set({ doc });
	  }
	};

	function oncreate$r() {
	  this.store.entangle(this);

	  this.set({ doc: 'a' });
	}
	const file$u = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/help/src/Help.html";

	function create_main_fragment$x(component, ctx) {
		var div, current;

		var if_block = (ctx.doc == 'a') && create_if_block$u();

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.id = "help";
				div.className = "svelte-13jignu";
				addLoc(div, file$u, 3, 0, 176);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.doc == 'a') {
					if (!if_block) {
						if_block = create_if_block$u();
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (14:2) {#if doc == 'a'}
	function create_if_block$u(component, ctx) {
		var p, text0, b, text2;

		return {
			c: function create() {
				p = createElement("p");
				text0 = createText("Please visit ");
				b = createElement("b");
				b.textContent = "uniqpath.com";
				text2 = createText(" to learn more.");
				addLoc(b, file$u, 15, 19, 577);
				p.className = "svelte-13jignu";
				addLoc(p, file$u, 14, 4, 554);
			},

			m: function mount(target, anchor) {
				insert(target, p, anchor);
				append(p, text0);
				append(p, b);
				append(p, text2);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(p);
				}
			}
		};
	}

	function Help(options) {
		this._debugName = '<Help>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({}, options.data);
		if (!('doc' in this._state)) console.warn("<Help> was created without expected data property 'doc'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$x(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$r.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Help.prototype, protoDev);
	assign(Help.prototype, methods$i);

	Help.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/device/src/NearbySensors.html generated by Svelte v2.16.1 */

	function sensorIds({ sensors }) {
	  return Object.keys(sensors).sort()
	  // console.log(sensors);
	  // // if(deviceState) {
	  //   return Object.keys(deviceState.nearbySensors).length
	  // }
	}

	function computedSensorsByType({ sensors, now }) {

	  const types = util.unique(Object.values(sensors).map(sensorInfo => sensorInfo.type)).sort();

	  const computedSensors = {};

	  for(const type of types) {
	    computedSensors[type] = [];
	  }

	  for(const sensorId of Object.keys(sensors).sort()) {

	    const sensorInfo = sensors[sensorId];

	    const relTime = util.humanTime(util.msIntoTimeSpan(now - sensorInfo.lastUpdateAt));

	    const computedInfo = {
	      id: sensorId,
	      error: sensorInfo.error,
	      updateRelativeTime: relTime
	    };

	    computedSensors[sensorInfo.type].push(computedInfo);
	  }

	  return computedSensors;
	  // console.log(sensors);
	  // // if(deviceState) {
	  //   return Object.keys(deviceState.nearbySensors).length
	  // }
	}

	function colorJSON$1(text) {
	  return util.colorJSON(text)
	}
	function oncreate$s() {
	  //this.store.entangle(this);

	  const tick = () => {
	    const now = Date.now();
	    this.set({ now });
	    this.timeout = setTimeout(tick, 1000);
	  };

	  tick();
	}
	function ondestroy$5() {
	  clearTimeout(this.timeout);
	}
	const file$v = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/device/src/NearbySensors.html";

	function get_each_context_1$3(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.sensor = list[i];
		return child_ctx;
	}

	function get_each_context$8(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.sensorType = list[i];
		return child_ctx;
	}

	function create_main_fragment$y(component, ctx) {
		var div0, pre, raw_value = colorJSON$1(ctx.sensors), text0, div1, p, text1, text2_value = ctx.Object.keys(ctx.sensors).length, text2, text3, current;

		var each_value = ctx.Object.keys(ctx.computedSensorsByType);

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$8(component, get_each_context$8(ctx, each_value, i));
		}

		return {
			c: function create() {
				div0 = createElement("div");
				pre = createElement("pre");
				text0 = createText("\n\n");
				div1 = createElement("div");
				p = createElement("p");
				text1 = createText("Sensors on local network: ");
				text2 = createText(text2_value);
				text3 = createText("\n\n  ");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				pre.className = "svelte-73m1e0";
				addLoc(pre, file$v, 1, 2, 31);
				div0.id = "sensors_json_view";
				div0.className = "svelte-73m1e0";
				addLoc(div0, file$v, 0, 0, 0);
				addLoc(p, file$v, 5, 2, 98);
				div1.id = "sensors";
				div1.className = "svelte-73m1e0";
				addLoc(div1, file$v, 4, 0, 77);
			},

			m: function mount(target, anchor) {
				insert(target, div0, anchor);
				append(div0, pre);
				pre.innerHTML = raw_value;
				insert(target, text0, anchor);
				insert(target, div1, anchor);
				append(div1, p);
				append(p, text1);
				append(p, text2);
				append(div1, text3);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div1, null);
				}

				current = true;
			},

			p: function update(changed, ctx) {
				if ((changed.sensors) && raw_value !== (raw_value = colorJSON$1(ctx.sensors))) {
					pre.innerHTML = raw_value;
				}

				if ((changed.Object || changed.sensors) && text2_value !== (text2_value = ctx.Object.keys(ctx.sensors).length)) {
					setData(text2, text2_value);
				}

				if (changed.computedSensorsByType || changed.Object) {
					each_value = ctx.Object.keys(ctx.computedSensorsByType);

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$8(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$8(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div1, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div0);
					detachNode(text0);
					detachNode(div1);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (17:8) {#if sensor.error}
	function create_if_block_1$o(component, ctx) {
		var span;

		return {
			c: function create() {
				span = createElement("span");
				span.textContent = "Sensor reading error...";
				span.className = "error svelte-73m1e0";
				addLoc(span, file$v, 17, 10, 411);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (26:10) {:else}
	function create_else_block$7(component, ctx) {
		var span;

		return {
			c: function create() {
				span = createElement("span");
				span.textContent = "now";
				span.className = "svelte-73m1e0";
				addLoc(span, file$v, 26, 12, 629);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
			},

			p: noop,

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (24:10) {#if sensor.updateRelativeTime}
	function create_if_block$v(component, ctx) {
		var text0_value = ctx.sensor.updateRelativeTime, text0, text1;

		return {
			c: function create() {
				text0 = createText(text0_value);
				text1 = createText(" ago");
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, text1, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.computedSensorsByType || changed.Object) && text0_value !== (text0_value = ctx.sensor.updateRelativeTime)) {
					setData(text0, text0_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(text1);
				}
			}
		};
	}

	// (13:4) {#each computedSensorsByType[sensorType] as sensor}
	function create_each_block_1$3(component, ctx) {
		var div, h3, text0_value = ctx.sensor.id, text0, text1, text2, p, text3, text4;

		var if_block0 = (ctx.sensor.error) && create_if_block_1$o();

		function select_block_type(ctx) {
			if (ctx.sensor.updateRelativeTime) return create_if_block$v;
			return create_else_block$7;
		}

		var current_block_type = select_block_type(ctx);
		var if_block1 = current_block_type(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				h3 = createElement("h3");
				text0 = createText(text0_value);
				text1 = createText("\n\n        ");
				if (if_block0) if_block0.c();
				text2 = createText("\n\n        ");
				p = createElement("p");
				text3 = createText("LAST UPDATE:\n\n          ");
				if_block1.c();
				text4 = createText("\n      ");
				h3.className = "svelte-73m1e0";
				addLoc(h3, file$v, 14, 8, 352);
				addLoc(p, file$v, 20, 8, 485);
				div.className = "sensor_info svelte-73m1e0";
				addLoc(div, file$v, 13, 6, 318);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h3);
				append(h3, text0);
				append(div, text1);
				if (if_block0) if_block0.m(div, null);
				append(div, text2);
				append(div, p);
				append(p, text3);
				if_block1.m(p, null);
				append(div, text4);
			},

			p: function update(changed, ctx) {
				if ((changed.computedSensorsByType || changed.Object) && text0_value !== (text0_value = ctx.sensor.id)) {
					setData(text0, text0_value);
				}

				if (ctx.sensor.error) {
					if (!if_block0) {
						if_block0 = create_if_block_1$o();
						if_block0.c();
						if_block0.m(div, text2);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
					if_block1.p(changed, ctx);
				} else {
					if_block1.d(1);
					if_block1 = current_block_type(component, ctx);
					if_block1.c();
					if_block1.m(p, null);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if_block1.d();
			}
		};
	}

	// (10:2) {#each Object.keys(computedSensorsByType) as sensorType}
	function create_each_block$8(component, ctx) {
		var h2, text0_value = ctx.sensorType, text0, text1, each_anchor;

		var each_value_1 = ctx.computedSensorsByType[ctx.sensorType];

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$3(component, get_each_context_1$3(ctx, each_value_1, i));
		}

		return {
			c: function create() {
				h2 = createElement("h2");
				text0 = createText(text0_value);
				text1 = createText("\n\n    ");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
				h2.className = "svelte-73m1e0";
				addLoc(h2, file$v, 10, 4, 233);
			},

			m: function mount(target, anchor) {
				insert(target, h2, anchor);
				append(h2, text0);
				insert(target, text1, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insert(target, each_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.Object || changed.computedSensorsByType) && text0_value !== (text0_value = ctx.sensorType)) {
					setData(text0, text0_value);
				}

				if (changed.computedSensorsByType || changed.Object) {
					each_value_1 = ctx.computedSensorsByType[ctx.sensorType];

					for (var i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1$3(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_1.length;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(h2);
					detachNode(text1);
				}

				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	function NearbySensors(options) {
		this._debugName = '<NearbySensors>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({ Object : Object }, options.data);

		this._recompute({ sensors: 1, now: 1 }, this._state);
		if (!('sensors' in this._state)) console.warn("<NearbySensors> was created without expected data property 'sensors'");
		if (!('now' in this._state)) console.warn("<NearbySensors> was created without expected data property 'now'");
		this._intro = !!options.intro;

		this._handlers.destroy = [ondestroy$5];

		this._fragment = create_main_fragment$y(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$s.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(NearbySensors.prototype, protoDev);

	NearbySensors.prototype._checkReadOnly = function _checkReadOnly(newState) {
		if ('sensorIds' in newState && !this._updatingReadonlyProperty) throw new Error("<NearbySensors>: Cannot set read-only property 'sensorIds'");
		if ('computedSensorsByType' in newState && !this._updatingReadonlyProperty) throw new Error("<NearbySensors>: Cannot set read-only property 'computedSensorsByType'");
	};

	NearbySensors.prototype._recompute = function _recompute(changed, state) {
		if (changed.sensors) {
			if (this._differs(state.sensorIds, (state.sensorIds = sensorIds(state)))) changed.sensorIds = true;
		}

		if (changed.sensors || changed.now) {
			if (this._differs(state.computedSensorsByType, (state.computedSensorsByType = computedSensorsByType(state)))) changed.computedSensorsByType = true;
		}
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/device/src/WifiSetup.html generated by Svelte v2.16.1 */

	var methods$j = {
	  inputChanged() {
	    console.log("Typed ...");
	  },
	  action(action) {
	    this.set({ touchInfo: action });
	    setTimeout(() => this.set({ touchInfo: undefined }), 50);

	    // local view actions
	    if(action == 'show_danger_zone') {
	      const msg = "Please select carefully ...";
	      this.set({ dangerZoneButtonVisible: false, msg });
	      setTimeout(() => {
	        this.set({ dangerZoneVisible: true });
	        setTimeout(() => this.set({ dangerZoneVisible: false, dangerZoneButtonVisible: true, msg: undefined }), 7000);
	      }, 500);

	      return
	    }

	    const msg = action == 'shutdown' ? "Shutting down ..." : "Device rebooting, please wait ...";
	    this.set({ dangerZoneVisible: false, dangerZoneButtonVisible: false, msg });
	    // the other timeout will still show the button after 7s but it's ok... reboot should already have heppened (almost)
	    // even if we see the buttons, it's ok.. what if the reboot doesn't actually succeed, it's better to show the default options

	    // otherwise forward to the view store
	    console.log(`sending: ${action}`);
	    this.store.signal('action', { action, scope: 'device' });
	  }
	};

	function oncreate$t() {
	  this.set({ wifiPassword: '' });

	  this.set({ dangerZoneVisible: false, dangerZoneButtonVisible: true, updateButtonVisible: true });
	}
	function ondestroy$6() {
	}
	const file$w = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/device/src/WifiSetup.html";

	function create_main_fragment$z(component, ctx) {
		var div, h3, text1, button, text3, text4, current;

		function click_handler(event) {
			component.action('reboot');
		}

		var if_block0 = (ctx.$device) && create_if_block_1$p(component, ctx);

		var if_block1 = (ctx.msg) && create_if_block$w(component, ctx);

		return {
			c: function create() {
				div = createElement("div");
				h3 = createElement("h3");
				h3.textContent = "Select an option →";
				text1 = createText("\n\n    ");
				button = createElement("button");
				button.textContent = "Reboot";
				text3 = createText("\n    ");
				if (if_block0) if_block0.c();
				text4 = createText("\n\n  \n\n  ");
				if (if_block1) if_block1.c();
				addLoc(h3, file$w, 2, 4, 83);
				addListener(button, "click", click_handler);
				button.className = "more_warning svelte-145tmag";
				addLoc(button, file$w, 4, 4, 116);
				div.id = "wifi_setup";
				div.className = "svelte-145tmag";
				toggleClass(div, "nonRPi", !ctx.atRPi);
				addLoc(div, file$w, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h3);
				append(div, text1);
				append(div, button);
				append(div, text3);
				if (if_block0) if_block0.m(div, null);
				append(div, text4);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$device) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_1$p(component, ctx);
						if_block0.c();
						if_block0.m(div, text4);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (ctx.msg) {
					if (if_block1) {
						if_block1.p(changed, ctx);
					} else {
						if_block1 = create_if_block$w(component, ctx);
						if_block1.c();
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				if (changed.atRPi) {
					toggleClass(div, "nonRPi", !ctx.atRPi);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				removeListener(button, "click", click_handler);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (6:4) {#if $device}
	function create_if_block_1$p(component, ctx) {
		var text, button;

		function select_block_type(ctx) {
			if (ctx.$device.apMode) return create_if_block_2$i;
			return create_else_block$8;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(component, ctx);

		function click_handler(event) {
			component.action('shutdown');
		}

		return {
			c: function create() {
				if_block.c();
				text = createText("\n\n      ");
				button = createElement("button");
				button.textContent = "Shutdown";
				addListener(button, "click", click_handler);
				button.className = "warning svelte-145tmag";
				toggleClass(button, "touch_pressed", ctx.touchInfo == 'shutdown');
				addLoc(button, file$w, 12, 6, 559);
			},

			m: function mount(target, anchor) {
				if_block.m(target, anchor);
				insert(target, text, anchor);
				insert(target, button, anchor);
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(text.parentNode, text);
				}

				if (changed.touchInfo) {
					toggleClass(button, "touch_pressed", ctx.touchInfo == 'shutdown');
				}
			},

			d: function destroy(detach) {
				if_block.d(detach);
				if (detach) {
					detachNode(text);
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (9:6) {:else}
	function create_else_block$8(component, ctx) {
		var button;

		function click_handler(event) {
			component.action('enableAP');
		}

		return {
			c: function create() {
				button = createElement("button");
				button.textContent = "Set AP Mode & Reboot";
				addListener(button, "click", click_handler);
				button.className = "warning svelte-145tmag";
				toggleClass(button, "touch_pressed", ctx.touchInfo == 'ap_mode_enable');
				addLoc(button, file$w, 9, 8, 404);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.touchInfo) {
					toggleClass(button, "touch_pressed", ctx.touchInfo == 'ap_mode_enable');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (7:6) {#if $device.apMode}
	function create_if_block_2$i(component, ctx) {
		var button;

		function click_handler(event) {
			component.action('disableAP');
		}

		return {
			c: function create() {
				button = createElement("button");
				button.textContent = "Set Wifi Mode & Reboot";
				addListener(button, "click", click_handler);
				button.className = "warning svelte-145tmag";
				toggleClass(button, "touch_pressed", ctx.touchInfo == 'ap_mode_disable');
				addLoc(button, file$w, 7, 8, 242);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.touchInfo) {
					toggleClass(button, "touch_pressed", ctx.touchInfo == 'ap_mode_disable');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (21:2) {#if msg}
	function create_if_block$w(component, ctx) {
		var h3, text;

		return {
			c: function create() {
				h3 = createElement("h3");
				text = createText(ctx.msg);
				addLoc(h3, file$w, 21, 4, 914);
			},

			m: function mount(target, anchor) {
				insert(target, h3, anchor);
				append(h3, text);
			},

			p: function update(changed, ctx) {
				if (changed.msg) {
					setData(text, ctx.msg);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(h3);
				}
			}
		};
	}

	function WifiSetup(options) {
		this._debugName = '<WifiSetup>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<WifiSetup> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["device"]), options.data);
		this.store._add(this, ["device"]);
		if (!('atRPi' in this._state)) console.warn("<WifiSetup> was created without expected data property 'atRPi'");
		if (!('$device' in this._state)) console.warn("<WifiSetup> was created without expected data property '$device'");
		if (!('touchInfo' in this._state)) console.warn("<WifiSetup> was created without expected data property 'touchInfo'");
		if (!('msg' in this._state)) console.warn("<WifiSetup> was created without expected data property 'msg'");
		this._intro = !!options.intro;

		this._handlers.destroy = [ondestroy$6, removeFromStore];

		this._fragment = create_main_fragment$z(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$t.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(WifiSetup.prototype, protoDev);
	assign(WifiSetup.prototype, methods$j);

	WifiSetup.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/device/src/Device.html generated by Svelte v2.16.1 */



	function parseAnsi$1(text) {
	  return ansicolor.parse(text);
	}
	function colorJSON$2(text) {
	  return util.colorJSON(text)
	}
	var methods$k = {
	  showFrontendLog() {
	    this.store.signal('action', { action: 'show_frontend_log', scope: 'dmt/gui' });
	  },
	  closeFrontendLog() {
	    this.store.signal('action', { action: 'close_frontend_log', scope: 'dmt/gui' });
	  }
	};

	function oncreate$u() {
	  this.store.entangle(this);

	  this.set({ deviceView: 'device_log' }); // default, duplicate in Device.html
	  this.store.on('select_device_view', ({ view }) => this.set({ deviceView: view }));
	}
	const file$x = "Users/david/Projects/dmt-system/packages/dmt-legacy-gui/frontend/device/src/Device.html";

	function get_each_context_1$4(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.span = list[i];
		return child_ctx;
	}

	function get_each_context$9(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.line = list[i];
		return child_ctx;
	}

	function create_main_fragment$A(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.loaded) && create_if_block$x(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.loaded) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$x(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if loaded}
	function create_if_block$x(component, ctx) {
		var div, text, current;

		var if_block0 = (ctx.$connected) && create_if_block_2$j(component, ctx);

		var if_block1 = (ctx.deviceView == 'wifi_setup') && create_if_block_1$q(component);

		return {
			c: function create() {
				div = createElement("div");
				if (if_block0) if_block0.c();
				text = createText("\n\n  \n\n  ");
				if (if_block1) if_block1.c();
				div.id = "device";
				div.className = "svelte-if31ux";
				addLoc(div, file$x, 2, 2, 16);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append(div, text);
				if (if_block1) if_block1.m(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$connected) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_2$j(component, ctx);
						if (if_block0) if_block0.c();
					}

					if_block0.i(div, text);
				} else if (if_block0) {
					if_block0.o(function() {
						if_block0.d(1);
						if_block0 = null;
					});
				}

				if (ctx.deviceView == 'wifi_setup') {
					if (!if_block1) {
						if_block1 = create_if_block_1$q(component);
						if_block1.c();
					}
					if_block1.i(div, null);
				} else if (if_block1) {
					if_block1.o(function() {
						if_block1.d(1);
						if_block1 = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 2);

				if (if_block0) if_block0.o(outrocallback);
				else outrocallback();

				if (if_block1) if_block1.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
			}
		};
	}

	// (5:2) {#if $connected}
	function create_if_block_2$j(component, ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block_3$g,
			create_if_block_5$d,
			create_if_block_6$9,
			create_if_block_8$7,
			create_if_block_10$5,
			create_if_block_12$4,
			create_if_block_14$2
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.deviceView == 'device_log') return 0;
			if (ctx.deviceView == 'network_log') return 1;
			if (ctx.deviceView == 'frontend_log' && ctx.$device) return 2;
			if (ctx.deviceView == 'device_state') return 3;
			if (ctx.deviceView == 'time_state') return 4;
			if (ctx.deviceView == 'player_state') return 5;
			if (ctx.deviceView == 'nearby_sensors_state') return 6;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
		}

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if (if_block) {
						if_block.o(function() {
							if_blocks[previous_block_index].d(1);
							if_blocks[previous_block_index] = null;
						});
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];
						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
							if_block.c();
						}
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (~current_block_type_index) if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (78:50) 
	function create_if_block_14$2(component, ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block_15$2,
			create_else_block_5$1
		];

		var if_blocks = [];

		function select_block_type_5(ctx) {
			if (ctx.$nearbySensors) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_5(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		return {
			c: function create() {
				if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_5(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block.c();
					}
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if_blocks[current_block_type_index].d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (66:42) 
	function create_if_block_12$4(component, ctx) {
		var pre, current;

		function select_block_type_4(ctx) {
			if (ctx.$player) return create_if_block_13$2;
			return create_else_block_4$1;
		}

		var current_block_type = select_block_type_4(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				pre = createElement("pre");
				if_block.c();
				pre.className = "svelte-if31ux";
				addLoc(pre, file$x, 69, 6, 1737);
			},

			m: function mount(target, anchor) {
				insert(target, pre, anchor);
				if_block.m(pre, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(pre, null);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(pre);
				}

				if_block.d();
			}
		};
	}

	// (54:40) 
	function create_if_block_10$5(component, ctx) {
		var pre, current;

		function select_block_type_3(ctx) {
			if (ctx.$time) return create_if_block_11$4;
			return create_else_block_3$1;
		}

		var current_block_type = select_block_type_3(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				pre = createElement("pre");
				if_block.c();
				pre.className = "svelte-if31ux";
				addLoc(pre, file$x, 57, 6, 1514);
			},

			m: function mount(target, anchor) {
				insert(target, pre, anchor);
				if_block.m(pre, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(pre, null);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(pre);
				}

				if_block.d();
			}
		};
	}

	// (42:42) 
	function create_if_block_8$7(component, ctx) {
		var pre, current;

		function select_block_type_2(ctx) {
			if (ctx.$device) return create_if_block_9$6;
			return create_else_block_2$2;
		}

		var current_block_type = select_block_type_2(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				pre = createElement("pre");
				if_block.c();
				pre.className = "svelte-if31ux";
				addLoc(pre, file$x, 45, 6, 1285);
			},

			m: function mount(target, anchor) {
				insert(target, pre, anchor);
				if_block.m(pre, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(pre, null);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(pre);
				}

				if_block.d();
			}
		};
	}

	// (26:53) 
	function create_if_block_6$9(component, ctx) {
		var pre0, h2, text0_value = ctx.$device.deviceName, text0, text1, text2, pre1, current;

		function select_block_type_1(ctx) {
			if (ctx.$device.showFrontendLog) return create_if_block_7$9;
			return create_else_block_1$3;
		}

		var current_block_type = select_block_type_1(ctx);
		var if_block = current_block_type(component, ctx);

		return {
			c: function create() {
				pre0 = createElement("pre");
				h2 = createElement("h2");
				text0 = createText(text0_value);
				text1 = createText("\n\n      ");
				if_block.c();
				text2 = createText("\n\n      ");
				pre1 = createElement("pre");
				pre1.textContent = "To close the frontend log you can also tap or click on the overlay on the device itself.";
				addLoc(h2, file$x, 28, 8, 601);
				pre0.className = "svelte-if31ux";
				addLoc(pre0, file$x, 27, 6, 587);
				pre1.className = "svelte-if31ux";
				addLoc(pre1, file$x, 37, 6, 1084);
			},

			m: function mount(target, anchor) {
				insert(target, pre0, anchor);
				append(pre0, h2);
				append(h2, text0);
				insert(target, text1, anchor);
				if_block.m(target, anchor);
				insert(target, text2, anchor);
				insert(target, pre1, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((changed.$device) && text0_value !== (text0_value = ctx.$device.deviceName)) {
					setData(text0, text0_value);
				}

				if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(component, ctx);
					if_block.c();
					if_block.m(text2.parentNode, text2);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(pre0);
					detachNode(text1);
				}

				if_block.d(detach);
				if (detach) {
					detachNode(text2);
					detachNode(pre1);
				}
			}
		};
	}

	// (20:42) 
	function create_if_block_5$d(component, ctx) {
		var pre, current;

		return {
			c: function create() {
				pre = createElement("pre");
				pre.textContent = "This information is missing";
				pre.className = "svelte-if31ux";
				addLoc(pre, file$x, 21, 6, 470);
			},

			m: function mount(target, anchor) {
				insert(target, pre, anchor);
				current = true;
			},

			p: noop,

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(pre);
				}
			}
		};
	}

	// (7:4) {#if deviceView == 'device_log' }
	function create_if_block_3$g(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$log) && create_if_block_4$e(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$log) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_4$e(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (84:6) {:else}
	function create_else_block_5$1(component, ctx) {
		var pre, current;

		return {
			c: function create() {
				pre = createElement("pre");
				pre.textContent = "This information is missing";
				pre.className = "svelte-if31ux";
				addLoc(pre, file$x, 84, 8, 2076);
			},

			m: function mount(target, anchor) {
				insert(target, pre, anchor);
				current = true;
			},

			p: noop,

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(pre);
				}
			}
		};
	}

	// (82:6) {#if $nearbySensors}
	function create_if_block_15$2(component, ctx) {
		var current;

		var nearbysensors_initial_data = { sensors: ctx.$nearbySensors };
		var nearbysensors = new NearbySensors({
			root: component.root,
			store: component.store,
			data: nearbysensors_initial_data
		});

		return {
			c: function create() {
				nearbysensors._fragment.c();
			},

			m: function mount(target, anchor) {
				nearbysensors._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var nearbysensors_changes = {};
				if (changed.$nearbySensors) nearbysensors_changes.sensors = ctx.$nearbySensors;
				nearbysensors._set(nearbysensors_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (nearbysensors) nearbysensors._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				nearbysensors.destroy(detach);
			}
		};
	}

	// (73:8) {:else}
	function create_else_block_4$1(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("This information is missing");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: noop,

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (71:8) {#if $player}
	function create_if_block_13$2(component, ctx) {
		var raw_value = colorJSON$2(ctx.$player), raw_before, raw_after;

		return {
			c: function create() {
				raw_before = createElement('noscript');
				raw_after = createElement('noscript');
			},

			m: function mount(target, anchor) {
				insert(target, raw_before, anchor);
				raw_before.insertAdjacentHTML("afterend", raw_value);
				insert(target, raw_after, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$player) && raw_value !== (raw_value = colorJSON$2(ctx.$player))) {
					detachBetween(raw_before, raw_after);
					raw_before.insertAdjacentHTML("afterend", raw_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachBetween(raw_before, raw_after);
					detachNode(raw_before);
					detachNode(raw_after);
				}
			}
		};
	}

	// (61:8) {:else}
	function create_else_block_3$1(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("This information is missing");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: noop,

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (59:8) {#if $time}
	function create_if_block_11$4(component, ctx) {
		var raw_value = colorJSON$2(ctx.$time), raw_before, raw_after;

		return {
			c: function create() {
				raw_before = createElement('noscript');
				raw_after = createElement('noscript');
			},

			m: function mount(target, anchor) {
				insert(target, raw_before, anchor);
				raw_before.insertAdjacentHTML("afterend", raw_value);
				insert(target, raw_after, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$time) && raw_value !== (raw_value = colorJSON$2(ctx.$time))) {
					detachBetween(raw_before, raw_after);
					raw_before.insertAdjacentHTML("afterend", raw_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachBetween(raw_before, raw_after);
					detachNode(raw_before);
					detachNode(raw_after);
				}
			}
		};
	}

	// (49:8) {:else}
	function create_else_block_2$2(component, ctx) {
		var text;

		return {
			c: function create() {
				text = createText("This information is missing");
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: noop,

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (47:8) {#if $device}
	function create_if_block_9$6(component, ctx) {
		var raw_value = colorJSON$2(ctx.$device), raw_before, raw_after;

		return {
			c: function create() {
				raw_before = createElement('noscript');
				raw_after = createElement('noscript');
			},

			m: function mount(target, anchor) {
				insert(target, raw_before, anchor);
				raw_before.insertAdjacentHTML("afterend", raw_value);
				insert(target, raw_after, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.$device) && raw_value !== (raw_value = colorJSON$2(ctx.$device))) {
					detachBetween(raw_before, raw_after);
					raw_before.insertAdjacentHTML("afterend", raw_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachBetween(raw_before, raw_after);
					detachNode(raw_before);
					detachNode(raw_after);
				}
			}
		};
	}

	// (34:6) {:else}
	function create_else_block_1$3(component, ctx) {
		var button;

		function click_handler(event) {
			component.showFrontendLog();
		}

		return {
			c: function create() {
				button = createElement("button");
				button.textContent = "Show frontend log";
				addListener(button, "click", click_handler);
				button.className = "svelte-if31ux";
				toggleClass(button, "active", ctx.deviceView == 'frontend_log_show');
				toggleClass(button, "touch_pressed", ctx.touchInfo == 'frontend_log_show');
				addLoc(button, file$x, 34, 8, 897);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.deviceView) {
					toggleClass(button, "active", ctx.deviceView == 'frontend_log_show');
				}

				if (changed.touchInfo) {
					toggleClass(button, "touch_pressed", ctx.touchInfo == 'frontend_log_show');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (32:6) {#if $device.showFrontendLog}
	function create_if_block_7$9(component, ctx) {
		var button;

		function click_handler(event) {
			component.closeFrontendLog();
		}

		return {
			c: function create() {
				button = createElement("button");
				button.textContent = "Close frontend log";
				addListener(button, "click", click_handler);
				button.className = "close svelte-if31ux";
				toggleClass(button, "active", ctx.deviceView == 'frontend_log_close');
				toggleClass(button, "touch_pressed", ctx.touchInfo == 'frontend_log_close');
				addLoc(button, file$x, 32, 8, 689);
			},

			m: function mount(target, anchor) {
				insert(target, button, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.deviceView) {
					toggleClass(button, "active", ctx.deviceView == 'frontend_log_close');
				}

				if (changed.touchInfo) {
					toggleClass(button, "touch_pressed", ctx.touchInfo == 'frontend_log_close');
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(button);
				}

				removeListener(button, "click", click_handler);
			}
		};
	}

	// (8:6) {#if $log}
	function create_if_block_4$e(component, ctx) {
		var pre, ul;

		var each_value = ctx.$log;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$9(component, get_each_context$9(ctx, each_value, i));
		}

		var each_else = null;

		if (!each_value.length) {
			each_else = create_else_block$9();
			each_else.c();
		}

		return {
			c: function create() {
				pre = createElement("pre");
				ul = createElement("ul");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				ul.className = "svelte-if31ux";
				addLoc(ul, file$x, 9, 10, 134);
				pre.className = "svelte-if31ux";
				addLoc(pre, file$x, 8, 8, 118);
			},

			m: function mount(target, anchor) {
				insert(target, pre, anchor);
				append(pre, ul);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(ul, null);
				}

				if (each_else) {
					each_else.m(ul, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.$log) {
					each_value = ctx.$log;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$9(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$9(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (each_value.length) {
					if (each_else) {
						each_else.d(1);
						each_else = null;
					}
				} else if (!each_else) {
					each_else = create_else_block$9();
					each_else.c();
					each_else.m(ul, null);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(pre);
				}

				destroyEach(each_blocks, detach);

				if (each_else) each_else.d();
			}
		};
	}

	// (13:12) {:else}
	function create_else_block$9(component, ctx) {
		var li;

		return {
			c: function create() {
				li = createElement("li");
				li.textContent = "Log is empty";
				addLoc(li, file$x, 13, 14, 334);
			},

			m: function mount(target, anchor) {
				insert(target, li, anchor);
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(li);
				}
			}
		};
	}

	// (12:31) {#each parseAnsi(line.msg).spans as span}
	function create_each_block_1$4(component, ctx) {
		var span, text_value = ctx.span.text, text, span_style_value;

		return {
			c: function create() {
				span = createElement("span");
				text = createText(text_value);
				span.style.cssText = span_style_value = ctx.span.css;
				addLoc(span, file$x, 11, 72, 244);
			},

			m: function mount(target, anchor) {
				insert(target, span, anchor);
				append(span, text);
			},

			p: function update(changed, ctx) {
				if ((changed.$log) && text_value !== (text_value = ctx.span.text)) {
					setData(text, text_value);
				}

				if ((changed.$log) && span_style_value !== (span_style_value = ctx.span.css)) {
					span.style.cssText = span_style_value;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(span);
				}
			}
		};
	}

	// (11:12) {#each $log as line}
	function create_each_block$9(component, ctx) {
		var li;

		var each_value_1 = parseAnsi$1(ctx.line.msg).spans;

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$4(component, get_each_context_1$4(ctx, each_value_1, i));
		}

		return {
			c: function create() {
				li = createElement("li");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				li.className = "line";
				addLoc(li, file$x, 11, 14, 186);
			},

			m: function mount(target, anchor) {
				insert(target, li, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(li, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.$log) {
					each_value_1 = parseAnsi$1(ctx.line.msg).spans;

					for (var i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1$4(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(li, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value_1.length;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(li);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (97:2) {#if deviceView == 'wifi_setup'}
	function create_if_block_1$q(component, ctx) {
		var current;

		var wifisetup = new WifiSetup({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				wifisetup._fragment.c();
			},

			m: function mount(target, anchor) {
				wifisetup._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (wifisetup) wifisetup._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				wifisetup.destroy(detach);
			}
		};
	}

	function Device(options) {
		this._debugName = '<Device>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<Device> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["connected","log","device","time","player","nearbySensors"]), options.data);
		this.store._add(this, ["connected","log","device","time","player","nearbySensors"]);
		if (!('loaded' in this._state)) console.warn("<Device> was created without expected data property 'loaded'");
		if (!('$connected' in this._state)) console.warn("<Device> was created without expected data property '$connected'");
		if (!('deviceView' in this._state)) console.warn("<Device> was created without expected data property 'deviceView'");
		if (!('$log' in this._state)) console.warn("<Device> was created without expected data property '$log'");
		if (!('$device' in this._state)) console.warn("<Device> was created without expected data property '$device'");
		if (!('touchInfo' in this._state)) console.warn("<Device> was created without expected data property 'touchInfo'");
		if (!('$time' in this._state)) console.warn("<Device> was created without expected data property '$time'");
		if (!('$player' in this._state)) console.warn("<Device> was created without expected data property '$player'");
		if (!('$nearbySensors' in this._state)) console.warn("<Device> was created without expected data property '$nearbySensors'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$A(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$u.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(Device.prototype, protoDev);
	assign(Device.prototype, methods$k);

	Device.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/ImagePreload.html generated by Svelte v2.16.1 */

	function oncreate$v() {}
	const file$y = "src/ImagePreload.html";

	function create_main_fragment$B(component, ctx) {
		var div, text, current;

		return {
			c: function create() {
				div = createElement("div");
				text = createText(ctx.path);
				div.className = "image svelte-xkwd2x";
				setStyle(div, "background-image", "url('" + ctx.path + "')");
				addLoc(div, file$y, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.path) {
					setData(text, ctx.path);
					setStyle(div, "background-image", "url('" + ctx.path + "')");
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function ImagePreload(options) {
		this._debugName = '<ImagePreload>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}

		init(this, options);
		this._state = assign({}, options.data);
		if (!('path' in this._state)) console.warn("<ImagePreload> was created without expected data property 'path'");
		this._intro = !!options.intro;

		this._fragment = create_main_fragment$B(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$v.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(ImagePreload.prototype, protoDev);

	ImagePreload.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/InfoBar.html generated by Svelte v2.16.1 */

	var methods$l = {
	  close() {
	    this.store.signalLocalDevice('action', { action: 'close_frontend_log', scope: 'gui' });
	  }
	};

	function oncreate$w() {
	  this.store.entangle(this);
	}
	const file$z = "src/InfoBar.html";

	function get_each_context$a(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.line = list[i];
		return child_ctx;
	}

	function create_main_fragment$C(component, ctx) {
		var div, h3, text0_value = ctx.$thisDeviceState && ctx.$thisDeviceState.device ? ctx.$thisDeviceState.device.deviceName : "", text0, text1, span, text3, current;

		var if_block = (ctx.frontendLog) && create_if_block$y(component, ctx);

		function click_handler(event) {
			component.close();
		}

		return {
			c: function create() {
				div = createElement("div");
				h3 = createElement("h3");
				text0 = createText(text0_value);
				text1 = createText(" ");
				span = createElement("span");
				span.textContent = "— frontend debug log";
				text3 = createText("\n\n  ");
				if (if_block) if_block.c();
				span.className = "svelte-c2idy2";
				addLoc(span, file$z, 1, 94, 133);
				h3.className = "svelte-c2idy2";
				addLoc(h3, file$z, 1, 2, 41);
				addListener(div, "click", click_handler);
				div.id = "info_bar";
				div.className = "svelte-c2idy2";
				addLoc(div, file$z, 0, 0, 0);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, h3);
				append(h3, text0);
				append(h3, text1);
				append(h3, span);
				append(div, text3);
				if (if_block) if_block.m(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((changed.$thisDeviceState) && text0_value !== (text0_value = ctx.$thisDeviceState && ctx.$thisDeviceState.device ? ctx.$thisDeviceState.device.deviceName : "")) {
					setData(text0, text0_value);
				}

				if (ctx.frontendLog) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block$y(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: run,

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
				removeListener(div, "click", click_handler);
			}
		};
	}

	// (4:2) {#if frontendLog}
	function create_if_block$y(component, ctx) {
		var each_anchor;

		var each_value = ctx.frontendLog;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$a(component, get_each_context$a(ctx, each_value, i));
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				insert(target, each_anchor, anchor);
			},

			p: function update(changed, ctx) {
				if (changed.frontendLog) {
					each_value = ctx.frontendLog;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$a(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$a(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_anchor.parentNode, each_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d: function destroy(detach) {
				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	// (5:4) {#each frontendLog as line}
	function create_each_block$a(component, ctx) {
		var div, text0_value = ctx.line, text0, text1;

		return {
			c: function create() {
				div = createElement("div");
				text0 = createText(text0_value);
				text1 = createText("\n      ");
				div.className = "line";
				addLoc(div, file$z, 5, 6, 231);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				append(div, text0);
				append(div, text1);
			},

			p: function update(changed, ctx) {
				if ((changed.frontendLog) && text0_value !== (text0_value = ctx.line)) {
					setData(text0, text0_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function InfoBar(options) {
		this._debugName = '<InfoBar>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<InfoBar> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["thisDeviceState"]), options.data);
		this.store._add(this, ["thisDeviceState"]);
		if (!('$thisDeviceState' in this._state)) console.warn("<InfoBar> was created without expected data property '$thisDeviceState'");
		if (!('frontendLog' in this._state)) console.warn("<InfoBar> was created without expected data property 'frontendLog'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$C(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$w.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(InfoBar.prototype, protoDev);
	assign(InfoBar.prototype, methods$l);

	InfoBar.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	/* src/App.html generated by Svelte v2.16.1 */



	var methods$m = {
	  saveGetParams() {
	    const urlParams = new URLSearchParams(window.location.search);
	    const getParams = {
	      subview: urlParams.get('subview'),
	      q: urlParams.get('q')
	    };
	    this.store.set({ getParams });
	  },
	  switchView(view) {
	    this.store.switchView(view);
	  },
	  select(view) {
	    this.switchView(view);
	  }
	};

	function oncreate$x() {

	  this.scope = 'home';

	  this.store.entangle(this); // was added later because of ImagePreload ($wallpapers)

	  // https://stackoverflow.com/a/3375140
	  // DISABLE ANNOYING SELECTIONS ON TOUCH SCREENS
	  // todo: see if this css-solution also works: https://stackoverflow.com/a/13068082
	  const checkRPi = () => {
	    if(this.get().loaded) {
	      if(this.get().atRPi) {
	        // window.onload = function() {
	          document.onselectstart = function() {return false;}; // ie
	          document.onmousedown = function() {return false;}; // mozilla
	        // }
	      }
	    } else {
	      setTimeout(checkRPi, 1000);
	    }
	  };

	  setTimeout(checkRPi, 500);

	  ////// ***************
	  //////// optimization option (maybe)... entangle only once at the  ?!
	  ////// ***************

	  document.addEventListener('click', (e) => {
	    // report any user action for purpose of detecting "user idle" -- for example we jump to homescreen
	    // if user is idle for long enough (if we enabled this option in .def file)
	    this.store.guiEngaged();
	  });

	  this.set({ errors: [] });
	  //this.set({ errors: [], showDetails: localStorage.getItem('hidePlayerInfoPanel') != 'true' })

	  window.onerror = (msg, file, line, col, error) => {

	    const { errors } = this.get();

	    const d = new Date();
	    const time = `${d.getHours()}:${('0' + d.getMinutes()).slice(-2)}`;

	    if (error && error.stack) {
	      errors.push({ msg, stacktrace: error.stack, time });

	      setTimeout(() => {
	        //console.log(this.store.get().localBrowserTime);
	        // console.log(error.stack);

	        this.store.signal('action', { action: 'errors', scope: 'gui', payload: error.stack });
	      }, 300); // we wait for the store to connect! we could still miss some messages by sending to currently unconnected store though
	    } else {
	      errors.push({ msg: `"${msg}" (No more info because of CORS, fix: 1) check for the same error on device where gui runs on :80... 2) if more possible errors from this source, then rethrow - see example in dmt-connect/browser/connect around JSON.parse(msg))`, corsProblem: true, time });
	    }

	    this.set({ errors });

	    // COPIED FROM SOMEWHERE ELSE FOR REFERENCE, MAYBE REMOVE IN THE FUTURE...
	    // if we don't do this and we get GUI from different port than 80 (7777) for example, then window.onerror will only get:
	    // "Script error." message without the error object
	    // read more here: https://blog.sentry.io/2016/05/17/what-is-script-error
	    // } else {
	    //   log.error(errMsg);
	    //   log.write(e);
	    // }

	    //return true; // means we caught the error and console won't show it anymore ....
	  };

	  // setTimeout(() => {
	  //   throw new Error("BOOM!")
	  // }, 3000)
	  // throw new Error("BOOM!");

	  window.onpopstate = (event) => {
	    this.saveGetParams();
	    if(!event.state) { // not sure why the first popstate doesn't include anything...
	      this.switchView(this.scope);
	      return;
	    }
	    this.switchView(event.state.view);
	  };

	  const path = window.location.pathname.replace(/\//g, ''); // "/home/"" => "home"

	  // used in multi-connected store reload, to keep connection to correct store!
	  const urlParams = new URLSearchParams(window.location.search);
	  const deviceKey = urlParams.get('deviceKey');
	  const initialIp = urlParams.get('ip');
	  const port = urlParams.get('port');
	  if(initialIp) {
	    setTimeout(() => {
	      const deviceName = urlParams.get('deviceName');
	      this.store.switch({ deviceKey, ip: initialIp, port, deviceName });
	      //this.store.switch({ ip: '192.168.0.80' })
	    }, 100);
	  }

	  this.saveGetParams();
	  this.switchView(path || this.scope);

	  // showDetails attribute is connected to the "alien panel" --
	  // if the panel is open, then more song information is visible
	  // (for example: duration)
	  // this.store.bus.on('showPlayerDetails', (showDetails) => {
	  //   this.set({ showDetails });
	  // });
	}
	const file$A = "src/App.html";

	function get_each_context_1$5(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.wallpaper = list[i];
		return child_ctx;
	}

	function get_each_context$b(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.error = list[i];
		return child_ctx;
	}

	function create_main_fragment$D(component, ctx) {
		var title_value, text0, div2, text1, text2, div0, text3, div1, text4, text5, current_block_type_index, if_block1, text6, text7, current;

		document.title = title_value = ctx.selectedDeviceName ? `${ctx.selectedDeviceName} - ${ctx.$view}` : 'DMT';

		var actionbar = new ActionBar({
			root: component.root,
			store: component.store
		});

		actionbar.on("select", function(event) {
			component.select(event.view);
		});

		var nearbydevices = new NearbyDevices({
			root: component.root,
			store: component.store
		});

		var sidebarmenus = new SidebarMenus({
			root: component.root,
			store: component.store
		});

		var sidebarbottoms = new SidebarBottoms({
			root: component.root,
			store: component.store
		});

		var sidebar = new Sidebar({
			root: component.root,
			store: component.store,
			slots: { default: createFragment(), sidebar_bottom: createFragment(), sidebar_menu: createFragment() }
		});

		var if_block0 = (ctx.errors && ctx.errors.length > 0) && create_if_block_11$5(component, ctx);

		var if_block_creators = [
			create_if_block_3$h,
			create_else_block$a
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.$view == 'home') return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);

		var if_block2 = (ctx.$thisDeviceState && ctx.$thisDeviceState.device && ctx.$thisDeviceState.device.showFrontendLog) && create_if_block_2$k(component);

		var if_block3 = (ctx.wallpapers) && create_if_block$z(component, ctx);

		return {
			c: function create() {
				text0 = createText("\n\n");
				div2 = createElement("div");
				actionbar._fragment.c();
				text1 = createText("\n\n  ");
				nearbydevices._fragment.c();
				text2 = createText("\n\n  ");
				div0 = createElement("div");
				sidebarmenus._fragment.c();
				text3 = createText("\n    ");
				div1 = createElement("div");
				sidebarbottoms._fragment.c();
				sidebar._fragment.c();
				text4 = createText("\n\n  ");
				if (if_block0) if_block0.c();
				text5 = createText("\n\n  ");
				if_block1.c();
				text6 = createText("\n\n  ");
				if (if_block2) if_block2.c();
				text7 = createText("\n\n  \n  ");
				if (if_block3) if_block3.c();
				setAttribute(div0, "slot", "sidebar_menu");
				div0.className = "svelte-1y54rwl";
				addLoc(div0, file$A, 11, 4, 263);
				setAttribute(div1, "slot", "sidebar_bottom");
				div1.className = "svelte-1y54rwl";
				addLoc(div1, file$A, 14, 4, 327);
				div2.id = "app";
				div2.className = "svelte-1y54rwl";
				toggleClass(div2, "preventPointerEvents", ctx.preventPointerEvents);
				addLoc(div2, file$A, 4, 0, 113);
			},

			m: function mount(target, anchor) {
				insert(target, text0, anchor);
				insert(target, div2, anchor);
				actionbar._mount(div2, null);
				append(div2, text1);
				nearbydevices._mount(div2, null);
				append(div2, text2);
				append(sidebar._slotted.sidebar_menu, div0);
				sidebarmenus._mount(div0, null);
				append(sidebar._slotted.default, text3);
				append(sidebar._slotted.sidebar_bottom, div1);
				sidebarbottoms._mount(div1, null);
				sidebar._mount(div2, null);
				append(div2, text4);
				if (if_block0) if_block0.m(div2, null);
				append(div2, text5);
				if_blocks[current_block_type_index].m(div2, null);
				append(div2, text6);
				if (if_block2) if_block2.m(div2, null);
				append(div2, text7);
				if (if_block3) if_block3.m(div2, null);
				current = true;
			},

			p: function update(changed, ctx) {
				if ((!current || changed.selectedDeviceName || changed.$view) && title_value !== (title_value = ctx.selectedDeviceName ? `${ctx.selectedDeviceName} - ${ctx.$view}` : 'DMT')) {
					document.title = title_value;
				}

				if (ctx.errors && ctx.errors.length > 0) {
					if (if_block0) {
						if_block0.p(changed, ctx);
					} else {
						if_block0 = create_if_block_11$5(component, ctx);
						if_block0.c();
						if_block0.m(div2, text5);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if_block1.o(function() {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});

					if_block1 = if_blocks[current_block_type_index];
					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
						if_block1.c();
					}
					if_block1.m(div2, text6);
				}

				if (ctx.$thisDeviceState && ctx.$thisDeviceState.device && ctx.$thisDeviceState.device.showFrontendLog) {
					if (!if_block2) {
						if_block2 = create_if_block_2$k(component);
						if_block2.c();
					}
					if_block2.i(div2, text7);
				} else if (if_block2) {
					if_block2.o(function() {
						if_block2.d(1);
						if_block2 = null;
					});
				}

				if (ctx.wallpapers) {
					if (if_block3) {
						if_block3.p(changed, ctx);
					} else {
						if_block3 = create_if_block$z(component, ctx);
						if (if_block3) if_block3.c();
					}

					if_block3.i(div2, null);
				} else if (if_block3) {
					if_block3.o(function() {
						if_block3.d(1);
						if_block3 = null;
					});
				}

				if (changed.preventPointerEvents) {
					toggleClass(div2, "preventPointerEvents", ctx.preventPointerEvents);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				outrocallback = callAfter(outrocallback, 8);

				if (actionbar) actionbar._fragment.o(outrocallback);
				if (nearbydevices) nearbydevices._fragment.o(outrocallback);
				if (sidebarmenus) sidebarmenus._fragment.o(outrocallback);
				if (sidebarbottoms) sidebarbottoms._fragment.o(outrocallback);
				if (sidebar) sidebar._fragment.o(outrocallback);

				if (if_block1) if_block1.o(outrocallback);
				else outrocallback();

				if (if_block2) if_block2.o(outrocallback);
				else outrocallback();

				if (if_block3) if_block3.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text0);
					detachNode(div2);
				}

				actionbar.destroy();
				nearbydevices.destroy();
				sidebarmenus.destroy();
				sidebarbottoms.destroy();
				sidebar.destroy();
				if (if_block0) if_block0.d();
				if_blocks[current_block_type_index].d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
			}
		};
	}

	// (20:2) {#if errors && errors.length > 0}
	function create_if_block_11$5(component, ctx) {
		var div;

		var each_value = ctx.errors.slice(0, 3);

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block_1$5(component, get_each_context$b(ctx, each_value, i));
		}

		return {
			c: function create() {
				div = createElement("div");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
				div.className = "errors svelte-1y54rwl";
				addLoc(div, file$A, 20, 4, 445);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(div, null);
				}
			},

			p: function update(changed, ctx) {
				if (changed.errors) {
					each_value = ctx.errors.slice(0, 3);

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$b(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block_1$5(component, child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}
					each_blocks.length = each_value.length;
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				destroyEach(each_blocks, detach);
			}
		};
	}

	// (29:10) {#if error.stacktrace}
	function create_if_block_12$5(component, ctx) {
		var text_value = ctx.error.stacktrace, text;

		return {
			c: function create() {
				text = createText(text_value);
			},

			m: function mount(target, anchor) {
				insert(target, text, anchor);
			},

			p: function update(changed, ctx) {
				if ((changed.errors) && text_value !== (text_value = ctx.error.stacktrace)) {
					setData(text, text_value);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(text);
				}
			}
		};
	}

	// (22:6) {#each errors.slice(0, 3) as error}
	function create_each_block_1$5(component, ctx) {
		var div1, div0, text0, span0, text1_value = ctx.error.time, text1, text2, span1, text3_value = ctx.error.msg, text3, text4;

		var if_block = (ctx.error.stacktrace) && create_if_block_12$5(component, ctx);

		return {
			c: function create() {
				div1 = createElement("div");
				div0 = createElement("div");
				text0 = createText("Error at ");
				span0 = createElement("span");
				text1 = createText(text1_value);
				text2 = createText("\n            ");
				span1 = createElement("span");
				text3 = createText(text3_value);
				text4 = createText("\n\n          ");
				if (if_block) if_block.c();
				span0.className = "time svelte-1y54rwl";
				addLoc(span0, file$A, 24, 21, 626);
				span1.className = "msg svelte-1y54rwl";
				addLoc(span1, file$A, 25, 12, 677);
				div0.className = "title svelte-1y54rwl";
				addLoc(div0, file$A, 23, 10, 585);
				div1.className = "error svelte-1y54rwl";
				toggleClass(div1, "cors_problem", ctx.error.corsProblem);
				addLoc(div1, file$A, 22, 8, 516);
			},

			m: function mount(target, anchor) {
				insert(target, div1, anchor);
				append(div1, div0);
				append(div0, text0);
				append(div0, span0);
				append(span0, text1);
				append(div0, text2);
				append(div0, span1);
				append(span1, text3);
				append(div1, text4);
				if (if_block) if_block.m(div1, null);
			},

			p: function update(changed, ctx) {
				if ((changed.errors) && text1_value !== (text1_value = ctx.error.time)) {
					setData(text1, text1_value);
				}

				if ((changed.errors) && text3_value !== (text3_value = ctx.error.msg)) {
					setData(text3, text3_value);
				}

				if (ctx.error.stacktrace) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_12$5(component, ctx);
						if_block.c();
						if_block.m(div1, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (changed.errors) {
					toggleClass(div1, "cors_problem", ctx.error.corsProblem);
				}
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div1);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (43:2) {:else}
	function create_else_block$a(component, ctx) {
		var div, current_block_type_index, if_block, current;

		var if_block_creators = [
			create_if_block_5$e,
			create_if_block_6$a,
			create_if_block_7$a,
			create_if_block_8$8,
			create_if_block_9$7,
			create_if_block_10$6
		];

		var if_blocks = [];

		function select_block_type_1(ctx) {
			if (ctx.$view == 'player') return 0;
			if (ctx.$view == 'clock') return 1;
			if (ctx.$view == 'apps') return 2;
			if (ctx.$view == 'ambience') return 3;
			if (ctx.$view == 'help') return 4;
			if (ctx.$view == 'device') return 5;
			return -1;
		}

		if (~(current_block_type_index = select_block_type_1(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
		}

		return {
			c: function create() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.className = "content_component svelte-1y54rwl";
				toggleClass(div, "dim_background", ctx.viewDef && ctx.viewDef.dimBackground);
				toggleClass(div, "has_full_sidebar", ctx.viewDef && ctx.viewDef.sidebar == 'true');
				addLoc(div, file$A, 44, 4, 975);
			},

			m: function mount(target, anchor) {
				insert(target, div, anchor);
				if (~current_block_type_index) if_blocks[current_block_type_index].m(div, null);
				current = true;
			},

			p: function update(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);
				if (current_block_type_index !== previous_block_index) {
					if (if_block) {
						if_block.o(function() {
							if_blocks[previous_block_index].d(1);
							if_blocks[previous_block_index] = null;
						});
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];
						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](component, ctx);
							if_block.c();
						}
						if_block.m(div, null);
					} else {
						if_block = null;
					}
				}

				if (changed.viewDef) {
					toggleClass(div, "dim_background", ctx.viewDef && ctx.viewDef.dimBackground);
					toggleClass(div, "has_full_sidebar", ctx.viewDef && ctx.viewDef.sidebar == 'true');
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (detach) {
					detachNode(div);
				}

				if (~current_block_type_index) if_blocks[current_block_type_index].d();
			}
		};
	}

	// (37:2) {#if $view == 'home'}
	function create_if_block_3$h(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.$device) && create_if_block_4$f(component);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.$device) {
					if (!if_block) {
						if_block = create_if_block_4$f(component);
						if_block.c();
					}
					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (56:33) 
	function create_if_block_10$6(component, ctx) {
		var current;

		var device = new Device({
			root: component.root,
			store: component.store
		});

		device.on("select", function(event) {
			component.select(event.view);
		});

		return {
			c: function create() {
				device._fragment.c();
			},

			m: function mount(target, anchor) {
				device._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (device) device._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				device.destroy(detach);
			}
		};
	}

	// (54:31) 
	function create_if_block_9$7(component, ctx) {
		var current;

		var help = new Help({
			root: component.root,
			store: component.store
		});

		help.on("select", function(event) {
			component.select(event.view);
		});

		return {
			c: function create() {
				help._fragment.c();
			},

			m: function mount(target, anchor) {
				help._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (help) help._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				help.destroy(detach);
			}
		};
	}

	// (52:35) 
	function create_if_block_8$8(component, ctx) {
		var current;

		var ambience = new Ambience({
			root: component.root,
			store: component.store
		});

		ambience.on("select", function(event) {
			component.select(event.view);
		});

		return {
			c: function create() {
				ambience._fragment.c();
			},

			m: function mount(target, anchor) {
				ambience._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (ambience) ambience._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				ambience.destroy(detach);
			}
		};
	}

	// (50:31) 
	function create_if_block_7$a(component, ctx) {
		var current;

		var apps = new AppList({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				apps._fragment.c();
			},

			m: function mount(target, anchor) {
				apps._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (apps) apps._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				apps.destroy(detach);
			}
		};
	}

	// (48:32) 
	function create_if_block_6$a(component, ctx) {
		var current;

		var clock = new Clock_1({
			root: component.root,
			store: component.store
		});

		clock.on("select", function(event) {
			component.select(event.view);
		});

		return {
			c: function create() {
				clock._fragment.c();
			},

			m: function mount(target, anchor) {
				clock._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (clock) clock._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				clock.destroy(detach);
			}
		};
	}

	// (46:6) {#if $view == 'player'}
	function create_if_block_5$e(component, ctx) {
		var current;

		var player = new Player({
			root: component.root,
			store: component.store
		});

		player.on("select", function(event) {
			component.select(event.view);
		});

		return {
			c: function create() {
				player._fragment.c();
			},

			m: function mount(target, anchor) {
				player._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (player) player._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				player.destroy(detach);
			}
		};
	}

	// (39:4) {#if $device}
	function create_if_block_4$f(component, ctx) {
		var current;

		var home = new Home({
			root: component.root,
			store: component.store
		});

		home.on("select", function(event) {
			component.select(event.view);
		});

		return {
			c: function create() {
				home._fragment.c();
			},

			m: function mount(target, anchor) {
				home._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (home) home._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				home.destroy(detach);
			}
		};
	}

	// (63:2) {#if $thisDeviceState && $thisDeviceState.device && $thisDeviceState.device.showFrontendLog}
	function create_if_block_2$k(component, ctx) {
		var current;

		var infobar = new InfoBar({
			root: component.root,
			store: component.store
		});

		return {
			c: function create() {
				infobar._fragment.c();
			},

			m: function mount(target, anchor) {
				infobar._mount(target, anchor);
				current = true;
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (infobar) infobar._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				infobar.destroy(detach);
			}
		};
	}

	// (68:2) {#if wallpapers}
	function create_if_block$z(component, ctx) {
		var each_anchor, current;

		var each_value_1 = ctx.wallpapers;

		var each_blocks = [];

		for (var i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block$b(component, get_each_context_1$5(ctx, each_value_1, i));
		}

		function outroBlock(i, detach, fn) {
			if (each_blocks[i]) {
				each_blocks[i].o(() => {
					if (detach) {
						each_blocks[i].d(detach);
						each_blocks[i] = null;
					}
					if (fn) fn();
				});
			}
		}

		return {
			c: function create() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_anchor = createComment();
			},

			m: function mount(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].i(target, anchor);
				}

				insert(target, each_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (changed.wallpapers) {
					each_value_1 = ctx.wallpapers;

					for (var i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
						} else {
							each_blocks[i] = create_each_block$b(component, child_ctx);
							each_blocks[i].c();
						}
						each_blocks[i].i(each_anchor.parentNode, each_anchor);
					}
					for (; i < each_blocks.length; i += 1) outroBlock(i, 1);
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				each_blocks = each_blocks.filter(Boolean);
				const countdown = callAfter(outrocallback, each_blocks.length);
				for (let i = 0; i < each_blocks.length; i += 1) outroBlock(i, 0, countdown);

				current = false;
			},

			d: function destroy(detach) {
				destroyEach(each_blocks, detach);

				if (detach) {
					detachNode(each_anchor);
				}
			}
		};
	}

	// (70:6) {#if wallpaper}
	function create_if_block_1$r(component, ctx) {
		var current;

		var imagepreload_initial_data = { path: ctx.wallpaper };
		var imagepreload = new ImagePreload({
			root: component.root,
			store: component.store,
			data: imagepreload_initial_data
		});

		return {
			c: function create() {
				imagepreload._fragment.c();
			},

			m: function mount(target, anchor) {
				imagepreload._mount(target, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				var imagepreload_changes = {};
				if (changed.wallpapers) imagepreload_changes.path = ctx.wallpaper;
				imagepreload._set(imagepreload_changes);
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (imagepreload) imagepreload._fragment.o(outrocallback);
				current = false;
			},

			d: function destroy(detach) {
				imagepreload.destroy(detach);
			}
		};
	}

	// (69:4) {#each wallpapers as wallpaper}
	function create_each_block$b(component, ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.wallpaper) && create_if_block_1$r(component, ctx);

		return {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
				current = true;
			},

			p: function update(changed, ctx) {
				if (ctx.wallpaper) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1$r(component, ctx);
						if (if_block) if_block.c();
					}

					if_block.i(if_block_anchor.parentNode, if_block_anchor);
				} else if (if_block) {
					if_block.o(function() {
						if_block.d(1);
						if_block = null;
					});
				}
			},

			i: function intro(target, anchor) {
				if (current) return;

				this.m(target, anchor);
			},

			o: function outro(outrocallback) {
				if (!current) return;

				if (if_block) if_block.o(outrocallback);
				else outrocallback();

				current = false;
			},

			d: function destroy(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	function App(options) {
		this._debugName = '<App>';
		if (!options || (!options.target && !options.root)) {
			throw new Error("'target' is a required option");
		}
		if (!options.store) {
			throw new Error("<App> references store properties, but no store was provided");
		}

		init(this, options);
		this._state = assign(this.store._init(["view","device","thisDeviceState"]), options.data);
		this.store._add(this, ["view","device","thisDeviceState"]);
		if (!('selectedDeviceName' in this._state)) console.warn("<App> was created without expected data property 'selectedDeviceName'");
		if (!('$view' in this._state)) console.warn("<App> was created without expected data property '$view'");
		if (!('preventPointerEvents' in this._state)) console.warn("<App> was created without expected data property 'preventPointerEvents'");
		if (!('errors' in this._state)) console.warn("<App> was created without expected data property 'errors'");
		if (!('$device' in this._state)) console.warn("<App> was created without expected data property '$device'");
		if (!('viewDef' in this._state)) console.warn("<App> was created without expected data property 'viewDef'");
		if (!('$thisDeviceState' in this._state)) console.warn("<App> was created without expected data property '$thisDeviceState'");
		if (!('wallpapers' in this._state)) console.warn("<App> was created without expected data property 'wallpapers'");
		this._intro = !!options.intro;

		this._handlers.destroy = [removeFromStore];

		this._fragment = create_main_fragment$D(this, this._state);

		this.root._oncreate.push(() => {
			oncreate$x.call(this);
			this.fire("update", { changed: assignTrue({}, this._state), current: this._state });
		});

		if (options.target) {
			if (options.hydrate) throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			this._fragment.c();
			this._mount(options.target, options.anchor);

			flush(this);
		}

		this._intro = true;
	}

	assign(App.prototype, protoDev);
	assign(App.prototype, methods$m);

	App.prototype._checkReadOnly = function _checkReadOnly(newState) {
	};

	// doing just const store = new ConnectedStore() probably doesn't work anymore... (but it should be a small fix!! -- not that anyone would want that but still!! Multi-connected stores are great.)
	const store = new MultiConnectedStore();

	// source: https://stackoverflow.com/a/9216488
	const log$2 = console.log.bind(console);
	console.log = (...args) => {
	  store.addToFrontendLog(...args);
	  log$2(...args);
	};

	const app = new App({
	  target: document.body,
	  store
	});

	window.store = store;

	return app;

}(crypto));
//# sourceMappingURL=bundle.js.map
